
/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfında capacity kullanılır ancak nasıl büyütüleceği söylenmez. Bu sebeple ArrayList sınıfının
    capacity değerini veren bir metodu yoktur. Bu sebeple capacity bilgisi gereken kodlarda Vector sınıfı ile örnekler
    yazılacaktır. Vector sınıfı burada anlatılmayan farklılıkları ve capacity bilgisini elde edebilmemiz dışında
    ArrayList ile aynı düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının default ctor elemanı ile capcity değerini 10 olarak nesne yaratılır. Vector
    sınıfının capacity metodu capacity değerini döndürür. ArrayList/Vector sınıfının size metodu tutulan eleman sayısı
    bilgisini döndürür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector();

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının capacity parametreli ctor elemanı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector(23);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının add metodu sona eklemek için kullanılır. Şüphesiz bu metot gerektiğinde capacity
    değerini de uygun şekilde (amortized constant time) büyütür. Vector sınıfının default capacity büyütmesi
    var olan capacity değerinin iki katı olacak şekildedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector(6);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        for (int i = 0; i < 12; ++i)
            numbers.add(i * 10);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        numbers.add(67);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının index parametreli add metodu araya ekleme yapmak için kullanılabilir. Bu metot
    O(n) karmaşıklıktadır. Şüphesiz bu metot gerektiğin capacity değerini uygun şekilde büyütür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector(6);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        for (int i = 0; i < 12; ++i)
            numbers.add(0, i * 10);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        numbers.add(2, 67);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının get metodu ile bir indeksteki eleman elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList(6);

        for (int i = 0; i < 12; ++i)
            numbers.add(i * 10);

        int size = numbers.size();

        for (int i = 0; i < size; ++i) {
            int val = (int)numbers.get(i);

            System.out.printf("%d ", val);
        }

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının get metoduna pozitif ya da negatif bakımdan sınırlar dışında bir indeks numarası
    verildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList(6);

        for (int i = 0; i < 12; ++i)
            numbers.add(i * 10);

        int size = numbers.size();

        int val = (int)numbers.get(13);

        System.out.println(val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfı for-each döngü deyimi ile dolaşılabilir (iterable) bir sınıftır. for-each döngü deyiminin
    her adımında içeride tutulan eleman sırasıyla elde edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList(6);

        for (int i = 0; i < 10; ++i)
            numbers.add(i * 10);

        for (Object obj : numbers) {
            int val = (int)obj;

            System.out.printf("%d ", val);
        }

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının isEmpty metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList(6);

        numbers.add(23);

        System.out.println(numbers.isEmpty() ? "Boş" : "Dolu");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının set metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList numbers = new ArrayList();

        for (int i = 0; i < 20; ++i)
            numbers.add(i * 10);

        for (Object o : numbers) {
            int val = (int)o;

            System.out.printf("%d ", val);
        }

        System.out.println();

        int oldValue = (int)numbers.set(2, 67);

        for (Object o : numbers) {
            int val = (int)o;

            System.out.printf("%d ", val);
        }

        System.out.println();
        System.out.printf("Old Value:%d%n", oldValue);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının clear metodu tüm elemanları siler. Bu sınıflarda silme yapan metotlar yani size değerini
    azaltan metotlar capacity değerini değiştirmezler
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector();

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        for (int i = 0; i < 15; ++i)
            numbers.add(i * 10);

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        numbers.clear();

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının remove metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector numbers = new Vector();

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        for (int i = 0; i < 15; ++i)
            numbers.add(i * 10);


        for (Object o : numbers) {
            int val = (int)o;

            System.out.printf("%d ", val);
        }
        System.out.println();

        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());

        int oldVal = (int)numbers.remove(2);

        for (Object o : numbers) {
            int val = (int)o;

            System.out.printf("%d ", val);
        }
        System.out.println();

        System.out.printf("Old value:%d%n", oldVal);
        System.out.printf("Capacity:%d%n", numbers.capacity());
        System.out.printf("Size:%d%n", numbers.size());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir dizinin mantıksal dinamik büyütülmesine ilişkin basit bir örnek kod yazılmıştır.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;
import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        ArrayListTest.run();
    }
}

class ArrayListTest {
    private static final int DEFAULT_CAPACITY = 3;

    public static void run()
    {
        Scanner kb = new Scanner(System.in);
        int index = 0;
        Vector list = new Vector(DEFAULT_CAPACITY);

        for (;;) {
            System.out.print("Bir sayı giriniz:");
            int val = Integer.parseInt(kb.nextLine());

            if (val == 0)
                break;

            list.add(val);

            System.out.printf("Size:%d%n", list.size());
            System.out.printf("Capacity:%d%n", list.capacity());
        }

        for (Object o : list) {
            int val = (int)o;

            System.out.printf("%d ", val);
        }

        System.out.println();

        System.out.println("Tekrar yapıyor musunuz?");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    ArrayList sınıfının trimToSize metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Random;
import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector passwords = new Vector();
        Random r = new Random();

        for (int i = 0; i < 15; ++i)
            passwords.add(StringUtil.generateRandomPassword(10));

        for (Object o : passwords)
            System.out.println((String)o);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.trimToSize();

        System.out.println("**************************************");
        for (Object o : passwords)
            System.out.println((String)o);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Vector sınıfının trimToSize metodu size sıfır ise capacity değerini de sıfır yapar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Random;
import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector passwords = new Vector();
        Random r = new Random();

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.trimToSize();

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.add(StringUtil.generateRandomPassword(r, 10));

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.add(StringUtil.generateRandomPassword(r, 5));

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.add(StringUtil.generateRandomPassword(r, 15));

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayList/Vector sınıfının ensureCapcity metodu capacity değerini aşağıdaki şekilde değiştirmekte (veya değiştirememekte)
    kullanılabilir:
    - Yeni capacity değeri var olan capacity değerinden küçük ve eşitse değişiklik yopmaz
    - Yeni capacity değeri var olan capacity değerinin artması gereken değerinden küçük veya eşitse
    artması gereken değere çeker
    - Yeni capacity değeri var olan capacity değerinin artması gereken değerinden büyükse yeni capacity değerine çeker
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.StringUtil;

import java.util.Random;
import java.util.Vector;

class App {
    public static void main(String [] args)
    {
        Vector passwords = new Vector();
        Random r = new Random();

        for (int i = 0; i < 15; ++i)
            passwords.add(StringUtil.generateRandomPassword(r, 10));

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(17);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(30);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());

        passwords.ensureCapacity(87);

        System.out.printf("Size:%d%n", passwords.size());
        System.out.printf("Capacity:%d%n", passwords.capacity());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    null, referans türlerine atanabilen kullanılmayan adresi temsil eden bir anahtar sözcüktür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

class App {
    public static void main(String [] args)
    {
        String s = null;
        Random r = null;
        Sample k = null;
        int [] a = null;
        Integer iVal = null;
        double val = null; //error

        //...
    }
}

enum Sample {

}

/*----------------------------------------------------------------------------------------------------------------------
    05.04.2020
    Bir referansın içerisinde null değeri olup olmadığı == veya != operatörleri ile test edilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = null;

        System.out.println(s == null);
        System.out.println(s != null);
    }
}


class Sample {

}

/*----------------------------------------------------------------------------------------------------------------------
    Bir referansın default değeri null'dır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A a = new A();

        System.out.println(a.b == null);
    }
}

class B {

}

class A {
    public B b;
}

/*----------------------------------------------------------------------------------------------------------------------
    İçerisinde null değeri olan bir referans ile sınıfın elemanlarına erişim exception oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        String s = null;

        System.out.println(s.toLowerCase());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    İçerisinde null değeri olan bir referans ile sınıfın elemanlarına erişim exception oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        String [] str = new String[10];

        for (String s : str)
            System.out.println(s.toLowerCase());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    null değer kontrol amaçlı kullanılabilir. Yani bir referansın nesne gösterip göstermediği testi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Singleton s = Singleton.getInstance();
        Singleton k = Singleton.getInstance();

        System.out.println(k == s);
    }
}

class Singleton {
    //...
    private static Singleton ms_instance;

    private Singleton() {}

    public static Singleton getInstance()
    {
        if (ms_instance == null)
            ms_instance = new Singleton();

        return ms_instance;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ArrayUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public final class ArrayUtil {
    private ArrayUtil() {}

    private static void copy(int [] src, int [] dest)
    {
        copy(src, dest, src.length);
    }

    private static void copy(int [] src, int [] dest, int n)
    {
        for (int i = 0; i < n; ++i)
            dest[i] = src[i];
    }

    public static double average(int [] a)
    {
        return  (double)sum(a) / a.length;
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void bubbleSort(int [] a, boolean desc)
    {
        if (desc) {
            for (int i = 0; i < a.length - 1; ++i) {
                for (int k = 0; k < a.length - 1 - i; ++k)
                    if (a[k] < a[k + 1]) {
                        int temp = a[k];
                        a[k] = a[k + 1];
                        a[k + 1] = temp;
                    }
            }
        }
        else {
            for (int i = 0; i < a.length - 1; ++i) {
                for (int k = 0; k < a.length - 1 - i; ++k)
                    if (a[k] > a[k + 1]) {
                        int temp = a[k];
                        a[k] = a[k + 1];
                        a[k + 1] = temp;
                    }
            }
        }
    }

    public static void display(int [] a)
    {
        display(a, 1);
    }

    public static void display(int [] a, int n)
    {
        display(a, n, a.length);
    }

    public static void display(int [] a, int n, int len)
    {
        String fmt = String.format("%%0%dd ", n);

        for (int i = 0; i < len; ++i)
            System.out.printf(fmt, a[i]);

        System.out.println();
    }

    public static void display(int [][] a)
    {
        display(a, 1);
    }
    public static void display(int [][] a, int n)
    {
        for (int [] array : a)
            display(array, n);
    }

    public static void drawHistogram(int [] hist, int n, char ch)
    {
        int maxVal = max(hist);

        for (int val : hist) {
            int nCh = val * n / maxVal;

            while (nCh-- > 0)
                System.out.print(ch);

            System.out.println();
        }
    }

    public static int [] enlarge(int [] a, int newLen)
    {
        if (newLen <= a.length)
            return a;

        return resize(a, newLen);
    }

    public static int [] getHistogramData(int [] a, int n) //[0, n]
    {
        int [] counts = new int[n + 1];

        for (int val : a)
            ++counts[val];

        return counts;
    }

    public static int[] getRandomArray(int n, int min, int max) //[min, max)
    {
        return getRandomArray(null, n, min, max);
    }

    public static int[] getRandomArray(Random r, int n, int min, int max) //[min, max)
    {
        if (r == null)
            r = new Random();

        int [] a = new int[n];

        for (int i = 0; i < n; ++i)
            a[i] = r.nextInt(max - min) + min;

        return a;
    }

    public static int[][] getRandomMatrix(int m, int n, int min, int max) //[min, max)
    {
        return getRandomMatrix(null, m, n, min, max);
    }

    public static int[][] getRandomMatrix(Random r, int m, int n, int min, int max) //[min, max)
    {
        if (r == null)
            r = new Random();

        int [][] a = new int[m][];

        for (int i = 0; i < m; ++i)
            a[i] = getRandomArray(r, n, min, max);

        return a;
    }

    public static int [][] getRandomSquareMatrix(int n, int min, int max)
    {
        return getRandomSquareMatrix(new Random(), n, min, max);
    }

    public static int [][] getRandomSquareMatrix(Random r, int n, int min, int max)
    {
        return getRandomMatrix(r, n, n, min, max);
    }

    public static int [][] getTransposedMatrix(int [][] a)
    {
        if (!isMatrix(a))
            return new int[0][];

        int row = a[0].length;
        int col = a.length;
        int [][] t = new int[row][col];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                t[i][j] = a[j][i];

        return t;
    }

    public static boolean isMatrix(int [][] a)
    {
        int col = a[0].length;

        for (int i = 1; i < a.length; ++i)
            if (a[i].length != col)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static String join(String [] s, char delim)
    {
        return join(s, delim + "");
    }

    public static  String join(String [] s, String delim)
    {
        String str = "";

        for (String sval : s)
            str += sval + delim;

        return str.substring(0, str.length() - delim.length());
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            result = Math.max(result, a[i]);

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            result = Math.min(result, a[i]);

        return result;
    }

    public static int [] resize(int [] a, int newLen)
    {
        int [] res = new int[newLen];

        copy(a, res, a.length);

        return res;
    }


    public static void reverse(int [] a) //by Emre Onsur
    {
        int temp;
        int halfLen = a.length / 2;

        for(int i = 0; i < halfLen; ++i) {
            temp = a[i];
            a[i] = a[a.length - 1 - i];
            a[a.length - 1 - i] = temp;
        }
    }

    public static void reverse(char [] a)
    {
        char temp;
        int halfLen = a.length / 2;

        for(int i = 0; i < halfLen; ++i) {
            temp = a[i];
            a[i] = a[a.length - 1 - i];
            a[a.length - 1 - i] = temp;
        }
    }

    public static int sum(int [] a)
    {
        int result = 0;

        for (int val : a)
            result += val;

        return result;
    }

    public static int sumDiagonal(int [][] a)
    {
        //...
        int sum = 0;

        for (int i = 0; i < a.length; ++i)
            sum += a[i][i];

        return sum;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    null referans metotların gerçeriz durumlarda döndürdüğü değer olarak da kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

class App {
    public static void main(String [] args)
    {
        double [] a = Util.getRandomArray(new Random(), 10, 20, 10);

        System.out.println(a == null);
    }
}

class Util {
    public static double[] getRandomArray(Random r, int n, double min, double max)
    {
        if (r == null || n <= 0 || min >= max)
            return null;

        double [] a = new double[n];

        for (int i = 0; i < n; ++i)
            a[i] = r.nextDouble() * (max - min) + min;

        return a;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte derleyici programcının algoritmasını anlayamacağı için (ya da anlamak zorunda olmadığı için)
    s referansına değer atanmazsa switch deyiminden sonra error oluşur. Bu error'u engellemek için null
    değeri kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        if (val < 1 || val > 3) {
            System.out.println("Geçersiz değerleri");
            return;
        }

        Sample s = null;

        switch (val) {
            case 1:
                s = new Sample(10);
                break;
            case 2:
                s = new Sample(34);
                break;
            case 3:
                s = new Sample(46);
                break;
        }

        System.out.println(s.getVal());
    }
}

class Sample {
    private int m_val;

    public Sample(int val)
    {
        m_val = val;
    }

    public int getVal()
    {
        return m_val;
    }

    public void setVal(int val)
    {
        m_val = val;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte derleyici programcının algoritmasını anlayamacağı için (ya da anlamak zorunda olmadığı için)
    s referansına değer atanmazsa switch deyiminden sonra error oluşur. Bu error'u engellemek için null
    değeri kullanılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        if (val < 1 || val > 3) {
            System.out.println("Geçersiz değerleri");
            return;
        }

        Sample s = null;

        switch (val) {
            case 1:
                s = new Sample(10);
                break;
            case 2:
                s = new Sample(34);
                break;
            case 3:
                s = new Sample(46);
                break;
        }

        System.out.println(s.getVal());
    }
}

class Sample {
    private int m_val;

    public Sample(int val)
    {
        m_val = val;
    }

    public int getVal()
    {
        return m_val;
    }

    public void setVal(int val)
    {
        m_val = val;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir nesne garbage colloctor denilen çöp toplayıcı tarafından yok edilir. Bir nesnenin artık kullanılmadığına
    yönelik çeşitli algoritmalar kullanılır. Bunlardan en tipik olan referans sayma yöntemidir. Bu yönteme göre
    yaratılmış her nesne için bir referans sayacı tutulur. Nesnenin her referansa atanması durumunda bu sayaç bir
    artırılır her referanstan kopartılması durumunda da bir azaltılır. Bir nesne için sayaç sıfır değerine
    gelmişse nesne artık kullanılmıyor durumdadır yani çöp olmuştur. Buna İngilizce olarak "garbage collected" veya
    "eligible" terimi kullanılmaktadır. Bir nesne kullanılmıyor durumda iken çöp toplayıcı program (garbage collector)
    devre girdiğinde yok edilir. Çöp toplayıcı programın ne zaman devreye gireceğine yönelik bir
    standart belirlenmemiştir. Bu işlem çöp toplayıcıyı yazanlara bırakılmıştır. Ancak JRE için bunun etkinliğine
    güvenilir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte referans yöntemi kullanıldığı varsayılarak sayaçları durumu gösterilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s;

        s = new Sample(); //reference counter (rc1): 1

        {
            Sample k = s; //rc1=2

        } //rc1=1

        Mample.foo(s); //rc1=2 ---> rc1=3
        //rc1=1

        Sample k = s; //rc1=2
        s = new Sample(); //rc1 = 1, rc2=1
        s = null; //rc2:0 (garbage colected (gc))

        //Burada çöp toplayıcının geleceği garanti değil
        k = new Sample(); //rc1:0 (gc), rc3:1

        //...
    }
}

class Mample {
    public static void foo(Sample s)
    {
        Sample k = s;

        //...
    }
}

class Sample {

}


/*----------------------------------------------------------------------------------------------------------------------
    System sınıfının gc isimli metodu ile garbage collector devreye sokulabilir. Ancak bunun sürekli yapılmaması.
    Daha açık bir ifadeyle dikkatli yapılması gerekir. ünkü çoğu zaman garbage collector'ün kendi algoritmasına
    güvenilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s;

        s = new Sample(); //reference counter (rc1): 1

        {
            Sample k = s; //rc1=2

        } //rc1=1

        Mample.foo(s); //rc1=2 ---> rc1=3
        //rc1=1

        Sample k = s; //rc1=2
        s = new Sample(); //rc1 = 1, rc2=1
        s = null; //rc2:0 (garbage colected (gc))

        System.gc();

        //Burada çöp toplayıcının geleceği garanti değil
        k = new Sample(); //rc1:0 (gc), rc3:1

        //...
    }
}

class Mample {
    public static void foo(Sample s)
    {
        Sample k = s;

        //...
    }
}

class Sample {

}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.collection.CSDArrayList;

class App {
    public static void main(String [] args)
    {
        CSDArrayList list = new CSDArrayList();

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());

        for (int i = 0; i < 10; ++i)
            list.add(i * 10);

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());

        list.add(67);

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());

        list.trimToSize();

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.collection.CSDArrayList;

class App {
    public static void main(String [] args)
    {
        CSDArrayList list = new CSDArrayList();

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());

        for (int i = 0; i < 10; ++i)
            list.add(i * 10);

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());

        list.add(67);
        list.clear();

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());

        list.trimToSize();

        System.out.printf("Capacity:%d%n", list.capacity());
        System.out.printf("Size:%d%n", list.size());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.collection;

public class CSDArrayList {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void doWorkForException(String msg)
    {
        System.out.println(msg);
        System.exit(-1); //exception konusuna kadar sabredin
    }

    private static void checkForIllegalArgumentException(int capacity)
    {
        if (capacity < 0)
            doWorkForException("Invalid capacity");
    }

    private static void checkForIndexOutOfBounds(int index, int end)
    {
        if (index < 0 || index >= end)
            doWorkForException("Index out of bounds");
    }

    private void allocateCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        for (int i = 0; i < m_index; ++i)
            temp[i] = m_elems[i];

        m_elems = temp;
    }

    private void checkAndAllocCapacity(int capacity)
    {
        if (m_index < m_elems.length)
            return;

        allocateCapacity(capacity);
    }

    public CSDArrayList()
    {
        this(DEFAULT_CAPACITY);
    }

    public CSDArrayList(int initialCapacity)
    {
        checkForIllegalArgumentException(initialCapacity);
        m_elems = new Object[initialCapacity];
    }

    public boolean add(Object elem)
    {
        checkAndAllocCapacity(m_elems.length * 2);
        m_elems[m_index++] = elem;
        return true;
    }

    public void add(int index, Object elem)
    {
        checkForIndexOutOfBounds(index, m_index + 1); // add size verildiğinde sona ekler
        checkAndAllocCapacity(m_elems.length * 2);
        //TODO:
    }

    public int capacity() {return m_elems.length;}

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public Object get(int index)
    {
        checkForIndexOutOfBounds(index, m_index);

        return m_elems[index];
    }

    public Object set(int index, Object elem)
    {
        checkForIndexOutOfBounds(index, m_index);
        Object old = m_elems[index];

        m_elems[index] = elem;

        return old;
    }

    public Object remove(int index)
    {
        checkForIndexOutOfBounds(index, m_index);
        Object old = m_elems[index];

        //TODO:
        return old;
    }
    public int size() {return m_index;}

    public void trimToSize()
    {
        if (m_index == m_elems.length)
            return;

        allocateCapacity(m_index == 0 ? DEFAULT_CAPACITY : m_index);
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın içerisinde tüm metotların dışında static anahtar sözcüğü ile tanımlanan bloklara sınıfın
    static blokları (static initializers) denir. Bu bloklar istenildiği kadar tanımlanabilir. Sınıfın
    herhangi bir elamanı ilk kez kullanıldığında tüm static bloklar yukarıdan aşağıya sırasıya bir kez olmak
    üzere çalıştırılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo();
        Sample.foo();
    }
}

class Sample {
    static {
        System.out.println("static initializer1");
    }
    //...

    static {
        System.out.println("static initializer2");
    }

    static {
        System.out.println("static initializer3");
    }

    public static void foo()
    {
        //..
    }


}
/*----------------------------------------------------------------------------------------------------------------------
    static bloklar static metotlar gibidir yani bu bloklarda sınıfın yalnızca static elemanlarına erişilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo();
        Sample.foo();
    }
}

class Sample {
    static {
        System.out.println("static initializer1");
        foo();
        bar();//error
    }

    public static void foo()
    {
        //..
    }

    public void bar()
    {
        //..
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    Sınıfın final static veri elemanlarına static bloklarda değer atanabilir. Şüphesiz burada değer atanabilmesi
    için bildirim noktasında atanmamış olması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    public static final double PI;

    static {
        PI = 3.14;
    }
    //...

}
/*----------------------------------------------------------------------------------------------------------------------
    static bloğun bir kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.VAL);
        System.out.println(Sample.VAL);
    }
}

class Sample {
    public static final int VAL;

    static {
        Random r = new Random();

        Scanner kb = new Scanner(System.in);
        System.out.print("min?");
        int min = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(kb.nextLine());

        VAL = r.nextInt(max - min) + min;
    }
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    10.04.2020
    Yukarıdaki örnek özelinde static blok aşağıdaki gibi yazılan metot olarak düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.VAL);
        System.out.println(Sample.VAL);
    }
}

class Sample {
    private static int initVal()
    {
        Random r = new Random();

        Scanner kb = new Scanner(System.in);
        System.out.print("min?");
        int min = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(kb.nextLine());

        return r.nextInt(max - min) + min;
    }


    public static final int VAL = initVal();
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıf içerisindeki tüm static blokların kendi faaliyet alanları vardır. Yani aslında bunlar ayrı metotlar
    gibi düşünülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.VAL1);
        System.out.println(Sample.VAL2);
    }
}

class Sample {
    public static final int VAL1;
    public static final int VAL2;

    static {
        System.out.println("static initializer1");
        int a = 10;

        VAL1 = a * 2;
    }

    static {
        System.out.println("static initializer2");
        int a = 20;

        VAL2 = a * 3;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın non-static blokları olabilir. Bu bloklar her nesne için yukarıdan aşağıya olmak üzere çalıştırılır.
    Detaylar aşağıdaki örneklerdedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        //...
    }
}

class Sample {
    {
        System.out.println("non-static initializer1");
    }


    {
        System.out.println("non-static initializer2");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın non-static blokları olabilir. Bu bloklar her nesne için yukarıdan aşağıya olmak üzere çalıştırılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Sample k = new Sample(10);

        //...
    }
}

class Sample {
    {
        System.out.println("non-static initializer1");
    }


    {
        System.out.println("non-static initializer2");
    }

    public Sample()
    {
        System.out.println("Sample.Sample()");
    }

    public Sample(int a)
    {
        System.out.println("Sample.Sample(int)");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın non-static blokları her ctor'un başında çalıştırılacak kısımdır. Yani non-static bloğa ilişkin
    kodların her ctor'un gizlice yerleştirildiğini düşünebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Sample k = new Sample(10);

        //...
    }
}

class Sample {
    public int a;

    {
        System.out.printf("a=%d%n", a);
    }

    public Sample()
    {
        System.out.println("Sample.Sample()");
    }

    public Sample(int a)
    {
        System.out.println("Sample.Sample(int)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın ctor'u içerisinde o sınfın başka bir ctor'unun çağrılması kodu yazılmışsa (this ctor)
    bu durumda çağıran için non-static initiliazer kodu yerleştirilmez. Çünkü zaten çağrılan ctor' da ya olacaktır ya da
    o da başka bir ctor'u olsa da sonuçta yerleştirilecek bir ctor mutlaka olacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Sample k = new Sample(10);

        //...
    }
}

class Sample {
    public int a;

    {
        System.out.println("non-static initializer");
    }

    public Sample()
    {
        System.out.println("Sample.Sample()");
    }

    public Sample(int a)
    {
        this();
        System.out.println("Sample.Sample(int)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    super ctor sentaksı kullanıldığında non-static blokların çalıştırılma sırası
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B x = new B();

        System.out.println("*****************");
        B y = new B(20);

    }
}

class A {
    {
        System.out.println("non-static initializer of A");
    }

    public A()
    {
        System.out.println("A.A()");
    }

    public A(int a)
    {
        System.out.println("A.A(int)");
    }
}

class B extends A {
    {
        System.out.println("non-static initializer of B");
    }

    public B()
    {
        System.out.println("B.B()");
    }

    public B(int a)
    {
        super(a);
        System.out.println("B.B(int)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sınıfın non-static final veri elemanlarına non-static blok içerisinde değer atanabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        System.out.printf("s.val=%d%n", s.val);

        Sample k = new Sample();

        System.out.printf("k.val=%d%n", k.val);
    }
}

class Sample {
    public final int val;

    {
        Scanner kb = new Scanner(System.in);
        Random r = new Random();
        System.out.print("min?");
        int min = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(kb.nextLine());

        val = r.nextInt(max - min) + min;
    }
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class IntValue {
    private final int m_val;
    private static final IntValue [] ms_cache;

    static {
        ms_cache = new IntValue[256];
        ZERO = of(0);
        ONE = of(1);
    }

    private IntValue(int val)
    {
        m_val = val;
    }

    public static final IntValue ZERO;
    public static final IntValue ONE;

    public static IntValue of(int val)
    {
        if (val < -128 || val > 127)
            return new IntValue(val);

        if (ms_cache[val + 128] == null)
            ms_cache[val + 128] = new IntValue(val);

        return ms_cache[val + 128];
    }


    public int getVal()
    {
        return m_val;
    }

    public IntValue inc()
    {
        return plus(1);
    }

    public IntValue plus(IntValue other)
    {
        return plus(other.m_val);
    }

    public IntValue plus(int val)
    {
        return of(m_val + val);
    }

    public int compareTo(IntValue other)
    {
        return m_val - other.m_val;
    }

    public String toString()
    {
        return m_val + "";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Date sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Date {
    private static final String [] ms_weekDaysTR;
    private static final String [] ms_weekDaysEN;

    static {
        ms_weekDaysTR = new String[]{"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
        ms_weekDaysEN = new String[]{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    }

    private int m_day, m_mon, m_year;
    private int m_dayOfWeek;

    private static int getDayOfWeek(int day, int mon, int year)
    {
        int totalDays = getDayOfYear(day, mon, year);

        for (int y = 1900; y < year; ++y)
            totalDays += Month.isLeapYear(y) ? 366 : 365;

        return totalDays % 7;
    }

    private static int getDayOfYear(int day, int mon, int year)
    {
        int dayOfYear = day;

        for (int m = mon - 1; m >= 1; --m)
            dayOfYear += Month.values()[m - 1].getDaysByYear(year);

        return dayOfYear;
    }

    private static boolean isValidDate(int day, int mon, int year)
    {
        if (day < 1 || day > 31 || mon < 1 || mon > 12)
            return false;

        int days =  Month.values()[mon - 1].getDaysByYear(year);

        return day <= days;
    }

    private static void doWorkForException(String msg)
    {
        System.out.println(msg);
        System.exit(-1); //exception konusuna kadar sabredin
    }

    private static void control(int day, int mon, int year, String msg)
    {
        if (!isValidDate(day, mon, year))
            doWorkForException(msg);
    }

    private void controlForDay(int day)
    {
        control(day, m_mon, m_year, "Invalid day");
    }

    private void controlForMonValue(int monVal)
    {
        control(m_day, monVal, m_year, "Invalid month");
    }

    private void controlForYear(int year)
    {
        control(m_day, m_mon, year, "Invalid year");
    }

    private void set(int day, int mon, int year)
    {
        m_day = day;
        m_mon = mon;
        m_year = year;
        m_dayOfWeek = getDayOfWeek(m_day, m_mon, m_year);
    }

    private int getDayOfWeekValue() {return m_dayOfWeek;}

    public static Date randomDate()
    {
        return randomDate(new Random());
    }

    public static Date randomDate(Random r)
    {
        Date now = new Date();

        return randomDate(r, now.m_year, now.m_year);
    }

    public static Date randomDate(int year)
    {
        return randomDate(new Random(), year);
    }

    public static Date randomDate(Random r, int year)
    {
        return randomDate(r, year, year);
    }
    public static Date randomDate(int minYear, int maxYear)
    {
        return randomDate(new Random(), minYear, maxYear);
    }

    public static Date randomDate(Random r, int minYear, int maxYear)
    {
        int year = r.nextInt(maxYear - minYear + 1) + minYear;
        int mon = r.nextInt(12) + 1;
        int days =  Month.values()[mon - 1].getDaysByYear(year);
        int day = r.nextInt(days) + 1;

        return new Date(day, mon, year);
    }

    public Date()
    {
        Calendar now = Calendar.getInstance();

        set(now.get(Calendar.DAY_OF_MONTH), now.get(Calendar.MONTH) + 1, now.get(Calendar.YEAR));
    }

    public Date(int day, Month month, int year)
    {
        this(day, month.ordinal() + 1, year);
    }

    public Date(int day, int mon, int year)
    {
        control(day, mon, year, "Invalid date");
        set(day, mon, year);
    }

    public void setDay(int day)
    {
        if (day == m_day)
            return;

        controlForDay(day);
        set(day, m_mon, m_year);
    }

    public void setMonth(Month month)
    {
        setMonthValue(month.ordinal() + 1);
    }

    public void setMonthValue(int mon)
    {
        if (m_mon == mon)
            return;

        controlForMonValue(mon);
        set(m_day, mon, m_year);
    }

    public void setYear(int year)
    {
        if (m_year == year)
            return;

        controlForYear(year);
        set(m_day, m_mon, year);
    }

    public int getDay()
    {
        return m_day;
    }
    public int getMonthValue()
    {
        return m_mon;
    }
    public Month getMonth() {return Month.values()[m_mon - 1];}
    public int getYear()
    {
        return m_year;
    }
    public DayOfWeek getDayOfWeek() {return DayOfWeek.values()[getDayOfWeekValue()];}
    public String getDayOfWeekTR() {return ms_weekDaysTR[getDayOfWeekValue()];}
    public String getDayOfWeekEN() {return ms_weekDaysEN[getDayOfWeekValue()];}
    public int getDayOfYear() {return getDayOfYear(m_day, m_mon, m_year);}

    public boolean isLeapYear()
    {
        return  Month.isLeapYear(m_year);
    }

    public boolean isWeekend()
    {
        return m_dayOfWeek == 0 || m_dayOfWeek == 6;
    }

    public boolean isWeekday()
    {
        return !isWeekend();
    }

    public String toString(char delim)
    {
        return String.format("%02d%c%02d%c%04d", m_day, delim, m_mon, delim, m_year);
    }

    public String toString()
    {
        return toString('/');
    }

    public String toStringTR()
    {
        return toStringTR('/');
    }

    public String toStringTR(char delim)
    {
        return String.format("%s %s", toString(delim), getDayOfWeekTR());
    }

    public String toStringEN()
    {
        return toStringEN('/');
    }

    public String toStringEN(char delim)
    {
        return String.format("%s %s", toString(delim), getDayOfWeekEN());
    }

    public String toLongDateStringTR()
    {
        //TODO:
        return toStringTR();
    }

    public String toLongDateStringEN()
    {
        //TODO:
        return toStringEN();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	NumberUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public final class NumberUtil {
	private static final String [] ms_onesTR;
	private static final String [] ms_tensTR;

	static {
		ms_onesTR = new String[]{"", "bir", "iki", "üç", "dört", "beş", "altı", "yedi", "sekiz", "dokuz"};
		ms_tensTR = new String[]{"", "on", "yirmi", "otuz", "kırk", "elli", "altmış", "yetmiş", "seksen", "doksan"};
	}

	private NumberUtil() {}
	private static String numToTextMax3DigitsTR(int val)
	{
		if (val == 0)
			return "sıfır";

		String str = val < 0 ? "eksi" : "";

		val = Math.abs(val);

		int a = val / 100;
		int b = val / 10 % 10;
		int c = val % 10;

		if (a != 0) {
			if (a != 1)
				str += ms_onesTR[a];
			str += "yüz";
		}

		if (b != 0)
			str += ms_tensTR[b];

		if (c != 0)
			str += ms_onesTR[c];

		return str;
	}

	private static int [] getDigits(int n, int val)
	{
		val = Math.abs(val);
		int len = val == 0 ? 1 : (int)Math.log10(val) / n + 1;
		int [] a = new int[len];

		for (int i = len - 1; i >= 0; --i) {
			int pow = (int)Math.pow(10, n);

			a[i] = val % pow;
			val /= pow;
		}

		return a;
	}

	public static long factorial(int n)
	{
		if (n < 0)
			return -1;

		long result = 1;

		for (int i = 2; i <= n; ++i)
			result *= i;

		return result;
	}

	public static int [] getDigits(int val)
	{
		return getDigits(1, val);
	}

	public static int [] getDigitsInThree(int val)
	{
		return getDigits(3, val);
	}

	public static int getDigitsCount(int val)
	{
		return val == 0 ? 1 : (int)Math.log10(Math.abs(val)) + 1;
	}

	public static int getDigitsSum(int val)
	{
		int sum = 0;

		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}

		return Math.abs(sum);
	}

	public static int getNextFibonacciNumber(int val)
	{
		if (val < 0)
			return 0;

		int prev1 = 0, prev2 = 1, number = 0;

		for (;;) {
			number = prev1 + prev2;
			if (number > val)
				return number;

			prev1 = prev2;
			prev2 = number;
		}
	}

	public static int getFibonnaciNumber(int n)
	{
		if (n <= 0)
			return -1;

		if (n <= 2)
			return n - 1;

		int prev1 = 0, prev2 = 1, val = 0;

		for (int i = 2; i < n; ++i) {
			val = prev1 + prev2;
			prev1 = prev2;
			prev2 = val;
		}

		return val;
	}

	public static int getPrime(int n)
	{
		if (n <= 0)
			return -1;

		int count = 0, val = 0;

		for (int i = 2; count < n; ++i) {
			if (isPrime(i)) {
				++count;
				val = i;
			}
		}

		return val;
	}

	public static int getRandom4DigitsNumber()
	{
		return getRandom4DigitsNumber(new Random());
	}

	public static int getRandom4DigitsNumber(Random r)
	{
		boolean [] flags = new boolean[10];
		int result = 0;
		int val = r.nextInt(9) + 1;

		flags[val] = true;
		result = val * 1000;

		for (int i = 3; i >= 1; --i) {
			for (;;) {
				val = r.nextInt(10);
				if (!flags[val])
					break;
			}
			result += val * (int)Math.pow(10, i - 1);
			flags[val] = true;
		}

		return result;
	}

	public static int getReverse(int val)
	{
		int rev = 0;

		while (val != 0) {
			rev = rev * 10 + val % 10;
			val /= 10;
		}

		return rev;
	}

	public static int getSum(int val)
	{
		int n = getDigitsCount(val);

		int sum = 0;

		while (val != 0) {
			sum += pow(val % 10, n);
			val /= 10;
		}

		return sum;
	}

	public static boolean isArmstrong(int val)
	{
		if (val < 0)
			return false;

		return val == getSum(val);
	}

	public static boolean isEven(int val)
	{
		return val % 2 == 0;
	}

	public static boolean isNegative(int val)
	{
		return val < 0;
	}

	public static boolean isOdd(int val)
	{
		return !isEven(val);
	}

	public static boolean isPalindrome(int val)
	{
		return getReverse(val) == val;
	}

	public static boolean isPrime(int val)
	{
		if (val <= 1)
			return false;

		if (val % 2 == 0)
			return val == 2;

		if (val % 3 == 0)
			return val == 3;

		if (val % 5 == 0)
			return val == 5;

		if (val % 7 == 0)
			return val == 7;

		for (int i = 11; i * i <= val; i += 2)
			if (val % i == 0)
				return false;

		return true;
	}

	public static boolean isPositive(int val)
	{
		return val > 0;
	}

	public static int pow(int a, int b)
	{
		b = Math.abs(b);
		int result = 1;

		while (b-- > 0)
			result *= a;

		return result;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	StringUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public final class StringUtil {
	private static final String ms_alphabetTR;
	private static final String ms_alphabetEN;

	static {
		ms_alphabetTR = "abcçdefgğhıijklmnoöprsştuüvyz";
		ms_alphabetEN = "abcdefghijklmnopqrstuwvxyz";
	}

	private StringUtil() {}
	public static String capitalize(String str)
	{
		str = str.trim();

		return !str.isEmpty() ? Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase() : "";
	}

	public static int getCount(String s1, String s2)
	{
		int count = 0;

		for (int index = -1; (index = s1.indexOf(s2, index + 1)) != -1; ++count)
				;

		return count;
	}

	public static String generateRandomPassword(Random r, int n)
	{
		String chars = "abcçdefgğhıijklmnoöpqrsştuüwxvyz0123456789.:?-_";

		char [] c = new char[n];

		for (int i = 0; i < n; ++i)  {
			char ch = chars.charAt(r.nextInt(chars.length()));

			c[i] = r.nextBoolean() ? Character.toUpperCase(ch) : ch;
		}

		return new String(c);
	}

	public static String generateRandomPassword(int n)
	{
		return generateRandomPassword(new java.util.Random(), n);
	}

	public static String getRandomString(Random r, int n, String str)
	{
		char [] c = new char[n];

		for (int i = 0; i < n; ++i)
			c[i] = str.charAt(r.nextInt(str.length()));

		return new String(c);
	}

	public static String getRandomText(Random r, int n, String str)
	{
		char [] c = new char[n];

		for (int i = 0; i < n; ++i) {
			char ch = str.charAt(r.nextInt(str.length()));

			c[i] = r.nextBoolean() ? Character.toUpperCase(ch) : ch;
		}

		return new String(c);
	}

	public static String getRandomTextEN(java.util.Random r, int n)
	{
		return getRandomText(r, n, ms_alphabetEN);
	}

	public static String getRandomTextEN(int n)
	{
		return getRandomTextEN(new java.util.Random(), n);
	}

	public static String getRandomTextTR(java.util.Random r, int n)
	{
		return getRandomText(r, n, ms_alphabetTR);
	}

	public static String getRandomTextTR(int n)
	{
		return getRandomTextTR(new java.util.Random(), n);
	}

	public static boolean isPalindrome(String s)
	{
		s = removeNonalphabetics(s);

		int len = s.length();
		int halfLen = len / 2;

		for (int i = 0; i < halfLen; ++i) {
			char ch1 = Character.toLowerCase(s.charAt(i));
			char ch2 = Character.toLowerCase(s.charAt(len - 1 - i));

			if (ch1 != ch2)
				return false;
		}

		return true;
	}

	public static boolean isPangram(String s, String alphabet)
	{
		int len = alphabet.length();

		for (int i = 0; i < len; ++i)
			if (!s.contains(alphabet.charAt(i) + ""))
				return false;

		return true;
	}

	public static boolean isPangramTR(String s)
	{
		return isPangram(s.toLowerCase(), ms_alphabetTR);
	}

	public static boolean isPangramEN(String s)
	{
		return isPangram(s.toLowerCase(), ms_alphabetEN);
	}

	public static String padLeft(String s, int len, char ch)
	{
		if (len <= s.length())
			return s;

		return repeat(len - s.length(), ch) + s;
	}

	public static String padLeft(String s, int len)
	{
		return padLeft(s, len, ' ');
	}

	public static String padRight(String s, int len, char ch)
	{
		if (len <= s.length())
			return s;

		return s + repeat(len - s.length(), ch);
	}

	public static String padRight(String s, int len)
	{
		return padRight(s, len, ' ');
	}

	public static String removeNonalphabetics(String s)
	{
		String str = "";

		int len = s.length();

		for (int i = 0; i < len; ++i) {
			char ch = s.charAt(i);

			if (Character.isLetter(ch))
				str += ch;
		}

		return str;
	}

	public static String repeat(int n, char ch)
	{
		char [] c = new char[n];

		while (n-- > 0)
			c[n] += ch;

		return new String(c);
	}

	public static String reverse(String str)
	{
		char [] c = str.toCharArray();

		ArrayUtil.reverse(c);

		return new String(c);
	}

	public static String [] split(String str, String delim)
	{
		return split(str, delim, StringSplitOptions.NONE);
	}

	public static String [] split(String str, String delim, StringSplitOptions stringSplitOptions)
	{
		String specials = "[].";
		String re = "[";

		for (int i = 0; i < delim.length(); ++i) {
			char ch = delim.charAt(i);

			re += specials.indexOf(ch) >= 0 ? "\\" + ch : ch;
		}

		re += "]";

		if (stringSplitOptions == StringSplitOptions.REMOVEEMPTYENTRIES)
			re += "+";

		return str.split(re);
	}

	public static String trimEnd(String s)
	{
		int i;

		for (i = s.length() - 1; i >= 0 && Character.isWhitespace(s.charAt(i)); --i)
			;

		return s.substring(0, i + 1);
	}

	public static String trimStart(String s)
	{
		int i;

		int len = s.length();

		for (i = 0; i < len && Character.isWhitespace(s.charAt(i)); ++i)
			;

		return s.substring(i);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
    non-static metotlar aşağı seviye adeta static metotlara dönüştürülür. Dolayısıyla bu metotların çağrısı da
    dönüştürümüş static metotların çağrısı biçimine dönüştürülür
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo(10);

        //non-static foo metodunun çağrısının aşağı seviyeli temsili karşılığı
        Sample.foo(s, 10);
    }
}

class Sample {
    private int m_val;

    public void foo(int val)
    {
        m_val = val;
    }

    //non-static foo metodunun bildiriminin aşağı seviyedeki temsili karşılığı
    public static void foo(Sample s, int val)
    {
        s.m_val = val;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    non-static bir metodu çağıran referansa metodun bildiriminde this anahtar sözcüğü ile erişilir. this'in bu şekilde
    kullanıldığı durumda this referansı denilmektedir. this aslında yukarıda anlatılan dönüştürmede metoda
    eklenmiş olan referansı temsil eder
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    private int m_val;

    public void foo(int val)
    {
        this.m_val = val;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    static metotlar içerisinde this referansı kullanılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    private static int ms_val;

    public static void foo(int val)
    {
        this.ms_val = val; //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    this referansına atama yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    private int m_val;

    public void foo(int val)
    {
        this = new Sample(); //error
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    Sınıfın non-static metotları içerisinde sınıfın non-static elemanlarına this referansı ile erişilebilir.
    Aşağıdaki örnekte doğrudan kullanmakla this referansı ile kullanmak arasında fark yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    private int m_val;

    public void foo(int val)
    {
        this.m_val = val;
        this.bar();
    }

    public void bar()
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Biz sınıfın non-static veri elemanlarına erişimde gerekmedikçe this referansı kullanmayacağız. Ancak metot
    çağırmalarda okunabilirliği artırmak için this referansını çoğunlukla tercih edeceğiz. Yani sınıfın
    non-static metotlarını this referansı ile çağıracağız. Bu durumda sınıfın static metotları ile non-static
    metotları çağrı sırasından anlaşılmış olacak.
    Aşağıdaki örnekte foo metodu içerisinde bar non-static olduğundan this referansı ile çağrılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    private int m_val;

    public static void tar()
    {

    }
    public void foo(int val)
    {
        m_val = val;
        this.bar();
        tar();
    }

    public void bar()
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşğıdaki kod yazım tekniğinde this referansı ile veri elemanına erişim zorunludur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(20);

        System.out.println(s.getVal());

        s.setVal(10);

        System.out.println(s.getVal());
    }
}

class Sample {
    private int val;

    public Sample(int val)
    {
        this.val = val;
    }

    public int getVal() {return val;}

    public void setVal(int val)
    {
        this.val = val;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Point sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math.geometry;

import static java.lang.Math.sqrt;

public class Point {
	public int x, y;

	Point(Point p)
	{
		x = p.x;
		y = p.y;
	}

	public Point()
	{}

	public Point(int x)
	{
		this(x, 0);
	}

	public Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public double distance()
	{
		return this.distance(0, 0);
	}

	public double distance(Point p)
	{
		return this.distance(p.x, p.y);
	}

	public double distance(int a, int b)
	{
		return sqrt((x - a) * (x - a) + (y - b) * (y - b));
	}

	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}

	public void offset(int dxy)
	{
		this.offset(dxy, dxy);
	}

	public String toString()
	{
		return String.format("(%d, %d)", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Circle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math.geometry;

public class Circle {
    private double m_r;

    public Circle()
    {}

    public Circle(double r)
    {
        this.setRadius(r);
    }

    public void setRadius(double r)
    {
        if (m_r == r)
            return;

        m_r = Math.abs(r);
    }

    public double getRadius() {return m_r;}
    public double getArea() {return Math.PI * m_r * m_r;}
    public double getCircumference() {return 2 * Math.PI * m_r;}
}

package org.csystem.math.geometry;

public class AnalyticalCircle extends Circle {
    private Point m_center;

    public AnalyticalCircle()
    {
        this(0);
    }

    public AnalyticalCircle(double r)
    {
        this(r, 0, 0);
    }

    public AnalyticalCircle(int x, int y)
    {
        this(0, x, y);
    }

    public AnalyticalCircle(double r, Point center)
    {
        this(r, center.x, center.y);
    }

    public AnalyticalCircle(double r, int x, int y)
    {
        super(r);
        m_center = new Point(x, y);
    }

    public int getX() {return m_center.x;}
    public int getY() {return m_center.y;}
    public Point getCenter() {return new Point(m_center);}

    public void setX(int x)
    {
        m_center.x = x;
    }

    public void setY(int y)
    {
        m_center.y = y;
    }

    public void setCenter(Point center)
    {
        this.setCenter(center.x, center.y);
    }

    public void setCenter(int x, int y)
    {
        this.setX(x);
        this.setY(y);
    }

    public void offset(int dxy) //delegate method
    {
        this.offset(dxy, dxy);
    }

    public void offset(int dx, int dy) //delegate method
    {
        m_center.offset(dx, dy);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math;

import static java.lang.Math.sqrt;

public final class Complex {
	private static Complex plus(double a1, double b1, double a2, double b2)
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	private static Complex minus(double a1, double b1, double a2, double b2)
	{
		return plus(a1, b1, -a2, -b2);
	}

	public double a, b;

	public Complex() {}

	public Complex(double a)
	{
		this(a, 0);
	}

	public Complex(double a, double b)
	{
		this.a = a;
		this.b = b;
	}

	public double getNorm() {return sqrt(a * a + b * b);}

	public Complex getConjugate() {return new Complex(a, -b);}

	//plus methods

	public static Complex plus(double val, Complex z)
	{
		return plus(val, 0, z.a, z.b);
	}

	public Complex plus(Complex z)
	{
		return plus(a, b, z.a, z.b);
	}

	public Complex plus(double val)
	{
		return plus(a, b, val, 0);
	}

	//minus methods

	public static Complex minus(double val, Complex z)
	{
		return minus(val, 0, z.a, z.b);
	}

	public Complex minus(Complex z)
	{
		return minus(a, b, z.a, z.b);
	}

	public Complex minus(double val)
	{
		return minus(a, b, val, 0);
	}

	//inc methods

	public void inc()
	{
		this.inc(1);
	}

	public void inc(int amount)
	{
		a += amount;
	}

	//dec methods

	public void dec()
	{
		this.dec(1);
	}

	public void dec(int amount)
	{
		this.inc(-amount);
	}

	public String toString()
	{
		return String.format("|%.2f + %.2fi|=%f", a, b, getNorm());
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Rational sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math;

import java.util.Random;

public final class Rational {
    private int m_a, m_b;

    private static Rational plus(int a1, int b1, int a2, int b2)
    {
        return new Rational(a1 * b2 + a2 * b1, b1 * b2);
    }

    private static Rational minus(int a1, int b1, int a2, int b2)
    {
        return plus(a1, b1, -a2, b2);
    }

    private static Rational multiply(int a1, int b1, int a2, int b2)
    {
        return new Rational(a1 * a2, b1 * b2);
    }

    private static Rational div(int a1, int b1, int a2, int b2)
    {
        return multiply(a1, b1, b2, a2);
    }

    private static void control(int a, int b)
    {
        if (b == 0) {
            System.out.println(a == 0 ? "Belirsiz" : "Tanımsız");
            System.exit(-1); //exception konusuna sabredin
        }
    }

    private void calibrateSigns()
    {
        if (m_b < 0) {
            m_a *= -1;
            m_b *= -1;
        }
    }

    private void set(int a, int b)
    {
        m_a = a;
        if (m_a == 0) {
            m_b = 1;
            return;
        }

        m_b = b;
        this.calibrateSigns();
        this.simplify();
    }

    private void simplify()
    {
        int a = Math.abs(m_a);
        int b = m_b;

        int min = a > b ? b : a;

        for (int i = min; i >= 2; --i) {
            if (a % i == 0 && b % i == 0) {
                m_a /= i;
                m_b /= i;
                break;
            }
        }
    }

    public static Rational randomRational(int min, int max) //[min, max)
    {
        return randomRational(new Random(), min, max);
    }

    public static Rational randomRational(Random r, int min, int max)  //[min, max)
    {
        return new Rational(r.nextInt(max - min) + min, r.nextInt(max - min) + min);
    }

    public Rational()
    {
        m_b = 1;
    }

    public Rational(int a, int b)
    {
        control(a, b);
        this.set(a, b);
    }

    public void setNumerator(int val)
    {
        if (m_a == val)
            return;

        this.set(val, m_b);
    }

    public void setDenominator(int val)
    {
        if (m_b == val)
            return;

        control(m_a, val);
        this.set(m_a, val);
    }

    public int getNumerator()
    {
        return m_a;
    }

    public int getDenominator()
    {
        return m_b;
    }

    public double toDouble()
    {
        return (double)m_a / m_b;
    }

    //plus methods
    public static Rational plus(int val, Rational r)
    {
        return plus(val, 1, r.m_a, r.m_b);
    }

    public Rational plus(Rational r)
    {
        return plus(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational plus(int val)
    {
        return plus(m_a, m_b, val, 1);
    }

    //minus methods
    public static Rational minus(int val, Rational r)
    {
        return minus(val, 1, r.m_a, r.m_b);
    }

    public Rational minus(Rational r)
    {
        return minus(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational minus(int val)
    {
        return minus(m_a, m_b, val, 1);
    }

    //multiply methods
    public static Rational multiply(int val, Rational r)
    {
        return multiply(val, 1, r.m_a, r.m_b);
    }

    public Rational multiply(Rational r)
    {
        return multiply(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational multiply(int val)
    {
        return multiply(m_a, m_b, val, 1);
    }

    //div methods
    public static Rational div(int val, Rational r)
    {
        return div(val, 1, r.m_a, r.m_b);
    }

    public Rational div(Rational r)
    {
        return div(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational div(int val)
    {
        return div(m_a, m_b, val, 1);
    }

    //inc methods
    public void inc()
    {
        this.inc(1);
    }
    public void inc(int amount)
    {
        m_a += amount * m_b;
    }

    //dec methods
    public void dec()
    {
        this.dec(1);
    }
    public void dec(int amount)
    {
        this.inc(-amount);
    }

    //pow method
    public void pow(int n)
    {
        m_a = (int)Math.pow(m_a, n);
        m_b = (int)Math.pow(m_b, n);
    }

    public int compareTo(Rational r)
    {
        return m_a * r.m_b - r.m_a * m_b;
    }

    public String toString()
    {
        return this.toString(6);
    }

    public String toString(int n)
    {
        String fmt = String.format("%%d / %%d = %%.%df", n);

        return String.format(fmt, m_a, m_b, toDouble());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.collection;

public class CSDArrayList {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void doWorkForException(String msg)
    {
        System.out.println(msg);
        System.exit(-1); //exception konusuna kadar sabredin
    }

    private static void checkForIllegalArgumentException(int capacity)
    {
        if (capacity < 0)
            doWorkForException("Invalid capacity");
    }

    private static void checkForIndexOutOfBounds(int index, int end)
    {
        if (index < 0 || index >= end)
            doWorkForException("Index out of bounds");
    }

    private void allocateCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        for (int i = 0; i < m_index; ++i)
            temp[i] = m_elems[i];

        m_elems = temp;
    }

    private void checkAndAllocCapacity(int capacity)
    {
        if (m_index < m_elems.length)
            return;

        this.allocateCapacity(capacity);
    }

    public CSDArrayList()
    {
        this(DEFAULT_CAPACITY);
    }

    public CSDArrayList(int initialCapacity)
    {
        checkForIllegalArgumentException(initialCapacity);
        m_elems = new Object[initialCapacity];
    }

    public boolean add(Object elem)
    {
        this.checkAndAllocCapacity(m_elems.length * 2);
        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, Object elem)
    {
        checkForIndexOutOfBounds(index, m_index + 1); // add size verildiğinde sona ekler
        this.checkAndAllocCapacity(m_elems.length * 2);

        //TODO:
    }

    public int capacity() {return m_elems.length;}

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public Object get(int index)
    {
        checkForIndexOutOfBounds(index, m_index);

        return m_elems[index];
    }

    public Object set(int index, Object elem)
    {
        checkForIndexOutOfBounds(index, m_index);
        Object old = m_elems[index];

        m_elems[index] = elem;

        return old;
    }

    public Object remove(int index)
    {
        checkForIndexOutOfBounds(index, m_index);
        Object old = m_elems[index];

        //TODO:
        return old;
    }
    public int size() {return m_index;}

    public void trimToSize()
    {
        if (m_index == m_elems.length)
            return;

        this.allocateCapacity(m_index == 0 ? DEFAULT_CAPACITY : m_index);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class IntValue {
    private final int m_val;
    private static final IntValue [] ms_cache;

    static {
        ms_cache = new IntValue[256];
        ZERO = of(0);
        ONE = of(1);
    }

    private IntValue(int val)
    {
        m_val = val;
    }

    public static final IntValue ZERO;
    public static final IntValue ONE;

    public static IntValue of(int val)
    {
        if (val < -128 || val > 127)
            return new IntValue(val);

        if (ms_cache[val + 128] == null)
            ms_cache[val + 128] = new IntValue(val);

        return ms_cache[val + 128];
    }


    public int getVal()
    {
        return m_val;
    }

    public IntValue inc()
    {
        return this.plus(1);
    }

    public IntValue plus(IntValue other)
    {
        return this.plus(other.m_val);
    }

    public IntValue plus(int val)
    {
        return of(m_val + val);
    }

    public int compareTo(IntValue other)
    {
        return m_val - other.m_val;
    }

    public String toString()
    {
        return m_val + "";
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    this referansı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    public int val;

    public void foo(int val)
    {
        //...
        this.bar(val);
    }

    public void bar(int val)
    {
        //...
        this.val = val;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki zincir çağrısında (fluent pattern) metotların this referansını döndürmesi gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo().bar().foo().tar().bar().zar();
    }
}

class Sample {
    //...
    public Sample foo()
    {
        System.out.println("foo");

        return this;
    }

    public Sample bar()
    {
        System.out.println("bar");

        return this;
    }

    public Sample tar()
    {
        System.out.println("tar");

        return this;
    }

    public Sample zar()
    {
        System.out.println("zar");

        return this;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    String sınıfı fluent çağrıya uygundur. Şüphesiz this referansını döndürmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        String s = "ankara";

        s = s.toUpperCase().trim().substring(1);

        System.out.println(s);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı da fluent çağırmaya uygundur fakat metotlar sınıf immutable olduğundan this referansını
    döndürmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.IntValue;

class App {
    public static void main(String [] args)
    {
        int val = IntValue.of(10).plus(3).inc().getVal();

        System.out.println(val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    IntValue sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class IntValue {
    private final int m_val;
    private static final IntValue [] ms_cache;

    static {
        ms_cache = new IntValue[256];
        ZERO = of(0);
        ONE = of(1);
    }

    private IntValue(int val)
    {
        m_val = val;
    }

    public static final IntValue ZERO;
    public static final IntValue ONE;

    public static IntValue of(int val)
    {
        if (val < -128 || val > 127)
            return new IntValue(val);

        if (ms_cache[val + 128] == null)
            ms_cache[val + 128] = new IntValue(val);

        return ms_cache[val + 128];
    }


    public int getVal()
    {
        return m_val;
    }

    public IntValue inc()
    {
        return this.plus(1);
    }

    public IntValue plus(IntValue other)
    {
        return this.plus(other.m_val);
    }

    public IntValue plus(int val)
    {
        return of(m_val + val);
    }

    public int compareTo(IntValue other)
    {
        return m_val - other.m_val;
    }

    public String toString()
    {
        return m_val + "";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    MutableIntValue sınıfı da fluent çağırmaya uygundur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.MutableIntValue;

class App {
    public static void main(String [] args)
    {
        MutableIntValue mutableIntValue = new MutableIntValue(10);

        mutableIntValue.plus(3).inc();

        System.out.println(mutableIntValue.getVal());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    MutableIntValue sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

public final class MutableIntValue {
    private int m_val;

    public MutableIntValue(int val)
    {
        m_val = val;
    }

    public int getVal()
    {
        return m_val;
    }

    public void setVal(int val)
    {
        m_val = val;
    }

    public MutableIntValue inc()
    {
        return this.plus(1);
    }

    public MutableIntValue plus(MutableIntValue other)
    {
        return this.plus(other.m_val);
    }

    public MutableIntValue plus(int val)
    {
        m_val += val;

        return this;
    }

    public int compareTo(MutableIntValue other)
    {
        return m_val - other.m_val;
    }

    public String toString()
    {
        return m_val + "";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    11.04.2020
    Polymorphism (çok biçimlilik)(runtime polymorphism):
    Biyolojideki tanım: Farklı doku ya da organların evrim süreci içerisinde temel hedefi aynı kalmak koşuluyla
    o hedefe ulaşmadaki yönteminin değişebilmesidir. Örneğin, görmek hedefi canlıdan canlıya aktarılırken değişmez.
    Ancak kalıtım sürecinde görme algoritması değişebilir.

    Polymorphism'in nesne yönelimli programlamada 3 tane tanımından bahsedilebilir:
    1. Biyolojik Tanımı: Taban sınıfın bir fonksiyonunun türemiş sınıfta yeniden gerçekleştirilmesi
    2. Yazılım Mühendisliği Tanımı: Türden bağımsız kod yazabilmek
    3. Aşağı Seviyeli Tanım: Önceden yazılmış kodların sonradan yazılmış kodları çağırabilmesidir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    Sanal (virtual) metot: non-static bildirilmiş ve final olmayan metotlardır.
    Java' da polymorphism sanal metotlar kullanılarak gerçekleştirilir.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class A {
    public static void tar() //sanal değil
    {

    }

    public void foo() //sanal
    {

    }

    public final void bar() //sanal değil
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Taban sınıfın bir metodunun türemiş sınıf içerisinde geri dönüş değeri ve imzası aynı
    olarak yeniden yazılmasına İngilizce olarak "override" denilmektedir. Burada erişim belirleyici
    aynı olmayabilir ancak bu konunun detayları vardır, ileride ele alınacaktır. Örneğin public
    ise public override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo");
    }
}

class B extends A {
    public void foo() //override
    {
        System.out.println("B.foo");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sanal bir metodun türemiş sınıfta override edilmesi zorunlu değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo");
    }
}

class B extends A {
    //...
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sanal bir metot çağrısında önce referansın dinamik türüne bakılır. Referansın dinamik türüne
    ilişkin sınıfta ilgili sanal metot override edilmişse override edilen çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        A x;

        if (val > 0)
            x = new C();
        else if (val == 0)
            x = new B();
        else
            x = new A();

        x.foo();
    }
}

class C extends B {
    public void foo() //override
    {
        System.out.println("C.foo");
    }
}

class B extends A {
    public void foo() //override
    {
        System.out.println("B.foo");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Sanal bir metot çağrısında önce referansın dinamik türüne bakılır. Referansın dinamik türüne
    ilişkin sınıfta ilgili sanal metot override edilmemişse taban sınıfına bakılır. Taban sınıfta
    override edilmişse taban sınıfınki çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        A x;

        if (val > 0)
            x = new C();
        else if (val == 0)
            x = new B();
        else
            x = new A();

        x.foo();
    }
}

class C extends B {

}

class B extends A {
    public void foo() //override
    {
        System.out.println("B.foo");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Türemiş sınıfların hiç birisinde override edilmemiş bile olsa sanal metodun başlatıldığı
    taban sınıfınki çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        A x;

        if (val > 0)
            x = new C();
        else if (val == 0)
            x = new B();
        else
            x = new A();

        x.foo();
    }
}

class C extends B {

}

class B extends A {

}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki doWork metodu A dan türemiş sınıflardan bağımsız yani onları bilmeden yazılmıştır.
    Çalışma zamanı sırasında foo sanal metodunu çağırdığı için dinamik türe ilişkin
    işlem yapabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        A x;

        if (val > 0)
            x = new C();
        else if (val == 0)
            x = new B();
        else
            x = new A();

        Sample s = new Sample();

        s.doWork(x);
    }
}

class Sample {
    public void doWork(A x)
    {
        x.foo();
    }
}

class C extends B {
    public void foo()
    {
        System.out.println("C.foo");
    }
}

class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki doWork metodu A dan türemiş sınıflardan bağımsız yani onları bilmeden yazılmıştır.
    Çalışma zamanı sırasında foo sanal metodunu çağırdığı için dinamik türe ilişkin
    işlem yapabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        int val = Integer.parseInt(kb.nextLine());

        A x;

        if (val > 0)
            x = new C();
        else if (val == 0)
            x = new B();
        else
            x = new D();

        Sample s = new Sample();

        s.doWork(x);
    }
}

class Sample {
    public void doWork(A x)
    {
        x.foo();
    }
}

class D extends B {
    public void foo()
    {
        System.out.println("D.foo");
    }
}

class C extends B {
    public void foo()
    {
        System.out.println("C.foo");
    }
}

class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
      super referansı ile türemiş sınıfın bir metodunda taban sınıfının bir metodu çağrılabilir.
      Aşağıdaki örnekte override edilen foo içerisinde taban sınıfın foo metodu da çağrılmıştır (augmentation).
      Aşağıdaki örnek için super zorunludur.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new B();

        x.foo();
    }
}


class B extends A {
    public void foo()
    {
        super.foo();
        System.out.println("B.foo");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }
}




/*----------------------------------------------------------------------------------------------------------------------
  super referansı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new B();

        x.foo();
    }
}

class B extends A {
    public void foo()
    {
        bar();
        super.bar();
        System.out.println("B.foo");
    }

    public void bar()
    {
        System.out.println("B.bar");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }

    public void bar()
    {
        System.out.println("A.bar");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
  super referansı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new C();

        x.foo();
    }
}

class C extends B {
    public void foo()
    {
        super.foo();
        System.out.println("C.foo");
    }
}

class B extends A {
    public void foo()
    {
        super.foo();
        System.out.println("B.foo");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Android uygulama geliştirmede Activity lifecycle da kullanılan metotlar çok biçimli olarak
    ve taban sınıfın ilgili metodunun çağrılması gerektiği biçiminde tasarlanmıştır. Aşağıda
    bu durumun bir demosu gösterilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Activity activity = new ChatActivity();

        activity.onCreate(new Bundle());
        //...
        activity.onPause();
    }
}

class ChatActivity extends AppCompatActivity {
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        System.out.println("ChatActivity.onCreate");
    }

    public void onPause()
    {
        super.onPause();
        System.out.println("ChatActivity.onPause");
    }
}

class AppCompatActivity extends Activity {
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        System.out.println("AppCompatActivity.onCreate");
    }

    public void onPause()
    {
        super.onPause();
        System.out.println("AppCompatActivity.onPause");
    }
}

class Activity {
    public void onCreate(Bundle savedInstanceState)
    {
        System.out.println("Activity.onCreate");
    }

    public void onPause()
    {
        System.out.println("Activity.onPause");
    }
}

class Bundle {

}

/*----------------------------------------------------------------------------------------------------------------------
    companyapp sınıfları ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.samples.companyapp.*;

class App {
    public static void main(String [] args)
    {
        HumanResources humanResources = new HumanResources();
        Worker worker = new Worker("12345", "Ali", 45, 8);
        ProjectWorker projectWorker = new ProjectWorker("123456", "Veli", 46.7, 7, "Otomasyon");
        Manager manager = new Manager("1234567", "Selami", 20000, "Muhasebe");
        SalesManager salesManager = new SalesManager("123458", "Ayşe", 23000, "Pazarlama", 3000);

        System.out.println(worker.toString());
        System.out.println(projectWorker.toString());
        System.out.println(manager.toString());

        System.out.println("******************");
        humanResources.payInsurance(worker);
        humanResources.payInsurance(projectWorker);
        humanResources.payInsurance(manager);
        humanResources.payInsurance(salesManager);
    }
}



package org.csystem.samples.companyapp;

public class Employee {
    private String m_citizenId;
    private String m_name;
    //...

    public Employee(String citizenId, String name)
    {
        m_citizenId = citizenId;
        m_name = name;
    }

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        m_citizenId = citizenId;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        m_name = name;
    }

    public double calculateInsurance()
    {
        return 0;
    }

    public String toString()
    {
        return String.format("[%s]%s", m_citizenId, m_name);
    }
}
package org.csystem.samples.companyapp;

public class HumanResources {
    //...
    public void payInsurance(Employee employee)
    {
        System.out.printf("Citizen Id:%s%n", employee.getCitizenId());
        System.out.printf("Name:%s%n", employee.getName());
        System.out.printf("Insurance amount:%f%n", employee.calculateInsurance());
    }
}

package org.csystem.samples.companyapp;

public class Manager extends Employee {
    private double m_salary;
    private String m_departmentName;

    public Manager(String citizenId, String name, double salary, String departmentName)
    {
        super(citizenId, name);
        m_salary = salary;
        m_departmentName = departmentName;
    }

    public double getSalary()
    {
        return m_salary;
    }

    public void setSalary(double salary)
    {
        m_salary = salary;
    }

    public String getDepartmentName()
    {
        return m_departmentName;
    }

    public void setDepartmentName(String departmentName)
    {
        m_departmentName = departmentName;
    }

    public double calculateInsurance()
    {
        return m_salary * 1.25;
    }

    public String toString()
    {
        return String.format("%s:%s:%s", m_departmentName, m_salary, super.toString());
    }
}
package org.csystem.samples.companyapp;

public class SalesManager extends Manager {
    private double m_extra;

    public SalesManager(String citizenId, String name, double salary, String departmentName, double extra)
    {
        super(citizenId, name, salary, departmentName);
        m_extra = extra;
    }

    public double getExtra()
    {
        return m_extra;
    }

    public void setExtra(double extra)
    {
        m_extra = extra;
    }

    public double calculateInsurance()
    {
        return super.calculateInsurance() + m_extra;
    }

    public String toString()
    {
        return String.format("%s:%f", super.toString(), getSalary() +  m_extra);
    }
}
package org.csystem.samples.companyapp;

public class Worker extends Employee {
    private double m_feePerHour;
    private int m_hourPerDay;

    //...
    public Worker(String citizenId, String name, double feePerHour, int hourPerDay)
    {
        super(citizenId, name);
        m_feePerHour = feePerHour;
        m_hourPerDay = hourPerDay;
    }

    public double getFeePerHour()
    {
        return m_feePerHour;
    }

    public void setFeePerHour(double feePerHour)
    {
        m_feePerHour = feePerHour;
    }

    public int getHourPerDay()
    {
        return m_hourPerDay;
    }

    public void setHourPerDay(int hourPerDay)
    {
        m_hourPerDay = hourPerDay;
    }

    public double calculateInsurance()
    {
        return m_feePerHour * m_hourPerDay * 30;
    }

    public String toString()
    {
        return String.format("%s:%f", super.toString(), m_feePerHour * m_hourPerDay);
    }
}

package org.csystem.samples.companyapp;

public class ProjectWorker extends Worker {
    private String m_projectName;

    public ProjectWorker(String citizenId, String name, double feePerHour, int hourPerDay, String projectName)
    {
        super(citizenId, name, feePerHour, hourPerDay);
        m_projectName = projectName;
    }

    public String getProjectName()
    {
        return m_projectName;
    }

    public void setProjectName(String projectName)
    {
        m_projectName = projectName;
    }

    public double calculateInsurance()
    {
        return super.calculateInsurance() * 1.15;
    }

    public String toString()
    {
        return String.format("%s:%s", m_projectName, super.toString());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Taban sınıf ile türemiş sınıf içerisinde aynı isimde birden veri elemanları olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();

        b.foo(10);

        A x = b;

        System.out.printf("b.a=%d%n", b.a);
        System.out.printf("x.a=%d%n", x.a);
    }
}

class B extends A {
    public int a;

    public void foo(int val)
    {
        a = val;
        super.a = val * 2;
    }
}

class A {
    public int a;
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Java' da override edilen bir metodun erişim belirleyicisi erşim anlamında düşürülemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class B extends A {
    protected void foo() //error
    {

    }
}

class A {
    public void foo()
    {

    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Java' da override edilen bir metodun erişim belirleyicisi erşim anlamında aynı kalabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class B extends A {
    protected void foo()
    {

    }
}

class A {
    protected void foo()
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Java' da override edilen bir metodun erişim belirleyicisi erşim anlamında yükseltilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class B extends A {
    public void foo()
    {

    }
}

class A {
    protected void foo()
    {

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte foo metodu çağrı sırasında erişilebilir bir metottur. App sınıfı da A sınıfı
    ile aynı pakette olduğundan bu durum geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new B();

        x.foo();
    }
}

class B extends A {
    void foo()
    {
        System.out.println("B.foo");
    }
}
class A {
    void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
     Aşağıdaki örnekte foo metodu çağrı sırasında erişilebilir bir metot değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.A;
import test.B;

class App {
    public static void main(String [] args)
    {
        A x = new B();

        x.foo(); //error

        B y = new B();

        y.foo();
    }
}

package test;

public class A {
    void foo()
    {
        System.out.println("A.foo");
    }
}

package test;

public class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
     Aşağıdaki örnekte foo metodu çağrı sırasında erişilebilir bir metot değildir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import test.A;
import test.B;

class App {
    public static void main(String [] args)
    {
        A x = new B();

        x.foo(); //error

        B y = new B();

        y.foo();
    }
}

package test;

public class A {
    protected void foo()
    {
        System.out.println("A.foo");
    }
}

package test;

public class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
     covariant return type: taban sınıf içerisinde referans geri dönüş değeri olan bir metot
     türemiş sınıfta override edilirken geri dönüş değeri olarak taban sınıftaki metodun
     geri dönüş türünden veya o türden türetilmiş bir sınıf türünden yazılabilir. Bu durum
     sadece geri dönüş değeri referans olan metotlar için ve geri dönüş değeri için
     istisna bir durumdur. Örneğin parameterler için böyle bir kural yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class C extends A {
    public Y foo() //covariant return type
    {
        //...
        return new Y();
    }
}

class B extends A {
    public X foo()
    {
        //...
        return new X();
    }
}

class A {
    public X foo()
    {
        //...
        return new X();
    }
}

class Y extends X {

}

class X {

}

/*----------------------------------------------------------------------------------------------------------------------
     covariant return type: taban sınıf içerisinde referans geri dönüş değeri olan bir metot
     türemiş sınıfta override edilirken geri dönüş değeri olarak taban sınıftaki metodun
     geri dönüş türünden veya o türden türetilmiş bir sınıf türünden yazılabilir. Bu durum
     sadece geri dönüş değeri referans olan metotlar için ve geri dönüş değeri için
     istisna bir durumdur. Örneğin parameterler için böyle bir kural yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;

class App {
    public static void main(String [] args)
    {

    }
}

class C extends A {
    public Random foo() //covariant return type
    {
        //...
        return new Random();
    }
}

class B extends A {
    public String foo()
    {
        //...
        return "izmir";
    }
}

class A {
    public Object foo()
    {
        //...
        return "ankara";
    }
}


/*----------------------------------------------------------------------------------------------------------------------
     covariant return type'ın bir kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        MyType myType = new MyType();
        MyType mt = myType.copy();

        //...
    }
}

class MyType extends Type {
    public MyType copy()
    {
        return new MyType();
    }
}
class Type {
    public Type copy()
    {
        //...
        return new Type();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
     Yukarıdaki örnekte covariant return type kullanılmasaydı downcasting yapılması gerekirdi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        MyType myType = new MyType();
        MyType mt = (MyType)myType.copy();

        //...
    }
}

class MyType extends Type {
    public Type copy()
    {
        return new MyType();
    }
}
class Type {
    public Type copy()
    {
        //...
        return new Type();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
     Türemiş sınıf içerisinde taban sınıfın static bir metodu da aynı geri dönüş değeri ve imza
     ile yazılabilir. Buna bazı kaynaklar "logical static override" derler. Ancak polymorphism
     anlamındaki bir override kesinlikle değildir. Çünkü polymophism olması için ortada bir nesne
     ve şüphesiz sanal metotlar olması gerekir. Yani aşağıdaki sorunun cevabı HAYIR'dır
     Soru: static metotlar override edilebilir mi? HAYIR
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A.foo();
        B.foo();
    }
}

class B extends A {
    public static void foo()
    {
        System.out.println("B.foo");
    }
}

class A {
    public static void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
     Türemiş sınıf içerisinde taban sınıfın static bir metodu da aynı geri dönüş değeri ve imza
     ile yazılabilir. Buna bazı kaynaklar "logical static override" derler. Ancak polymorphism
     anlamındaki bir override kesinlikle değildir. Çünkü runtime polymophism olması için ortada bir nesne
     ve şüphesiz sanal metotlar olması gerekir. Yani aşağıdaki sorunun cevabı HAYIR'dır
     Soru: static metotlar override edilebilir mi? HAYIR
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A.foo();
        B.foo();
    }
}

class B extends A {
    public static void foo()
    {
        System.out.println("B.foo");
    }
}

class A {
    public static void foo()
    {
        System.out.println("A.foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
     final olarak bildirilmiş bir metot override edilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }

    public void bar() //error
    {
        System.out.println("B.bar");
    }
}
class A {
    public void foo()
    {
        System.out.println("A.foo");
    }

    public final void bar()
    {
        System.out.println("A.bar");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
     final olarak bildirilmiş bir metot override edilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}


class D extends A {
    public void foo()
    {
        System.out.println("D.foo");
    }

    public final void bar()
    {
        System.out.println("D.bar");
    }
}

class C extends B {
    public void foo()
    {
        System.out.println("C.foo");
    }

    public final void bar() //error
    {
        System.out.println("C.bar");
    }
}

class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }

    public final void bar()
    {
        System.out.println("B.bar");
    }
}

class A {
    public void foo()
    {
        System.out.println("A.foo");
    }

    public void bar()
    {
        System.out.println("A.bar");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Circle sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math.geometry;

public class Circle {
    private double m_r;

    public Circle()
    {}

    public Circle(double r)
    {
        this.setRadius(r);
    }

    public final void setRadius(double r)
    {
        if (m_r == r)
            return;

        m_r = Math.abs(r);
    }

    public final double getRadius() {return m_r;}
    public final double getArea() {return Math.PI * m_r * m_r;}
    public final double getCircumference() {return 2 * Math.PI * m_r;}
}


/*----------------------------------------------------------------------------------------------------------------------
    12.04.2020
    parserapp uygulaması
    (parserapp.png dosyasına bakınız)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.samples.parserapp.ParserTest;

class App {
    public static void main(String [] args)
    {
        ParserTest.run();
    }
}

package org.csystem.samples.parserapp;

import java.util.Scanner;

public class ParserTest {
    private static String getString()
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir yazı giriniz:");

        return kb.nextLine();
    }

    public static void run()
    {
        String str = getString();
        StringSource ss = new StringSource(str);
        CharArraySource cs = new CharArraySource(str);
        Parser p = new Parser(ss);

        p.doParse();
        p.setSource(cs);
        p.doParse();
    }
}

package org.csystem.samples.parserapp;

public class Source {
    public int getChar()
    {
        return -1;
    }
}

package org.csystem.samples.parserapp;

public class Parser {
    private Source m_source;

    public Parser(Source source)
    {
        this.setSource(source);
    }

    public void setSource(Source source)
    {
        //...
        m_source = source;
    }

    public void doParse()
    {
        int count = 0;

        int ch;

        while ((ch = m_source.getChar()) != -1)
            if (Character.isLetter((char)ch))
                ++count;

        System.out.printf("Count:%d%n", count);
    }
}

package org.csystem.samples.parserapp;

public class StringSource extends Source {
    private final String m_str;
    private final int m_length;
    private int m_index;

    public StringSource(String str)
    {
        m_str = str;
        m_length = m_str.length();
    }

    public int getChar()
    {
        return m_index == m_length ? -1 : m_str.charAt(m_index++);
    }
}

package org.csystem.samples.parserapp;

public class CharArraySource extends Source {
    private final char [] m_chars;
    private int m_index;

    public CharArraySource(char [] chars)
    {
        m_chars = chars;
    }

    public CharArraySource(String str)
    {
        this(str.toCharArray());
    }

    public int getChar()
    {
        return m_index == m_chars.length ? -1 : m_chars[m_index++];
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Object sınıfının toString sanal metodu nesneye yönelik tekil bir bilgi verir. Bu bilginin pratikte
    çok anlamı yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        System.out.println(s.toString());
        System.out.println(k.toString());
    }
}

class Sample {

}


/*----------------------------------------------------------------------------------------------------------------------
    Object sınıfınon toString metodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        System.out.println(s.toString());
        System.out.println(k.toString());
    }
}

class Sample {
    public String toString()
    {
        return "Sample";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    print ve println metotları bir referans için toString metodunu çağırarak geri döndürdüğü yazıyı ekrana basar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Sample k = new Sample();

        System.out.println(s);
        System.out.println(k);
    }
}

class Sample {
    public String toString()
    {
        return "Sample";
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    printf metodunda s format karakteri ile bir referans verildiğinde toString metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.math.geometry.Point;

class App {
    public static void main(String [] args)
    {
        Point p = new Point(100, 45);

        System.out.printf("point:%s%n", p);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Temel türlerin String ile + işlemi sınrasında yazıya dönüştürülmesi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        int degree = 10;
        String str = "Derece:" + degree; // "Derece:" + Integer.valueOf(degree).toString()

        System.out.println(str);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir referansın bir String ile + işlemine sokulması durumda referans için toString metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.math.geometry.Point;

class App {
    public static void main(String [] args)
    {
        Point p = new Point(100, 56);
        String str = "Point:" + p; // "Point:" + p.toString()

        System.out.println(str);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir referansın bir String ile + işlemine sokulması durumda referans için toString metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.datetime.Date;

class App {
    public static void main(String [] args)
    {
        Date date = new Date();
        String str = "Date:" + date;

        System.out.println(str);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bazı durumlarda bir sınıf bir kavramı soyut olarak temsil ediyor olabilir. Bu durumda sınıfın tek başına
    anlamı yoktur. Yani nesne yönelimli programlama bakış açısıyla o sınıf türünden nesnenin anlamı yoktur. Ancak
    o sınıftan türeyen sınıfların nesne olarak anlamı vardır. Bu tarz sınıflara soyut (abstract) sınıflar denir.
    Soyut olmayan sınıflara da somut (concrete) sınıflar denir. Soyut bir sınıf abstract anahtar sözcüğü ile bildirilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

abstract class Sample {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir sınıfın abstract metotları olabilir. abstract metotlar gövdesi olmayan metotlardır. Bu metotlar sanaldır.
    Dolayısıyla override edilebilir. En az bir tane abstract metodu olan bir sınıf abstract olarak bildirilmelidir.
    Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Mample { //error
    public abstract void bar();
}

abstract class Sample {
    public abstract void foo();
    public abstract void tar();

    public void bar()
    {}
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıf türünden bir nesne new operatörü ile yaratılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(); //error
    }
}

abstract class Sample {
    public abstract void foo();
    public abstract void tar();

    public void bar()
    {
        Sample s = new Sample(); //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıfların da veri elemanları olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(); //error
    }
}

abstract class Sample {
    private int m_x;
    public abstract void foo();
    public abstract void tar();

    public void bar()
    {
        Sample s = new Sample(); //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract bir sınıftan türetilmiş olan bir sınıf taban sınıfının en az bir tane abstract metodunu override etmezse
    türemiş sınıf da abstract olarak bildirilmek zorundadır. Sınıf içerisinde hiç abstract metot kalmadıysa bu durumda
    sınıf concrete olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

abstract class E extends A {
    public void foo()
    {
        //...
    }
    public void bar()
    {
        //...
    }
}

class C extends A {
    public void foo()
    {
        //...
    }
    public void bar()
    {
        //...
    }
}

abstract class D extends A {
    public void foo()
    {
        //...
    }
}

class B extends A {//error
    public void foo()
    {
        //...
    }
}

abstract class A {
    public abstract void foo();
    public abstract void bar();
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki durumda C sınıfında artık hiç abstract metot kalmadığından concrete olabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}



class C extends B {
    public void bar()
    {
        //...
    }
}

abstract class B extends A {
    public void foo()
    {
        //...
    }
}

abstract class A {
    public abstract void foo();
    public abstract void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıf referansları taban sınıf referansı olarak anlamlıdır ve polymorphism de kullanılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new C();

        x.foo();
        x.bar();
    }
}

class C extends B {
    public void bar()
    {
        System.out.println("C.bar");
    }
}

abstract class B extends A {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

abstract class A {
    public abstract void foo();
    public abstract void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
    abstract sınıflarda ctor olabilir. public yerine protected yapılması okunabilirlik açısından daha uygundur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B(10, 20);

        //..
    }
}

class B extends A {
    private int m_y;

    public B(int x, int y)
    {
        super(x);
        m_y = y;
    }

    public void foo()
    {

    }
}

abstract class A {
    private int m_x;

    private A()
    {
        //...
    }

    protected A(int x)
    {
        m_x = x;
    }

    public int getX()
    {
        return m_x;
    }

    public void setX(int x)
    {
        m_x = x;
    }

    public abstract void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
     companyapp sınıfları ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.samples.companyapp.*;

class App {
    public static void main(String [] args)
    {
        HumanResources humanResources = new HumanResources();
        Worker worker = new Worker("12345", "Ali", 45, 8);
        ProjectWorker projectWorker = new ProjectWorker("123456", "Veli", 46.7, 7, "Otomasyon");
        Manager manager = new Manager("1234567", "Selami", 20000, "Muhasebe");
        SalesManager salesManager = new SalesManager("123458", "Ayşe", 23000, "Pazarlama", 3000);

        System.out.println(worker.toString());
        System.out.println(projectWorker.toString());
        System.out.println(manager.toString());

        System.out.println("******************");
        humanResources.payInsurance(worker);
        humanResources.payInsurance(projectWorker);
        humanResources.payInsurance(manager);
        humanResources.payInsurance(salesManager);
    }
}



package org.csystem.samples.companyapp;

public abstract class Employee {
    private String m_citizenId;
    private String m_name;
    //...

    protected Employee(String citizenId, String name)
    {
        m_citizenId = citizenId;
        m_name = name;
    }

    public String getCitizenId()
    {
        return m_citizenId;
    }

    public void setCitizenId(String citizenId)
    {
        m_citizenId = citizenId;
    }

    public String getName()
    {
        return m_name;
    }

    public void setName(String name)
    {
        m_name = name;
    }

    public abstract double calculateInsurance();


    public String toString()
    {
        return String.format("[%s]%s", m_citizenId, m_name);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
     parserapp sınıfları ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.samples.parserapp.ParserTest;

class App {
    public static void main(String [] args)
    {
        ParserTest.run();
    }
}

package org.csystem.samples.parserapp;

public abstract class Source {
    public abstract int getChar();
}

/*----------------------------------------------------------------------------------------------------------------------
    Java' da exception işlemleri için aşağıdaki anahtar sözcükler kullanılır:
    try, catch, throw, finally, throws

    Bir exception throw anahtar sözcüğü ile fırlatılabilir. throw anahtar sözcüğünün genel biçimi şöyledir:

    throw <referans>;

    throw anahtar sözcüğü bir referans alır. throw anahtar sözcüğünün aldığı referansın Throwable sınıfından doğrudan
    ya da dolaylı olarak türemiş bir sınıf türünden olması gerekir. Bir exception fırlatıldığında akış exception'ın
    fırlatıldığı metottan çıkar.

    Bir exception yakalanamaz ise bu durumda exception ın fırlatıldığı akış (thread) sonlanır.

    Akış exception bakımından ele alınacaksa (handling) try bloğu içerisinde yazılmalıdır. try bloğu
    catch bloğu veya blokları veya tek başına finally bloğu veya catch blokları ve finally bloğu
    ile devam edebilir. try bloğu tek başına olamaz. try bloğu tüm diğer blokları ile birlikte tek bir deyimdir.
    try bloğu içerisinde bulunan diğer bloklar arasında herhangi bir deyim yazılamaz.

    catch bloğunun parantezi içerisinde yazılan parametreye catch parametresi denir. catch parametresine
    ilişkin türün bir exception sınıfı yani Throwable dan doğrudan ya da dolaylı olarak türetilmiş
    bir sınıf türünden olması gerekir.

    Exception oluşursa (fırlatılırsa) akış try bloğundan bir daha geri dönmemek üzere (non-resumptive) catch bloklarına
    sıçrar. catch blokları yukarıdan aşağıya switch deyimi gibi teker teker kontrol edilir.
    Uygun catch bloğu bulunursa o catch bloğu çalıştırılır. Uygun catch bloğu fırlatılan exception nesnesinin adresinin
    (referansının) ilgili catch parametresine doğrudan atanabildiği ilk catch bloğudur. Exception yakalanırsa yakalanan
    catch bloğuna ilişkin kodlar çalıştırılır. Kodlar bitince tüm diğer catch blokları atlanarak akış devam eder
    Eğer exception yakalanamazsa akış çöker. Yani bir catch bloğu çalıştırılırsa diğer catch blokları
    çalıştırılmaz. try bloğu exception oluşmadan sonlanırsa tüm catch blokları atlanarak akış devam eder.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
     Aşağıdaki örnekte MyException sınıfı doğrudan ya da dolaylı olarak Throwable sınıfından türetilmediği için
     throw' a referans olarak verilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val <= 0) {
            MyException ex = new MyException();

            throw ex; //error
        }

    }

}

class MyException {

}

/*----------------------------------------------------------------------------------------------------------------------
    Bir exception fırlatılması
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        System.out.printf("log(%f)=%f%n", val, MathUtil.myLog(val));
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val <= 0) {
            MyException ex = new MyException();

            throw ex;
        }

        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    17.04.2020
    throw ile o an nesne yaratılarak fırlatılmasına ilişkin ifade çok sık kullanılmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        System.out.printf("log(%f)=%f%n", val, MathUtil.myLog(val));
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val <= 0)
            throw new MyException();

        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    try-catch blokları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        try {
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("My Excepion yakalandı");
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val <= 0)
            throw new MyException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    try-catch blokları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        try {
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("My Excepion yakalandı");
        }
        catch (YourException ex) {
            System.out.println("Your Excepion yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();

        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Taban sınıf parametreli catch bloğu o sınıftan türemiş olan exception nesnelerini yakalayabilir.
    Bu işlem aslında bir upcasting işlemidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        try {
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("My Excepion yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends MyException {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf exception parametreli catch bloğu taban sınıf parametreli catch bloğundan sonra yazılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        try {
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("My Excepion yakalandı");
        }
        catch (YourException ex) { //error
            System.out.println("Your Excepion yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();

        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends MyException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf exception parametreli catch bloğu taban sınıf parametreli catch bloğundan önce yazılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        System.out.print("Bir sayı giriniz:");
        double val = Double.parseDouble(kb.nextLine());

        try {
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (YourException ex) {
            System.out.println("Your Excepion yakalandı");
        }
        catch (MyException ex) {
            System.out.println("My Excepion yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends MyException {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Throwable parametreli catch bloğu ile tüm exception'lar yakalanabilir. Bu durumda Throwable parametreli catch
    bloğunun tüm catch bloklarından sonra yazılması zorunludur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (YourException ex) {
            System.out.println("Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("My Exception yakalandı");
        }
        catch (Throwable ex) {
            System.out.println("Throwable yakalandı");
        }


        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends MyException {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte parseDouble metodunun fırlattığı exception nesnesini yakalayabilecek bir catch bloğu
    bulunamadığından akış sonlanır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (YourException ex) {
            System.out.println("Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("My Exception yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends MyException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir try bloğu içerisinde bir exception yakalanamaz ise o try bloğunu kapsayan try bloğunun catch bloklarına
    bakılır. Bu işlem uygun catch bloğu bulununcaya veya bulunamayıncaya kadar devam eder. Bulunursa
    uygun catch bloğu çalıştırılır bulunamazsa akış sonlanır. Eğer bir exception try bloğu içerisinde yakalanmışsa
    kapsayan try bloklarının catch bloklarına bakılmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Sample.foo();
            System.out.println("main:try sonu");
        }
        catch (YourException ex) {
            System.out.println("main:Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("main:My Exception yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static void foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("foo:My Exception yakalandı");
        }

        System.out.println("foo sonu");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();

        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte foo metodu MyException fırlatıldığında onu yakalamış ve aynı nesneyi yeniden fırlatmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Sample.foo();
            System.out.println("main:try sonu");
        }
        catch (YourException ex) {
            System.out.println("main:Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("main:My Exception yakalandı");
        }
        catch (Throwable ex) {
            System.out.println("main:Throwable yakalandı");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static void foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("foo:My Exception yakalandı");

            throw ex; //rethrow
        }

        System.out.println("foo sonu");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    finally bloğu akış try bloğunu nasıl bitirirse bitirsin çalıştırılacak bloktur. finally bloğu
    try bloğunda catch blokları ile birlikte olacaksa tüm catch bloklarının sonunda olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Sample.foo();
            System.out.println("main:try sonu");
        }
        catch (YourException ex) {
            System.out.println("main:Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("main:My Exception yakalandı");
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static void foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println("foo:My Exception yakalandı");
        }
        finally {
            System.out.println("foo:finally");
        }

        System.out.println("foo sonu");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}
/*----------------------------------------------------------------------------------------------------------------------
    finally bloğu akış try deyimini nasıl bitirirse bitirsin çalıştırılacak bloktur. finally bloğu
    try bloğunda catch blokları ile birlikte olacaksa tüm catch bloklarının sonunda olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            double result = Sample.foo();

            System.out.printf("result:%f%n", result);
        }
        catch (YourException ex) {
            System.out.println("main:Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("main:My Exception yakalandı");
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            return result;
        }
        catch (MyException ex) {
            System.out.println("foo:My Exception yakalandı");
            throw ex;
        }
        finally {
            System.out.println("foo:finally");
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    try-finally yani catch bloksuz bir try bloğu ile exception nesnesi yakalanmadan ve aynı zamanda exception
    oluşsa da oluşmasa da yapılacak bir işleme yönelik kod yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            double result = Sample.foo();

            System.out.printf("result:%f%n", result);

        }
        catch (YourException ex) {
            System.out.println("main:Your Exception yakalandı");
        }
        catch (MyException ex) {
            System.out.println("main:My Exception yakalandı");
        }
        catch (NumberFormatException ex) {
            System.out.println("main:NumberFormatException yakalandı");
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            return result;
        }
        finally {
            System.out.println("foo:finally");
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException();

        if (val == 0)
            throw new YourException();


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    //...
}

class YourException extends RuntimeException {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.foo("foo"));//footryfinally
    }
}

class Sample {
    public static MutableString foo(String str)
    {
        MutableString ms = new MutableString(str);

        try {
            return ms.append("try");
        }
        finally {
            ms.append("finally");
        }
    }
}

//Dikkat detaylar gözardı edilmiştir
class MutableString {
    private String m_str;

    public MutableString(String str)
    {
        m_str = str;
    }

    public MutableString append(String str)
    {
        m_str += str;

        return this;
    }

    //...

    public String toString() {return m_str;}
}



/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.foo("foo"));//footry
    }
}

class Sample {
    public static String foo(String str)
    {
        try {
            str += "try";

            return str;
        }
        finally {
            str += "finally";
            System.out.println(str); //footryfinally
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.foo("foo"));//footry
    }
}

class Sample {
    public static String foo(String str)
    {
        try {
            return str + "try";
        }
        finally {
            str += "finally";
            System.out.println(str); //foofinally
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örneği inceleyiniz. finally içerisinde return yapılmadan kod yazmaya gayret ediniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        System.out.println(Sample.foo("foo")); //footry
    }
}

class Sample {
    public static String foo(String str)
    {
        try {
            str += "try";

            return str;
        }
        finally {
            str += "finally";

            return str;
        }
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    Exception sınıfları içerisinde tutulan elemanlar ile bilgi taşınabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.printf("Exception message:%s%n", ex.getMessage());
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new MyException("val can not be zero");


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    private String m_message;

    public MyException(String message)
    {
        m_message = message;
    }

    public String getMessage() {return m_message;}
}

/*----------------------------------------------------------------------------------------------------------------------
    Throwable sınıfı içerisinde exception işlemlerine yönelik bir takım veri elemanları bulunmaktadır.
    Bunlardan en temel olanı mesaja karşılık gelen elemandır. Throwable sınıfından türetilmiş olan
    sınıflar yani exception sınıfları genel olarak String parametreli ctor elemanını yazarlar böylelikle
    hiyararşik olarak mesaj elemanı Throwable sınıfına aktarılmış olur. İsterse programcı başka bilgileri de
    yazdığı exception sınıfına ekleyebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.printf("Exception message:%s, Error Status:%s%n", ex.getMessage(), ex.getErrorStatus());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative", ExceptionStatus.NEGATIVE);

        if (val == 0)
            throw new MyException("val can not be zero", ExceptionStatus.ZERO);


        return Math.log(val);
    }
}

enum ExceptionStatus {ZERO, NEGATIVE}

class MyException extends RuntimeException {
    private ExceptionStatus m_errorStatus;

    public MyException(String message, ExceptionStatus errorStatus)
    {
        super(message);
        m_errorStatus = errorStatus;
    }

    public ExceptionStatus getErrorStatus()
    {
        return m_errorStatus;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    getMessage metodu override edilebilir. Böylelikle programcı kendi exception sınıfına özel getMessage
    yazabilir. Aşağıdaki örnekte çok biçimli olarak MyException sınıfının getMessage metodu çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (Throwable ex) {
            System.out.printf(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative", ErrorStatus.NEGATIVE);

        if (val == 0)
            throw new MyException("val can not be zero", ErrorStatus.ZERO);


        return Math.log(val);
    }
}

enum ErrorStatus {ZERO, NEGATIVE}

class MyException extends RuntimeException {
    private ErrorStatus m_errorStatus;
    public MyException(String message, ErrorStatus errorStatus)
    {
        super(message);
        m_errorStatus = errorStatus;
    }

    public ErrorStatus getErrorStatus()
    {
        return m_errorStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Error Status:%s", super.getMessage(), m_errorStatus);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Throwable sınıfının parametresiz printStackTrace metodu exception fırlatılması noktalarını bir stack biçiminde
    gösteren mesajı ekrana basar. Bu metot da basılan yazı akış exception yakalanmadığında dolayı sonlandığında da
    basılan yazı ile neredeyse aynıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            ex.printStackTrace();
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative", ErrorStatus.NEGATIVE);

        if (val == 0)
            throw new MyException("val can not be zero", ErrorStatus.ZERO);


        return Math.log(val);
    }
}

enum ErrorStatus {ZERO, NEGATIVE}

class MyException extends RuntimeException {
    private ErrorStatus m_errorStatus;
    public MyException(String message, ErrorStatus errorStatus)
    {
        super(message);
        m_errorStatus = errorStatus;
    }

    public ErrorStatus getErrorStatus()
    {
        return m_errorStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Error Status:%s", super.getMessage(), m_errorStatus);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Throwable sınıfı içerisinde Throwable türünden bir referans tutulur. Bu referans bir exception sınıfı
    içerisinde başka bir exception referansının tutulabilmesine olanak sağlar. getCause metodu ile
    içsel olarak tutulan referans elde edilebilir. Ayrıca Throwable sınıfının Throwble parametresi de olan
    ctor elemanı ile bu bilgi nesneye verilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            System.out.println(Sample.foo());
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            return result;
        }
        catch (Throwable ex) {
            throw new WrapperException("foo exception", ex);
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative", ErrorStatus.NEGATIVE);

        if (val == 0)
            throw new MyException("val can not be zero", ErrorStatus.ZERO);

        return Math.log(val);
    }
}

class WrapperException extends RuntimeException {
    public WrapperException(String message)
    {
        super(message);
    }
    public WrapperException(String message, Throwable cause)
    {
        super(message, cause);
    }

    public String getMessage()
    {
        Throwable cause =  getCause();

        return String.format("Message:%s%s",
                super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
    }
}

enum ErrorStatus {ZERO, NEGATIVE}

class MyException extends RuntimeException {
    private ErrorStatus m_errorStatus;
    public MyException(String message, ErrorStatus errorStatus)
    {
        super(message);
        m_errorStatus = errorStatus;
    }

    public ErrorStatus getErrorStatus()
    {
        return m_errorStatus;
    }

    public String getMessage()
    {
        return String.format("Message:%s, Error Status:%s", super.getMessage(), m_errorStatus);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        int val = Console.readInt("Bir sayı giriniz:", "Hatalı giriş yaptınız");

        System.out.println(val * val);

    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        int val = Console.readInt("Bir sayı giriniz:");

        System.out.println(val * val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        System.out.print("Bir sayı giriniz:");
        int val = Console.readInt();

        System.out.println(val * val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        int val = Console.readIntLine("Bir sayı giriniz", "Hatalı giriş yaptınız");

        System.out.println(val * val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        int val = Console.readIntLine("Bir sayı giriniz");

        System.out.println(val * val);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        double val = Console.readDoubleLine("Bir sayı giriniz", "hatalı giriş yaptınız");

        System.out.println(val * val);
    }
}

package org.csystem.util;

import java.util.Scanner;

public final class Console {
    private final static Scanner ms_kb;

    static {
        ms_kb = new Scanner(System.in);
    }

    private Console()
    {}

    public static int readInt()
    {
        return readInt("");
    }

    public static int readInt(String msg)
    {
        return readInt(msg, "");
    }

    public static int readInt(String msg, String errMsg)
    {
        for (;;) {
            try {
                System.out.print(msg);

                return Integer.parseInt(ms_kb.nextLine());
            }
            catch (Throwable ex) {
                System.out.print(errMsg);
            }
        }
    }

    public static int readIntLine(String msg)
    {
        return readInt(msg + "\n", "");
    }

    public static int readIntLine(String msg, String errMsg)
    {
        return readInt(msg + "\n", errMsg + "\n");
    }

    ////////////////////////////////////////////////////

    public static double readDouble()
    {
        return readDouble("");
    }

    public static double readDouble(String msg)
    {
        return readDouble(msg, "");
    }

    public static double readDouble(String msg, String errMsg)
    {
        for (;;) {
            try {
                System.out.print(msg);

                return Double.parseDouble(ms_kb.nextLine());
            }
            catch (Throwable ex) {
                System.out.print(errMsg);
            }
        }
    }

    public static double readDoubleLine(String msg)
    {
        return readDouble(msg + "\n", "");
    }

    public static double readDoubleLine(String msg, String errMsg)
    {
        return readDouble(msg + "\n", errMsg + "\n");
    }

    ////////////////////////////////////////////////////

    public static String read(String msg)
    {
        System.out.print(msg);

        return ms_kb.nextLine();
    }

    public static String readLine(String msg)
    {
        return read(msg + "\n");
    }

}

/*----------------------------------------------------------------------------------------------------------------------
    Console sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Console;

class App {
    public static void main(String [] args)
    {
        String str = Console.readLine("Bir yazı giriniz:");

        System.out.println(str.toUpperCase());
    }
}

package org.csystem.util;

import java.util.Scanner;

public final class Console {
    private final static Scanner ms_kb;

    static {
        ms_kb = new Scanner(System.in);
    }

    private Console()
    {}

    public static int readInt()
    {
        return readInt("");
    }

    public static int readInt(String msg)
    {
        return readInt(msg, "");
    }

    public static int readInt(String msg, String errMsg)
    {
        for (;;) {
            try {
                System.out.print(msg);

                return Integer.parseInt(ms_kb.nextLine());
            }
            catch (Throwable ex) {
                System.out.print(errMsg);
            }
        }
    }

    public static int readIntLine(String msg)
    {
        return readInt(msg + "\n", "");
    }

    public static int readIntLine(String msg, String errMsg)
    {
        return readInt(msg + "\n", errMsg + "\n");
    }

    public static double readDouble()
    {
        return readDouble("");
    }

    public static double readDouble(String msg)
    {
        return readDouble(msg, "");
    }

    public static double readDouble(String msg, String errMsg)
    {
        for (;;) {
            try {
                System.out.print(msg);

                return Double.parseDouble(ms_kb.nextLine());
            }
            catch (Throwable ex) {
                System.out.print(errMsg);
            }
        }
    }

    public static double readDoubleLine(String msg)
    {
        return readDouble(msg + "\n", "");
    }

    public static double readDoubleLine(String msg, String errMsg)
    {
        return readDouble(msg + "\n", errMsg + "\n");
    }

    public static String read(String msg)
    {
        System.out.print(msg);

        return ms_kb.nextLine();
    }

    public static String readLine(String msg)
    {
        return read(msg + "\n");
    }

    //...
}

/*----------------------------------------------------------------------------------------------------------------------
    unchecked exception sınıfları: Bir sınıfın türetme hiyararşisi içerisinde Error veya RuntimeException sınıfı
    varsa unchecked exception'dır.

    checked exception sınıfları: unchecked olmayan exception sınıflarıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class MyException extends Throwable { //checked

}

class YourException extends Error { //unchecked

}

class OurException extends Exception { //checked

}

class TheirException extends RuntimeException { //unchecked

}

/*----------------------------------------------------------------------------------------------------------------------
    checked bir exception throw edilen metodun içerisinde eğer exception ele alınmayacaksa throws bildirimi
    yapılmalıdır. Aksi durumda error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val) throws MyException
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new MyException("val can not be zero");

        return Math.log(val);
    }
}



class MyException extends Exception {
    public MyException(String message)
    {
        super(message);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    checked bir exception throw edilen metodun içerisinde eğer exception ele alınmayacaksa throws bildirimi
    yapılmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val) throws MyException, YourException
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new YourException("val can not be zero");


        return Math.log(val);
    }
}



class MyException extends Exception {
    public MyException(String message)
    {
        super(message);
    }
}

class YourException extends Exception {
    public YourException(String message)
    {
        super(message);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    checked exception fırlatma ihtimali olan bir akışın throws bildirimi yapılmayacaksa try bloğu içerisinde
    olması ve fırlatma ihtimali olan checked exception'ları yakalabilecek catch bloklarının varolması zorunludur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val); //error

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val) throws MyException, YourException
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new YourException("val can not be zero");


        return Math.log(val);
    }
}



class MyException extends Exception {
    public MyException(String message)
    {
        super(message);
    }
}

class YourException extends Exception {
    public YourException(String message)
    {
        super(message);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    checked exception sınıfı türünden parametreli bir catch bloğunun ait olduğu try bloğunda o checked exception
    türüne ilişkin nesneyi fırlatabilecek bir akış bulunmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = Math.log(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (MyException ex) { //error
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MyException extends Exception {
    public MyException(String message)
    {
        super(message);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Bir metodun fırlatabileceği checked exception sınıfları arasında türetme ilişkisi varsa throws listesine
    yalnızca taban sınıf yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = Math.log(val);

            System.out.printf("log(%f)=%f%n", val, result);
        }
        catch (Throwable ex) {
            System.out.println(ex.getMessage());
        }
        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class MathUtil {
    public static double myLog(double val) throws MyException
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new YourException("val can not be zero");


        return Math.log(val);
    }
}

class MyException extends Exception {
    public MyException(String message)
    {
        super(message);
    }
}

class YourException extends MyException {
    public YourException(String message)
    {
        super(message);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    throws bildirimi olan bir metodun override edilmesi durumunda override edilen metotta throws listesinde
    olan exception sınıfları kaldırılabilir. Yani örneğin, hiç throws listesi de yazılmayabilir. throws listesi
    override edilen metotta olacaksa listedeki sınıflar ya taban sınıfın metoduyla aynı olan veya ondan türemiş
    sınıflar türünden olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class E extends A {
    public void foo() throws TheirException //error
    {

    }
}

class D extends A {
    public void foo() throws OurException
    {

    }
}

class C extends A {
    public void foo() throws MyException
    {

    }
}

class B extends A {
    public void foo()
    {

    }
}

abstract class A {
    public abstract void foo() throws MyException, YourException;
}

class MyException extends Exception {

}

class OurException extends MyException {

}

class YourException extends Exception {

}

class TheirException extends Exception {

}
/*----------------------------------------------------------------------------------------------------------------------
    Aşağıdaki problemden dolayı programcı yöntemini değiştirmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    public static void bar() throws YourException
    {
        //...
    }
}
class B extends A {
    public void foo() throws YourException //error
    {
        Sample.bar();
    }
}

abstract class A {
    public abstract void foo() throws MyException;
}


class MyException extends Exception {

}
class YourException extends Exception {

}

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problem aşağıdaki gibi çözülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample {
    public static void bar() throws YourException
    {
        //...
    }
}
class B extends A {
    public void foo()
    {
        try {
            Sample.bar();
        }
        catch (YourException ex) {
            throw new WrapperException("", ex);
        }
    }
}

abstract class A {
    public abstract void foo() throws MyException;
}


class WrapperException extends RuntimeException {
    public WrapperException(String message)
    {
        super(message);
    }
    public WrapperException(String message, Throwable cause)
    {
        super(message, cause);
    }

    public String getMessage()
    {
        Throwable cause =  getCause();
        return String.format("Message:%s%s",
                super.getMessage(), cause != null ? ", Cause Message:" + cause.getMessage() : "");
    }
}

class MyException extends Exception {

}

class YourException extends Exception {

}
/*----------------------------------------------------------------------------------------------------------------------
    18.04.2020
    NumberFormatException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);

        try {
            System.out.print("Bir sayı giriniz:");
            int val = Integer.parseInt(kb.nextLine());

            System.out.println(val * val);
        }
        catch (NumberFormatException ex) {
            System.out.printf("Message:%s%n", ex.getMessage());
            System.out.println("Geçersiz formatta sayı girdiniz");
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    ClassExceptionException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A x = new A();

        B y = (B)x;

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class A {

}

class B extends A {

}

/*----------------------------------------------------------------------------------------------------------------------
    NullPointerException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = null;

        s.foo();
    }
}

class Sample {
    public void foo()
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    IllegalArgumentException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Random;
import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("min?");
        int min = Integer.parseInt(kb.nextLine());

        System.out.print("max?");
        int max = Integer.parseInt(kb.nextLine());

        try {
            Random r = new Random();
            for (int i = 0; i < 10; ++i)
                System.out.printf("%d ", RandomUtil.nextInt(r, min, max));

            System.out.println();
        }
        catch (IllegalArgumentException ex) {
            System.out.println(ex.getMessage());
        }
    }
}

class RandomUtil {
    public static int nextInt(Random r, int min, int max)
    {
        if (r == null || min >= max)
            throw new IllegalArgumentException("Illegal Arguments");

        return r.nextInt(max - min) + min;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    IndexOutOfBoundsException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.ArrayUtil;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        Scanner kb = new Scanner(System.in);
        System.out.print("n?");
        int n = Integer.parseInt(kb.nextLine());

        System.out.print("start?");
        int start = Integer.parseInt(kb.nextLine());

        System.out.print("end?");
        int end = Integer.parseInt(kb.nextLine());

        int [] a = ArrayUtil.getRandomArray(n, 0, 100);

        ArrayUtil.display(a, 2);
        ArrayUtil.display(Util.getSubArray(a, start, end), 2);
    }
}

class Util {
    public static int [] getSubArray(int []a, int start, int end) //[start, end)
    {
        if (a == null)
            throw new IllegalArgumentException("a can not be null");

        if (start < 0 || end < 0 || start >= end || start >= a.length || end > a.length)
            throw new IndexOutOfBoundsException("Invalid indices");

        int [] res = new int[end - start];

        for (int i = start; i < end; ++i)
            res[i - start] = a[i];

        return res;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    UnsupportedOperationException sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}


class B extends A {
    public void foo()
    {
        //...
    }

    public int bar()
    {
        throw new UnsupportedOperationException();
    }
}

abstract class A {
    public abstract void foo();
    public abstract int bar();
}

/*----------------------------------------------------------------------------------------------------------------------
    Java 7 ile birlikte birden fazla exception için ortak bir iş yapılacaksa | ayracı kullanılarak catch bloğu
    yazılabilir. Bu catch bloğu içerisinde iki sınıfın da ancak ortak elemanları kullanılablir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            double result = Sample.foo();

            System.out.printf("result:%f%n", result);
        }
        catch (MyException | YourException ex) { //Since Java 7
            System.out.println("ortak iş");
            System.out.println(ex.getMessage());
        }
        catch (NumberFormatException ex) {
            System.out.println("main:NumberFormatException yakalandı");
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            return result;
        }
        finally {
            System.out.println("foo:finally");
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new YourException("val can not be zero");


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    public MyException(String msg)
    {
        super(msg);
    }
}

class YourException extends RuntimeException {
    public YourException(String msg)
    {
        super(msg);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlem istenildiği kadar exception sınıfı ile yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            double result = Sample.foo();

            System.out.printf("result:%f%n", result);

        }
        catch (MyException | YourException | NumberFormatException ex) { //Since Java 7
            System.out.println("ortak iş");
            System.out.println(ex.getMessage());
        }
        finally {
            System.out.println("main:finally");
        }

        System.out.println("Tekrar yapıyor musunuz?");
    }
}

class Sample {
    public static double foo()
    {
        try {
            Scanner kb = new Scanner(System.in);

            System.out.print("Bir sayı giriniz:");
            double val = Double.parseDouble(kb.nextLine());
            double result = MathUtil.myLog(val);

            return result;
        }
        finally {
            System.out.println("foo:finally");
        }
    }
}

class MathUtil {
    public static double myLog(double val)
    {
        if (val < 0)
            throw new MyException("val can not be negative");

        if (val == 0)
            throw new YourException("val can not be zero");


        return Math.log(val);
    }
}


class MyException extends RuntimeException {
    public MyException(String msg)
    {
        super(msg);
    }
}

class YourException extends RuntimeException {
    public YourException(String msg)
    {
        super(msg);
    }
}



/*----------------------------------------------------------------------------------------------------------------------
    ArrayUtil sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util;

import java.util.Random;

public final class ArrayUtil {
    private ArrayUtil() {}

    private static void copy(int [] src, int [] dest)
    {
        copy(src, dest, src.length);
    }

    private static void copy(int [] src, int [] dest, int n)
    {
        for (int i = 0; i < n; ++i)
            dest[i] = src[i];
    }

    public static double average(int [] a)
    {
        return  (double)sum(a) / a.length;
    }

    public static void bubbleSort(int [] a)
    {
        bubbleSort(a, false);
    }

    public static void bubbleSort(int [] a, boolean desc)
    {
        if (desc) {
            for (int i = 0; i < a.length - 1; ++i) {
                for (int k = 0; k < a.length - 1 - i; ++k)
                    if (a[k] < a[k + 1]) {
                        int temp = a[k];
                        a[k] = a[k + 1];
                        a[k + 1] = temp;
                    }
            }
        }
        else {
            for (int i = 0; i < a.length - 1; ++i) {
                for (int k = 0; k < a.length - 1 - i; ++k)
                    if (a[k] > a[k + 1]) {
                        int temp = a[k];
                        a[k] = a[k + 1];
                        a[k + 1] = temp;
                    }
            }
        }
    }

    public static void display(int [] a)
    {
        display(a, 1);
    }

    public static void display(int [] a, int n)
    {
        display(a, n, a.length);
    }

    public static void display(int [] a, int n, int len)
    {
        String fmt = String.format("%%0%dd ", n);

        for (int i = 0; i < len; ++i)
            System.out.printf(fmt, a[i]);

        System.out.println();
    }

    public static void display(int [][] a)
    {
        display(a, 1);
    }
    public static void display(int [][] a, int n)
    {
        for (int [] array : a)
            display(array, n);
    }

    public static void drawHistogram(int [] hist, int n, char ch)
    {
        int maxVal = max(hist);

        for (int val : hist) {
            int nCh = val * n / maxVal;

            while (nCh-- > 0)
                System.out.print(ch);

            System.out.println();
        }
    }

    public static int [] enlarge(int [] a, int newLen)
    {
        if (newLen <= a.length)
            return a;

        return resize(a, newLen);
    }

    public static int [] getHistogramData(int [] a, int n) //[0, n]
    {
        int [] counts = new int[n + 1];

        for (int val : a)
            ++counts[val];

        return counts;
    }

    public static int[] getRandomArray(int n, int min, int max) //[min, max)
    {
        return getRandomArray(null, n, min, max);
    }

    public static int[] getRandomArray(Random r, int n, int min, int max) //[min, max)
    {
        if (r == null)
            r = new Random();

        int [] a = new int[n];

        for (int i = 0; i < n; ++i)
            a[i] = r.nextInt(max - min) + min;

        return a;
    }

    public static int[][] getRandomMatrix(int m, int n, int min, int max) //[min, max)
    {
        return getRandomMatrix(null, m, n, min, max);
    }

    public static int[][] getRandomMatrix(Random r, int m, int n, int min, int max) //[min, max)
    {
        if (r == null)
            r = new Random();

        int [][] a = new int[m][];

        for (int i = 0; i < m; ++i)
            a[i] = getRandomArray(r, n, min, max);

        return a;
    }

    public static int [][] getRandomSquareMatrix(int n, int min, int max)
    {
        return getRandomSquareMatrix(new Random(), n, min, max);
    }

    public static int [][] getRandomSquareMatrix(Random r, int n, int min, int max)
    {
        return getRandomMatrix(r, n, n, min, max);
    }

    public static int [] getSubArray(int []a, int start, int end) //[start, end)
    {
        if (a == null || start < 0 || end < 0 || start >= end || start >= a.length || end > a.length)
            throw new IllegalArgumentException("Invalid arguments");

        int [] res = new int[end - start];

        for (int i = start; i < end; ++i)
            res[i - start] = a[i];

        return res;
    }

    public static int [][] getTransposedMatrix(int [][] a)
    {
        if (!isMatrix(a))
            return new int[0][];

        int row = a[0].length;
        int col = a.length;
        int [][] t = new int[row][col];

        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                t[i][j] = a[j][i];

        return t;
    }

    public static boolean isMatrix(int [][] a)
    {
        int col = a[0].length;

        for (int i = 1; i < a.length; ++i)
            if (a[i].length != col)
                return false;

        return true;
    }

    public static boolean isSquareMatrix(int [][] a)
    {
        return isMatrix(a) && a.length == a[0].length;
    }

    public static String join(String [] s, char delim)
    {
        return join(s, delim + "");
    }

    public static  String join(String [] s, String delim)
    {
        String str = "";

        for (String sval : s)
            str += sval + delim;

        return str.substring(0, str.length() - delim.length());
    }

    public static int max(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            result = Math.max(result, a[i]);

        return result;
    }

    public static int min(int [] a)
    {
        int result = a[0];

        for (int i = 1; i < a.length; ++i)
            result = Math.min(result, a[i]);

        return result;
    }

    public static int [] resize(int [] a, int newLen)
    {
        int [] res = new int[newLen];

        copy(a, res, a.length);

        return res;
    }


    public static void reverse(int [] a) //by Emre Onsur
    {
        int temp;
        int halfLen = a.length / 2;

        for(int i = 0; i < halfLen; ++i) {
            temp = a[i];
            a[i] = a[a.length - 1 - i];
            a[a.length - 1 - i] = temp;
        }
    }

    public static void reverse(char [] a)
    {
        char temp;
        int halfLen = a.length / 2;

        for(int i = 0; i < halfLen; ++i) {
            temp = a[i];
            a[i] = a[a.length - 1 - i];
            a[a.length - 1 - i] = temp;
        }
    }

    public static int sum(int [] a)
    {
        int result = 0;

        for (int val : a)
            result += val;

        return result;
    }

    public static int sumDiagonal(int [][] a)
    {
        //...
        int sum = 0;

        for (int i = 0; i < a.length; ++i)
            sum += a[i][i];

        return sum;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.collection;

public class CSDArrayList {
    private static final int DEFAULT_CAPACITY = 10;
    private Object [] m_elems;
    private int m_index;

    private static void checkForIllegalArgumentException(int capacity)
    {
        if (capacity < 0)
            throw new IllegalArgumentException("Capactiy value can not be negative");
    }

    private static void checkForIndexOutOfBounds(int index, int end)
    {
        if (index < 0 || index >= end)
            throw new IndexOutOfBoundsException("Index out of bounds");
    }

    private void allocateCapacity(int capacity)
    {
        Object [] temp = new Object[capacity];

        for (int i = 0; i < m_index; ++i)
            temp[i] = m_elems[i];

        m_elems = temp;
    }

    private void checkAndAllocCapacity(int capacity)
    {
        if (m_index < m_elems.length)
            return;

        this.allocateCapacity(capacity);
    }

    public CSDArrayList()
    {
        this(DEFAULT_CAPACITY);
    }

    public CSDArrayList(int initialCapacity)
    {
        checkForIllegalArgumentException(initialCapacity);
        m_elems = new Object[initialCapacity];
    }

    public boolean add(Object elem)
    {
        this.checkAndAllocCapacity(m_elems.length * 2);
        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, Object elem)
    {
        checkForIndexOutOfBounds(index, m_index + 1); // add size verildiğinde sona ekler
        this.checkAndAllocCapacity(m_elems.length * 2);

        //TODO:
    }

    public int capacity() {return m_elems.length;}

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public Object get(int index)
    {
        checkForIndexOutOfBounds(index, m_index);

        return m_elems[index];
    }

    public Object set(int index, Object elem)
    {
        checkForIndexOutOfBounds(index, m_index);
        Object old = m_elems[index];

        m_elems[index] = elem;

        return old;
    }

    public Object remove(int index)
    {
        checkForIndexOutOfBounds(index, m_index);
        Object old = m_elems[index];

        //TODO:
        return old;
    }
    public int size() {return m_index;}

    public void trimToSize()
    {
        if (m_index == m_elems.length)
            return;

        this.allocateCapacity(m_index == 0 ? DEFAULT_CAPACITY : m_index);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    RationalException sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.math.Rational;

import java.util.Scanner;

class App {
    public static void main(String [] args)
    {
        try {
            Rational r = new Rational(0, 0);
        }
        catch (NumberFormatException ex) {
            System.out.println(ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Rational sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math;

import java.util.Random;

public final class Rational {
    private int m_a, m_b;

    private static Rational plus(int a1, int b1, int a2, int b2)
    {
        return new Rational(a1 * b2 + a2 * b1, b1 * b2);
    }

    private static Rational minus(int a1, int b1, int a2, int b2)
    {
        return plus(a1, b1, -a2, b2);
    }

    private static Rational multiply(int a1, int b1, int a2, int b2)
    {
        return new Rational(a1 * a2, b1 * b2);
    }

    private static Rational div(int a1, int b1, int a2, int b2)
    {
        return multiply(a1, b1, b2, a2);
    }

    private static void control(int a, int b)
    {
        if (b == 0) {
            if (a == 0)
                throw new NumberFormatException("Belirsiz");

            throw new NumberFormatException("Tanımsız");
        }
    }

    private void calibrateSigns()
    {
        if (m_b < 0) {
            m_a *= -1;
            m_b *= -1;
        }
    }

    private void set(int a, int b)
    {
        m_a = a;
        if (m_a == 0) {
            m_b = 1;
            return;
        }

        m_b = b;
        this.calibrateSigns();
        this.simplify();
    }

    private void simplify()
    {
        int a = Math.abs(m_a);
        int b = m_b;

        int min = a > b ? b : a;

        for (int i = min; i >= 2; --i) {
            if (a % i == 0 && b % i == 0) {
                m_a /= i;
                m_b /= i;
                break;
            }
        }
    }

    public static Rational randomRational(int min, int max) //[min, max)
    {
        return randomRational(new Random(), min, max);
    }

    public static Rational randomRational(Random r, int min, int max)  //[min, max)
    {
        return new Rational(r.nextInt(max - min) + min, r.nextInt(max - min) + min);
    }

    public Rational()
    {
        m_b = 1;
    }

    public Rational(int a, int b)
    {
        control(a, b);
        this.set(a, b);
    }

    public void setNumerator(int val)
    {
        if (m_a == val)
            return;

        this.set(val, m_b);
    }

    public void setDenominator(int val)
    {
        if (m_b == val)
            return;

        control(m_a, val);
        this.set(m_a, val);
    }

    public int getNumerator()
    {
        return m_a;
    }

    public int getDenominator()
    {
        return m_b;
    }

    public double toDouble()
    {
        return (double)m_a / m_b;
    }

    //plus methods
    public static Rational plus(int val, Rational r)
    {
        return plus(val, 1, r.m_a, r.m_b);
    }

    public Rational plus(Rational r)
    {
        return plus(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational plus(int val)
    {
        return plus(m_a, m_b, val, 1);
    }

    //minus methods
    public static Rational minus(int val, Rational r)
    {
        return minus(val, 1, r.m_a, r.m_b);
    }

    public Rational minus(Rational r)
    {
        return minus(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational minus(int val)
    {
        return minus(m_a, m_b, val, 1);
    }

    //multiply methods
    public static Rational multiply(int val, Rational r)
    {
        return multiply(val, 1, r.m_a, r.m_b);
    }

    public Rational multiply(Rational r)
    {
        return multiply(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational multiply(int val)
    {
        return multiply(m_a, m_b, val, 1);
    }

    //div methods
    public static Rational div(int val, Rational r)
    {
        return div(val, 1, r.m_a, r.m_b);
    }

    public Rational div(Rational r)
    {
        return div(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational div(int val)
    {
        return div(m_a, m_b, val, 1);
    }

    //inc methods
    public void inc()
    {
        this.inc(1);
    }
    public void inc(int amount)
    {
        m_a += amount * m_b;
    }

    //dec methods
    public void dec()
    {
        this.dec(1);
    }
    public void dec(int amount)
    {
        this.inc(-amount);
    }

    //pow method
    public void pow(int n)
    {
        m_a = (int)Math.pow(m_a, n);
        m_b = (int)Math.pow(m_b, n);
    }

    public int compareTo(Rational r)
    {
        return m_a * r.m_b - r.m_a * m_b;
    }

    public String toString()
    {
        return this.toString(6);
    }

    public String toString(int n)
    {
        String fmt = String.format("%%d / %%d = %%.%df", n);

        return String.format(fmt, m_a, m_b, toDouble());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    RationalException sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.math.Rational;
import org.csystem.math.RationalException;

class App {
    public static void main(String [] args)
    {
        try {
            Rational r = new Rational(3, 0);
        }
        catch (RationalException ex) {
            System.out.println(ex.getRationalExceptionStatus());
            System.out.println(ex.getMessage());
        }
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Rational sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.math;

import java.util.Random;

public final class Rational {
    private int m_a, m_b;

    private static Rational plus(int a1, int b1, int a2, int b2)
    {
        return new Rational(a1 * b2 + a2 * b1, b1 * b2);
    }

    private static Rational minus(int a1, int b1, int a2, int b2)
    {
        return plus(a1, b1, -a2, b2);
    }

    private static Rational multiply(int a1, int b1, int a2, int b2)
    {
        return new Rational(a1 * a2, b1 * b2);
    }

    private static Rational div(int a1, int b1, int a2, int b2)
    {
        return multiply(a1, b1, b2, a2);
    }

    private static void control(int a, int b)
    {
        if (b == 0) {
            if (a == 0)
                throw new RationalException("Belirsiz", RationalExceptionStatus.INDEFINITE);

            throw new RationalException("Tanımsız", RationalExceptionStatus.UNDEFINED);
        }
    }

    private void calibrateSigns()
    {
        if (m_b < 0) {
            m_a *= -1;
            m_b *= -1;
        }
    }

    private void set(int a, int b)
    {
        m_a = a;
        if (m_a == 0) {
            m_b = 1;
            return;
        }

        m_b = b;
        this.calibrateSigns();
        this.simplify();
    }

    private void simplify()
    {
        int a = Math.abs(m_a);
        int b = m_b;

        int min = a > b ? b : a;

        for (int i = min; i >= 2; --i) {
            if (a % i == 0 && b % i == 0) {
                m_a /= i;
                m_b /= i;
                break;
            }
        }
    }

    public static Rational randomRational(int min, int max) //[min, max)
    {
        return randomRational(new Random(), min, max);
    }

    public static Rational randomRational(Random r, int min, int max)  //[min, max)
    {
        return new Rational(r.nextInt(max - min) + min, r.nextInt(max - min) + min);
    }

    public Rational()
    {
        m_b = 1;
    }

    public Rational(int a, int b)
    {
        control(a, b);
        this.set(a, b);
    }

    public void setNumerator(int val)
    {
        if (m_a == val)
            return;

        this.set(val, m_b);
    }

    public void setDenominator(int val)
    {
        if (m_b == val)
            return;

        control(m_a, val);
        this.set(m_a, val);
    }

    public int getNumerator()
    {
        return m_a;
    }

    public int getDenominator()
    {
        return m_b;
    }

    public double toDouble()
    {
        return (double)m_a / m_b;
    }

    //plus methods
    public static Rational plus(int val, Rational r)
    {
        return plus(val, 1, r.m_a, r.m_b);
    }

    public Rational plus(Rational r)
    {
        return plus(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational plus(int val)
    {
        return plus(m_a, m_b, val, 1);
    }

    //minus methods
    public static Rational minus(int val, Rational r)
    {
        return minus(val, 1, r.m_a, r.m_b);
    }

    public Rational minus(Rational r)
    {
        return minus(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational minus(int val)
    {
        return minus(m_a, m_b, val, 1);
    }

    //multiply methods
    public static Rational multiply(int val, Rational r)
    {
        return multiply(val, 1, r.m_a, r.m_b);
    }

    public Rational multiply(Rational r)
    {
        return multiply(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational multiply(int val)
    {
        return multiply(m_a, m_b, val, 1);
    }

    //div methods
    public static Rational div(int val, Rational r)
    {
        return div(val, 1, r.m_a, r.m_b);
    }

    public Rational div(Rational r)
    {
        return div(m_a, m_b, r.m_a, r.m_b);
    }

    public Rational div(int val)
    {
        return div(m_a, m_b, val, 1);
    }

    //inc methods
    public void inc()
    {
        this.inc(1);
    }
    public void inc(int amount)
    {
        m_a += amount * m_b;
    }

    //dec methods
    public void dec()
    {
        this.dec(1);
    }
    public void dec(int amount)
    {
        this.inc(-amount);
    }

    //pow method
    public void pow(int n)
    {
        m_a = (int)Math.pow(m_a, n);
        m_b = (int)Math.pow(m_b, n);
    }

    public int compareTo(Rational r)
    {
        return m_a * r.m_b - r.m_a * m_b;
    }

    public String toString()
    {
        return this.toString(6);
    }

    public String toString(int n)
    {
        String fmt = String.format("%%d / %%d = %%.%df", n);

        return String.format(fmt, m_a, m_b, toDouble());
    }
}
package org.csystem.math;

public class RationalException extends NumberFormatException {
    private RationalExceptionStatus m_rationalExceptionStatus;

    public RationalException(String msg, RationalExceptionStatus rationalExceptionStatus)
    {
        super(msg);
        m_rationalExceptionStatus = rationalExceptionStatus;
    }

    public RationalExceptionStatus getRationalExceptionStatus() {return m_rationalExceptionStatus;}

    public String getMessage()
    {
        return String.format("Message:%s, Status:%s", super.getMessage(), m_rationalExceptionStatus);
    }
}

package org.csystem.math;

public enum RationalExceptionStatus {INDEFINITE, UNDEFINED}


/*----------------------------------------------------------------------------------------------------------------------
    Date sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Date {
    private static final String [] ms_weekDaysTR;
    private static final String [] ms_weekDaysEN;

    static {
        ms_weekDaysTR = new String[]{"Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"};
        ms_weekDaysEN = new String[]{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    }

    private int m_day, m_mon, m_year;
    private int m_dayOfWeek;

    private static int getDayOfWeek(int day, int mon, int year)
    {
        int totalDays = getDayOfYear(day, mon, year);

        for (int y = 1900; y < year; ++y)
            totalDays += Month.isLeapYear(y) ? 366 : 365;

        return totalDays % 7;
    }

    private static int getDayOfYear(int day, int mon, int year)
    {
        int dayOfYear = day;

        for (int m = mon - 1; m >= 1; --m)
            dayOfYear += Month.values()[m - 1].getDaysByYear(year);

        return dayOfYear;
    }

    private static boolean isValidDate(int day, int mon, int year)
    {
        if (day < 1 || day > 31 || mon < 1 || mon > 12)
            return false;

        int days =  Month.values()[mon - 1].getDaysByYear(year);

        return day <= days;
    }

    private static void doWorkForException(String msg)
    {
        throw new DateTimeException(msg);
    }

    private static void control(int day, int mon, int year, String msg)
    {
        if (!isValidDate(day, mon, year))
            doWorkForException(msg);
    }

    private void controlForDay(int day)
    {
        control(day, m_mon, m_year, "Invalid day");
    }

    private void controlForMonValue(int monVal)
    {
        control(m_day, monVal, m_year, "Invalid month");
    }

    private void controlForYear(int year)
    {
        control(m_day, m_mon, year, "Invalid year");
    }

    private void set(int day, int mon, int year)
    {
        m_day = day;
        m_mon = mon;
        m_year = year;
        m_dayOfWeek = getDayOfWeek(m_day, m_mon, m_year);
    }

    private int getDayOfWeekValue() {return m_dayOfWeek;}

    public static Date randomDate()
    {
        return randomDate(new Random());
    }

    public static Date randomDate(Random r)
    {
        Date now = new Date();

        return randomDate(r, now.m_year, now.m_year);
    }

    public static Date randomDate(int year)
    {
        return randomDate(new Random(), year);
    }

    public static Date randomDate(Random r, int year)
    {
        return randomDate(r, year, year);
    }
    public static Date randomDate(int minYear, int maxYear)
    {
        return randomDate(new Random(), minYear, maxYear);
    }

    public static Date randomDate(Random r, int minYear, int maxYear)
    {
        int year = r.nextInt(maxYear - minYear + 1) + minYear;
        int mon = r.nextInt(12) + 1;
        int days =  Month.values()[mon - 1].getDaysByYear(year);
        int day = r.nextInt(days) + 1;

        return new Date(day, mon, year);
    }

    public Date()
    {
        Calendar now = Calendar.getInstance();

        set(now.get(Calendar.DAY_OF_MONTH), now.get(Calendar.MONTH) + 1, now.get(Calendar.YEAR));
    }

    public Date(int day, Month month, int year)
    {
        this(day, month.ordinal() + 1, year);
    }

    public Date(int day, int mon, int year)
    {
        control(day, mon, year, "Invalid date");
        set(day, mon, year);
    }

    public void setDay(int day)
    {
        if (day == m_day)
            return;

        controlForDay(day);
        set(day, m_mon, m_year);
    }

    public void setMonth(Month month)
    {
        setMonthValue(month.ordinal() + 1);
    }

    public void setMonthValue(int mon)
    {
        if (m_mon == mon)
            return;

        controlForMonValue(mon);
        set(m_day, mon, m_year);
    }

    public void setYear(int year)
    {
        if (m_year == year)
            return;

        controlForYear(year);
        set(m_day, m_mon, year);
    }

    public int getDay()
    {
        return m_day;
    }
    public int getMonthValue()
    {
        return m_mon;
    }
    public Month getMonth() {return Month.values()[m_mon - 1];}
    public int getYear()
    {
        return m_year;
    }
    public DayOfWeek getDayOfWeek() {return DayOfWeek.values()[getDayOfWeekValue()];}
    public String getDayOfWeekTR() {return ms_weekDaysTR[getDayOfWeekValue()];}
    public String getDayOfWeekEN() {return ms_weekDaysEN[getDayOfWeekValue()];}
    public int getDayOfYear() {return getDayOfYear(m_day, m_mon, m_year);}

    public boolean isLeapYear()
    {
        return  Month.isLeapYear(m_year);
    }

    public boolean isWeekend()
    {
        return m_dayOfWeek == 0 || m_dayOfWeek == 6;
    }

    public boolean isWeekday()
    {
        return !isWeekend();
    }

    public String toString(char delim)
    {
        return String.format("%02d%c%02d%c%04d", m_day, delim, m_mon, delim, m_year);
    }

    public String toString()
    {
        return toString('/');
    }

    public String toStringTR()
    {
        return toStringTR('/');
    }

    public String toStringTR(char delim)
    {
        return String.format("%s %s", toString(delim), getDayOfWeekTR());
    }

    public String toStringEN()
    {
        return toStringEN('/');
    }

    public String toStringEN(char delim)
    {
        return String.format("%s %s", toString(delim), getDayOfWeekEN());
    }

    public String toLongDateStringTR()
    {
        //TODO:
        return toStringTR();
    }

    public String toLongDateStringEN()
    {
        //TODO:
        return toStringEN();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
    Time sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.util.datetime;

import java.util.Calendar;
import java.util.Random;

public class Time {
    private int m_hour, m_minute, m_second, m_millisecond;

    private static void doWorkForException(String msg)
    {
        throw new DateTimeException(msg);
    }

    private static boolean isValidForBounds(int val, int min, int max)
    {
        return min <= val && val <= max;
    }

    private static boolean isValidForTime(int hour, int minute, int second, int millisecond)
    {
        return isValidForHour(hour) && isValidForMinute(minute) && isValidForSecond(second)
                && isValidForMillisecond(millisecond);
    }

    private static boolean isValidForHour(int val)
    {
        return isValidForBounds(val, 0, 23);
    }

    private static boolean isValidForMinute(int val)
    {
        return isValidForBounds(val, 0, 59);
    }

    private static boolean isValidForSecond(int val)
    {
        return isValidForBounds(val, 0, 59);
    }

    private static boolean isValidForMillisecond(int val)
    {
        return isValidForBounds(val, 0, 999);
    }

    private static void control(int hour, int minute, int second, int millisecond)
    {
        if (!isValidForTime(hour, minute, second, millisecond))
            doWorkForException("Invalid time");
    }

    private static void controlForHour(int val)
    {
        if (!isValidForHour(val))
            doWorkForException("Invalid hour");
    }

    private static void controlForMinute(int val)
    {
        if (!isValidForMinute(val))
            doWorkForException("Invalid minute");
    }

    private static void controlForSecond(int val)
    {
        if (!isValidForSecond(val))
            doWorkForException("Invalid second");
    }

    private static void controlForMillisecond(int val)
    {
        if (!isValidForMillisecond(val))
            doWorkForException("Invalid millisecond");
    }

    private void set(int hour, int minute, int second, int millisecond)
    {
        m_hour = hour;
        m_minute = minute;
        m_second = second;
        m_millisecond = millisecond;
    }

    public static Time randomTime()
    {
        return randomTime(new Random());
    }

    public static Time randomTime(Random r)
    {
        return new Time(r.nextInt(24), r.nextInt(60), r.nextInt(60), r.nextInt(1000));
    }

    public Time() //Bu kısmın detayları önemsiz
    {
        Calendar now = Calendar.getInstance();

        set(now.get(Calendar.HOUR_OF_DAY), now.get(Calendar.MINUTE), now.get(Calendar.SECOND), now.get(Calendar.MILLISECOND));
    }

    public Time(int hour, int minute)
    {
        this(hour, minute, 0);
    }

    public Time(int hour, int minute, int second)
    {
        this(hour, minute, second, 0);
    }

    public Time(int hour, int minute, int second, int millisecond)
    {
        control(hour, minute, second, millisecond);
        set(hour, minute, second, millisecond);
    }

    public void setHour(int hour)
    {
        if (hour == m_hour)
            return;

        controlForHour(hour);
        m_hour = hour;
    }

    public void setMinute(int minute)
    {
        if (minute == m_minute)
            return;

        controlForMinute(minute);
        m_minute = minute;
    }

    public void setSecond(int second)
    {
        if (second == m_second)
            return;

        controlForSecond(second);
        m_second = second;
    }

    public void setMillisecond(int millisecond)
    {
        if (millisecond == m_millisecond)
            return;

        controlForMillisecond(millisecond);
        m_millisecond = millisecond;
    }

    public int getHour()
    {
        return m_hour;
    }

    public int getMinute()
    {
        return m_minute;
    }

    public int getSecond()
    {
        return m_second;
    }

    public int getMillisecond()
    {
        return m_millisecond;
    }

    public String toString()
    {
        return String.format("%s:%02d", toShortTimeString(), m_second);
    }

    public String toShortTimeString()
    {
        return String.format("%02d:%02d", m_hour, m_minute);
    }

    public String toLongTimeString()
    {
        return String.format("%s.%03d", toString(), m_millisecond);
    }
}

package org.csystem.util.datetime;

public class DateTimeException  extends RuntimeException {
    public DateTimeException()
    {}
    public DateTimeException(String msg)
    {
        super(msg);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	interface bildirimi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde veri elemanı bildirimi yapılabilir. Bu veri elemanları yazılsa da yazılmasa da
	public static ve final olarak bildirilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		System.out.println(IX.PI);
		IX.PI = 2.34; //error
	}
}

interface IX {
	double PI = 3.14;
}

/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde gövdesiz metotlar olabilir. Bu metotlar yazılsa da yazılmasa da public ve abstract olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{

	}
}

interface IX {
	void foo();
	int bar(double val);
}

/*----------------------------------------------------------------------------------------------------------------------
	Hiç bir abstract metodu olmayan arayüzlere işaretleme arayüzleri (marker interfaces) denir.
	Genel olarak işaretleme arayüzlerinin içerisi boş bırakılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{

	}
}

interface IMarker {

}

interface IX { //marker
	String name = "IX";
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte interface içerisinde gövdeli (abstract olmayan) non-static metotlar yazılabilir. Bu metotlar
	default anahtar sözcüğü ile bildirilmelidir. Yazılsa da yazılmasa da public metotladır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{

	}
}

interface IX {
	default void foo() //Since Java 8
	{
		//...
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte bir arayüz içerisinde static metotlar olabilir. Şüphesiz static metotlar
	gövdeli olmalıdır. Bu metotlar da yazılsa da yazılmasa da public dir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        IX.foo();
    }
}

interface IX {
    static void foo() //Since Java 8
    {
        System.out.println("foo");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 8 ile birlikte belli koşullar altında arayüzler kullanım anlamında genişletilmiştir.
	Buna göre içerisinde bir ve yalnız bir tane abstract metodu olan arayüzlere fonksiyonel
	arayüzler (functional interfaces) denir. Bu konu Java 8 ile dile katılan daha kolay ve net yapılabilen fonksiyonel
	programlama tekniğinin temelini oluşturur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        IOperation iop = (a, b) -> a * b;

        System.out.println(iop.appyAsInt(10, 20));
    }
}

interface IOperation {
    static void doWork()
    {
        //...
    }
    int appyAsInt(int a, int b);
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 9 ile birlikte arayüzler içerisinde private metotlar yazılabilir. Şüphesiz bu metotların gövdesi
	olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {

    }
}

interface IX {
    private void foo() //Since Java 9
    {
        //...
    }

    default void bar()
    {
        foo();
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde bulunabilen private metotlar static olarak da bildirilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{

	}
}

interface IX {
	private static void foo() //Since Java 9
	{
		//...
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	interface içerisinde olabilecek elemanlar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

interface IX {
    int NUM = 10;
    private void foo() //Since Java 9
    {

    }
    private static void bar() //Since Java 9
    {

    }

    default void tar() //Since Java 8
    {

    }
    static void func() // Since Java 8
    {

    }

    void zar();
    void car();
}

/*----------------------------------------------------------------------------------------------------------------------
	interface türünden nesne yaratılmaz ve yaratılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		IX ix = new IX(); //error

	}
}

interface IX {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü implements anahtar sözcüğü ile destekler (implementation)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {


    }
}

class A implements IX {

}

interface IX {
    //...
}



/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf birden fazla arayüzü destekleyebilir. Bu durumda hangi arayüzün listede önce olduğunun
	hiç bir önemi yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{


	}
}

class A implements IX, IY, IZ {

}

interface IX {
	//...
}

interface IY {
	//...
}

interface IZ {
	//...
}


/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf başka bir sınıftan türetilip istediği kadar arayüzü destekleyebilir. Bu durumda taban sınıf
	listenin başında olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{


	}
}

class X {

}
class A extends X implements IX, IY, IZ {

}

interface IX {
	//...
}

interface IY {
	//...
}

interface IZ {
	//...
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü destekliyorsa o arayüzün tüm abstract metotlarını override etmelidir. Eğer birini
	bile override etmezse sınıf bildiriminde abstract yazılmalıdır. Yani sınıf abstract olmalıdır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{


	}
}

abstract class B implements IX {
	public void foo()
	{

	}
}
class A implements IX {
	public void foo()
	{

	}

	public void bar()
	{

	}
}

interface IX {
	void foo();
	void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	Arayüz referansları taban sınıf referansı gibi kullanılabilir. Böylelikle çok biçimlilik arayüzler ile de
	yapılabilmektedir. Yani arayüzler çoklu türetmeyi kısmi olarak kullanabilme olanağı sağlar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Mample m = new Mample();
        Test t = new Test();

        m.doWorkForIX(s);
        m.doWorkForIY(s);
        m.doWorkForIX(t);
    }
}

class Mample {
    public void doWorkForIX(IX ix)
    {
        ix.foo();
    }

    public void doWorkForIY(IY iy)
    {
        iy.bar();
    }
}

class Test implements IX {
    public void foo()
    {
        System.out.println("Test.foo");
    }

}

class Sample implements IX, IY {
    public void foo()
    {
        System.out.println("Sample.foo");
    }

    public void bar()
    {
        System.out.println("Sample.bar");
    }
}

interface IX {
    void foo();
}

interface IY {
    void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	Arayüz referansları taban sınıf referansı gibi kullanılabilir. Böylelikle çok biçimlilik arayüzler ile de
	yapılabilmektedir. Yani arayüzler çoklu türetmeyi kısmi olarak kullanabilme olanağı sağlar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Mample m = new Mample();
        Test t = new Test();

        m.doWorkForIX(s);
        m.doWorkForIY(s);
        m.doWorkForIX(t);
        m.doWorkForIY(t); //error
    }
}

class Mample {
    public void doWorkForIX(IX ix)
    {
        ix.foo();
    }

    public void doWorkForIY(IY iy)
    {
        iy.bar();
    }
}

class Test implements IX {
    public void foo()
    {
        System.out.println("Test.foo");
    }

}

class Sample implements IX, IY {
    public void foo()
    {
        System.out.println("Sample.foo");
    }

    public void bar()
    {
        System.out.println("Sample.bar");
    }
}

interface IX {
    void foo();
}

interface IY {
    void bar();
}


/*----------------------------------------------------------------------------------------------------------------------
	Birden fazla arayüz içerisinde aynı imzaya ve geri dönüş değerine sahip bir sanal metot varsa ve bir sınıf
	bu iki arayüzü de destekliyorsa bir tane metot ikisi için de override edilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();
        Mample m = new Mample();

        s.foo();
        m.doWorkForIX(s);
        m.doWorkForIY(s);
    }
}

class Mample {
    public void doWorkForIX(IX ix)
    {
        ix.foo();
    }

    public void doWorkForIY(IY iy)
    {
        iy.foo();
    }
}

class Sample implements IX, IY {
    public void foo()
    {
        System.out.println("Sample.foo");
    }
}

interface IX {
    void foo();
}

interface IY {
    void foo();
}
/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf bir arayüzü destekliyorsa o sınıftan türetilmiş bir sınıf da aynı arayüzü destekler. Bu durum
	türemiş sınıf arayüz listesinde belirtilmek zorunda değildir. İstenirse belirtilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		B b = new B();

		IX ix = b;

		ix.foo();
	}
}

class B extends A {

}

class A implements IX {
	public void foo()
	{
		System.out.println("A.foo");
	}
}

interface IX {
	void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte B sınıfı IX arayüzünün foo metodunu override etmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		B b = new B();

		IX ix = b;

		ix.foo();
	}
}

class B extends A {
	public void foo()
	{
		System.out.println("B.foo");
	}
}

class A implements IX {
	public void foo()
	{
		System.out.println("A.foo");
	}
}

interface IX {
	void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte foo metodu A sınıfında final yapılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        B b = new B();

        IX ix = b;

        ix.foo();
    }
}

class B extends A {

}

class A implements IX {
    public final void foo()
    {
        System.out.println("A.foo");
    }
}

interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir arayüz başka bir arayüzden türetilebilir. Burada extends anahtar sözcüğü kullanılır.
	Bu durumda türemiş arayüzü destekleyen bir sınıf taban arayüzü de destekler yani somut sınıf olabilmek için
	tüm abstract metotları override etmesi gerekir. Aşağıdaki örnekte A sınıfı hem IY yi hem de IX'i desteklemiş olur.
	Arayüz listesinde sadece IY yazılması yeterlidir. İstenirse IX de yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();

		IY iy = a;
		IX ix = a;

		ix = iy; //upcasting
	}
}

class A implements IY {
	public void foo()
	{

	}

	public void bar()
	{

	}
}

interface IY extends IX {
	void bar();
}

interface IX {
	void foo();
}


/*----------------------------------------------------------------------------------------------------------------------
	Arayüzler arasında çoklu türetme yapılabilir. Aşağıdaki örnekte IZ yi destekleyen bir sınıf listeye yazılsa da
	yazılmasa da IX ve IY yi de destekler
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {

    }
}

class A implements IZ {
    public void foo()
    {

    }

    public void bar()
    {

    }

    public void tar()
    {

    }
}

interface IZ extends IX, IY {
    void tar();
}
interface IY  {
    void foo();
}
interface IX {
    void bar();
}

/*----------------------------------------------------------------------------------------------------------------------
	default metotlar da override edilebilir. Bu durumda çok biçimli olarak override edilen çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IX ix = a;

		ix.foo();
	}
}

class A implements IX {
	public void foo()
	{
		System.out.println("A.foo");
	}
}

interface IX {
	default void foo()
	{
		System.out.println("IX.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte super taban sınıfı temsil ettiğinden ve taban sınıf da Object olduğundan error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IX ix = a;

		ix.foo();
	}
}

class A implements IX {
	public void foo()
	{
		System.out.println("A.foo");
		super.foo(); //error
	}
}

interface IX {
	default void foo()
	{
		System.out.println("IX.foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçerlidir. super.foo() çağrısında B sınfının foo metodu çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IX ix = a;

		ix.foo();
	}
}

class B {
	public void foo()
	{
		System.out.println("B.foo");
	}
}

class A extends B implements IX {
	public void foo()
	{
		System.out.println("A.foo");
		super.foo();
	}
}

interface IX {
	default void foo()
	{
		System.out.println("IX.foo");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçerlidir. B den miras alınan foo metodu IX'in fooo metodu yerine de geçer
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        A a = new A();
        IX ix = a;

        ix.foo();
    }
}

class B {
    public void foo()
    {
        System.out.println("B.foo");
    }
}

class A extends B implements IX {

}

interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçerlidir. A' da override edilen foo aynı zamanda IX türden referans ile de dinamik
	olarak çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IX ix = a;

		ix.foo();
	}
}

class B {
	protected void foo()
	{
		System.out.println("B.foo");
	}
}

class A extends B implements IX {
	public void foo()
	{
		System.out.println("A.foo");
	}
}

interface IX {
	void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durum geçersizdir. Çünkü bir sınıf içerisinde aynı imzaya sahip birden fazla metot bildirilemez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {

    }
}

class A implements IX, IY {
    public void foo() //error
    {

    }

    public int foo() //error
    {
        return 10;
    }
}

interface IX {
    void foo();
}

interface IY {
    int foo();
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki durum covariant return type kuralları dolayısıyla geçerlidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {

    }
}

class A implements IX, IY {
    public String foo()
    {
        return "ankara";
    }
}

interface IX {
    String foo();
}

interface IY {
    Object foo();
}

/*----------------------------------------------------------------------------------------------------------------------
    (Abstract) sınıflar ile arayüzler arasındaki tipik farklar: (maddelerin sırasının önemi yoktur)
    1. Arayüzler interface anahtar sözcüğü ile abstract sınıflar ise class anahtar sözcüğü ile bildirilir
    2. Arayüzler non-static veri elemanlarına sahip olamaz, abstract sınıflar olabilir
    3. Arayüzler nesne olamayacaklarından ctor'ları olamaz, abstract sınıfların olabilir
    4. Arayüzlerin abstract metotları public ve abstract yazılmasa da bu şekilde kabul edilir. abstract
    sınıflarda bunlar yazılmalıdır
    5. Arayüzlere Java 8 ile birlikte eklenen gövdeli non-static metotlar default anahtar sözcüğü ile yazılmalıdır.
    abstract sınıflarda doğrudan erişim belirleyici ile yazılabilir
    6. Arayüzlerin veri elemanları yazılsa da yazılmasa da public, static ve final olur. abstract sınıflarda
    bunlar belirtilmelidir.
    7. Bir sınıf bir arayüzü implements anahtar sözcüğü ile destekler (implementation), abstract sınıftan
    ise extends anahtar sözcüğü ile türetilebilir. Burada arayüzler için türetme teriminin kullanılmadığına
    dikkat ediniz
    8. Bir sınıf istediği kadar arayüzü destekleyebilir, ancak tek bir sınıftan türetilebilir
    9. Arayüzler arasında çoklu türetme yapılabilir. Ancak sınıflar arasında çoklu türetme geçersizdir
    10. Arayüzler türünden nesne hiç bir şekilde yaratılmaz, abstract sınıf türünden nesne türemiş
    sınıf nesnesi içerisinde yaratılır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
	parserapp sınıfları
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.samples.parserapp.ParserTest;

public class App {
    public static void main(String [] args)
    {
        ParserTest.run();
    }
}


package org.csystem.samples.parserapp;

public interface ISource {
    int getChar();
}


package org.csystem.samples.parserapp;

public class Parser {
    private ISource m_source;

    public Parser(ISource source)
    {
        this.setSource(source);
    }

    public void setSource(ISource source)
    {
        //...
        m_source = source;
    }

    public void doParse()
    {
        int count = 0;

        int ch;

        while ((ch = m_source.getChar()) != -1)
            if (Character.isLetter((char)ch))
                ++count;

        System.out.printf("Count:%d%n", count);
    }
}


package org.csystem.samples.parserapp;

public class CharArraySource implements ISource {
    private final char [] m_chars;
    private int m_index;

    public CharArraySource(char [] chars)
    {
        m_chars = chars;
    }

    public CharArraySource(String str)
    {
        this(str.toCharArray());
    }

    public int getChar()
    {
        return m_index == m_chars.length ? -1 : m_chars[m_index++];
    }
}


package org.csystem.samples.parserapp;

public class StringSource implements ISource {
    private final String m_str;
    private final int m_length;
    private int m_index;

    public StringSource(String str)
    {
        m_str = str;
        m_length = m_str.length();
    }

    public int getChar()
    {
        return m_index == m_length ? -1 : m_str.charAt(m_index++);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
    Arayüzlerle İlgili Tür Dönüştürmeleri

    Arayüzlerle ilgili tür dönüştürmeleri dört durum olarak ele alınabilir:

    1. Bir sınıf referansının onun desteklediği bir arayüz referansına dönüştürülmesi

    2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi

    3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi

    4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
	1. Bir sınıf referansının onun desteklediği bir arayüz referansına dönüştürülmesi:
	Bu durum çok aşikar bir durumdur. Arayüz referansının taban sınıf referansı gibi kullanılmasıdır.
	Zaten hedefine de uygundur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();

		IX ix = a;
	}
}

class A implements IX {

}

interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi:
	Bu dönüşüm tür dönüştürme operatörü ile yapılmalıdır. Ancak çalışma zamanı sırasında arayüz referansının
	dinamik türünün dönüştürülecek sınıfı kapsayıp kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür.
	Kapsamıyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IX ix = a;

		B b = (B)ix; //Haklı dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class A extends B implements IX {

}

class B {

}
interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi:
	Bu dönüşüm tür dönüştürme operatörü ile yapılmalıdır. Ancak çalışma zamanı sırasında arayüz referansının
	dinamik türünün dönüştürülecek sınıfı kapsayıp kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür.
	Kapsamıyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IX ix = a;

		B b = (B)ix; //Haksız dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class A implements IX {
}

class B {

}
interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	2. Bir arayüz referansının herhangi bir sınıf türüne dönüştürülmesi:
	Bu dönüşüm tür dönüştürme operatörü ile yapılmalıdır. Ancak çalışma zamanı sırasında arayüz referansının
	dinamik türünün dönüştürülecek sınıfı kapsayıp kapsamadığına bakılır. Kapsıyorsa haklı dönüşümdür.
	Kapsamıyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IX ix = a;

		B b = (B)ix; //Haksız dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class A implements IX {
}

class B extends A {

}
interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilmişse doğrudan
	yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IY iy = a;
		IX ix = iy; //upcasting
		//...
	}
}


class A  implements IY {

}
interface IY extends IX {

}
interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse
	tür dönüştürme operatörü ile yapılabilir. Bu durumda çalışma zamanı sırasında kaynak arayüz referansının
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşüdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IY iy = a;
		IX ix = (IX)iy; //Haklı dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class A  implements IY, IX {

}
interface IY {

}
interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse
	tür dönüştürme operatörü ile yapılabilir. Bu durumda çalışma zamanı sırasında kaynak arayüz referansının
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşüdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A();
		IY iy = a;
		IX ix = (IX)iy; //Haksız dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class A  implements IY {

}
interface IY {

}
interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse
	tür dönüştürme operatörü ile yapılabilir. Bu durumda çalışma zamanı sırasında kaynak arayüz referansının
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşüdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new B();
		IY iy = a;
		IX ix = (IX)iy; //Haklı dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");
	}
}


class B extends A implements IX {

}

class A implements IY {

}
interface IY {

}
interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	3. Bir arayüz referansının başka bir arayüz referansına dönüştürülmesi:
	Bu durum iki şekilde incelenebilir:
	- Kaynak arayüz referansına ilişkin tür hedef arayüz referansına ilişkin türden türetilMEmişse
	tür dönüştürme operatörü ile yapılabilir. Bu durumda çalışma zamanı sırasında kaynak arayüz referansının
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşüdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        A a = new B();
        IY iy = a;
        IX ix = (IX)iy; //Haksız dönüşüm

        System.out.println("Tekrar yapıyor musunuz?");
    }
}


class B extends A {

}

class A implements IY {

}
interface IY {

}
interface IX {

}
/*----------------------------------------------------------------------------------------------------------------------
	4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi:
	Bu işlem tür dönüştürme operatörü ile yapılabilir. Çalışma zamanı sırasında kaynak referansın
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşümdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new B();
		IX ix = (IX)a;//Haklı dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");

	}
}

class B extends A implements IX {

}
class A {

}

interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	4. Bir sınıf referansının onun desteklemediği bir arayüz referansına dönüştürülmesi:
	Bu işlem tür dönüştürme operatörü ile yapılabilir. Çalışma zamanı sırasında kaynak referansın
	dinamik türünün hedef arayüzü destekleyip desteklemediğine bakılır. Destekliyorsa haklı dönüşümdür.
	Desteklemiyorsa haksız dönüşümdür. ClassCastException fırlatılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new B();
		IX ix = (IX)a; //Haksız dönüşüm

		System.out.println("Tekrar yapıyor musunuz?");

	}
}

class B extends A {

}
class A {

}

interface IX {

}

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir klonlama işlemi
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(10);

        System.out.println("s:");
        s.foo();

        Sample clone = (Sample)s.clone();

        System.out.println("clone:");
        clone.foo();

        System.out.println("s:");
        s.foo();
    }
}

class Sample implements Cloneable {
    private int m_x;
    private boolean m_flag;

    public Sample(int x)
    {
        m_x = x;
    }

    public int getX() {return m_x;}

    public void foo()
    {
        System.out.printf("Before:m_flag=%b%n", m_flag);
        m_flag = !m_flag;
        System.out.printf("After:m_flag=%b%n", m_flag);
    }

    public Object clone()
    {
        Sample s = new Sample(m_x);

        s.m_flag = m_flag;

        return s;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir sığ kopyalama (shallow copy) örneği
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A(10);
		B b = new B(23, a);

		B clone = (B)b.clone();

		System.out.printf("b.a.x=%d%n", b.getA().getX());
		System.out.printf("clone.a.x=%d%n", clone.getA().getX());
		System.out.printf("b.y=%d%n", b.getY());
		System.out.printf("clone.y=%d%n", clone.getY());

		b.getA().setX(45);
		b.setY(89);

		System.out.println("**************");
		System.out.printf("b.a.x=%d%n", b.getA().getX());
		System.out.printf("clone.a.x=%d%n", clone.getA().getX());
		System.out.printf("b.y=%d%n", b.getY());
		System.out.printf("clone.y=%d%n", clone.getY());
	}
}

class B implements Cloneable {
	private int m_y;
	private A m_a;

	public B(int y, A a)
	{
		m_y = y;
		m_a = a;
	}

	public int getY()
	{
		return m_y;
	}

	public void setY(int y)
	{
		m_y = y;
	}

	public A getA()
	{
		return m_a;
	}

	public void setA(A a)
	{
		m_a = a;
	}

	public Object clone()
	{
		B b = new B(m_y, m_a);

		return b;
	}
}
class A {
	private int m_x;

	public A(int x)
	{
		m_x = x;
	}

	public int getX()
	{
		return m_x;
	}

	public void setX(int x)
	{
		m_x = x;
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Basit bir derin kopyalama (deep copy) örneği
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
	public static void main(String [] args)
	{
		A a = new A(10);
		B b = new B(23, a);

		B clone = (B)b.clone();

		System.out.printf("b.a.x=%d%n", b.getA().getX());
		System.out.printf("clone.a.x=%d%n", clone.getA().getX());
		System.out.printf("b.y=%d%n", b.getY());
		System.out.printf("clone.y=%d%n", clone.getY());

		b.getA().setX(45);
		b.setY(89);

		System.out.println("**************");
		System.out.printf("b.a.x=%d%n", b.getA().getX());
		System.out.printf("clone.a.x=%d%n", clone.getA().getX());
		System.out.printf("b.y=%d%n", b.getY());
		System.out.printf("clone.y=%d%n", clone.getY());
	}
}

class B implements Cloneable {
	private int m_y;
	private A m_a;

	public B(int y, A a)
	{
		m_y = y;
		m_a = a;
	}

	public int getY()
	{
		return m_y;
	}

	public void setY(int y)
	{
		m_y = y;
	}

	public A getA()
	{
		return m_a;
	}

	public void setA(A a)
	{
		m_a = a;
	}

	public Object clone()
	{
		B b = new B(m_y, (A)m_a.clone());

		return b;
	}
}

class A implements Cloneable {
	private int m_x;

	public A(int x)
	{
		m_x = x;
	}

	public int getX()
	{
		return m_x;
	}

	public void setX(int x)
	{
		m_x = x;
	}
	public Object clone()
	{
		return new A(m_x);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	clone metodu aşağıdaki gibi override edilirse (covariant return type) downcasting yapılmadan da kullanılabilir.
	Ancak bu yaklaşımla Java' da pek kod yazılmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

public class App {
    public static void main(String [] args)
    {
        Sample s = new Sample(10);

        System.out.println("s:");
        s.foo();

        Sample clone = s.clone();

        System.out.println("clone:");
        clone.foo();

        System.out.println("s:");
        s.foo();
    }
}

class Sample implements Cloneable {
    private int m_x;
    private boolean m_flag;

    public Sample(int x)
    {
        m_x = x;
    }

    public int getX() {return m_x;}

    public void foo()
    {
        System.out.printf("Before:m_flag=%b%n", m_flag);
        m_flag = !m_flag;
        System.out.printf("After:m_flag=%b%n", m_flag);
    }

    public Sample clone()
    {
        Sample s = new Sample(m_x);

        s.m_flag = m_flag;

        return s;
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfı sığ kopyalama yapar. Aşağıdaki örneği inceleyiniz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

public class App {
	public static void main(String [] args)
	{
		ArrayList devices = new ArrayList();

		devices.add(new DeviceInfo(1, "test", 5050));
		devices.add(new DeviceInfo(2, "sensor", 5051));
		devices.add(new DeviceInfo(3, "mest", 5698));

		System.out.printf("devices:%s%n", devices);

		ArrayList clone = (ArrayList)devices.clone();

		System.out.printf("clone:%s%n", clone);

		System.out.println("********************");

		((DeviceInfo)clone.get(1)).setName("SENSOR");

		System.out.printf("devices:%s%n", devices);
		System.out.printf("clone:%s%n", clone);
	}
}

class DeviceInfo {
	private int m_id;
	private String m_name;
	private int m_port;

	public DeviceInfo() {}
	public DeviceInfo(int id, String name, int port)
	{
		//...
		m_id = id;
		m_name = name;
		m_port = port;
	}

	public int getId()
	{
		return m_id;
	}

	public void setId(int id)
	{
		//...
		m_id = id;
	}

	public String getName()
	{
		return m_name;
	}

	public void setName(String name)
	{
		//...
		m_name = name;
	}

	public int getPort()
	{
		return m_port;
	}

	public void setPort(int port)
	{
		//...
		m_port = port;
	}
	public String toString()
	{
		return String.format("[%d]%s:%d", m_id, m_name, m_port);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte clone referansına ilişkin nesnenin içerisindeki bir bilgi değiştirilmiştir.
	Yani artık clone yeni adresteki nesneyi görmektedir. Orjinal nesne bundan etkilenmez
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

public class App {
	public static void main(String [] args)
	{
		ArrayList devices = new ArrayList();

		devices.add(new DeviceInfo(1, "test", 5050));
		devices.add(new DeviceInfo(2, "sensor", 5051));
		devices.add(new DeviceInfo(3, "mest", 5698));

		System.out.printf("devices:%s%n", devices);

		ArrayList clone = (ArrayList)devices.clone();

		System.out.printf("clone:%s%n", clone);

		System.out.println("********************");

		clone.set(1, new DeviceInfo(2, "SENSOR", 6767));

		System.out.printf("devices:%s%n", devices);
		System.out.printf("clone:%s%n", clone);
	}
}

class DeviceInfo {
	private int m_id;
	private String m_name;
	private int m_port;

	public DeviceInfo() {}
	public DeviceInfo(int id, String name, int port)
	{
		//...
		m_id = id;
		m_name = name;
		m_port = port;
	}

	public int getId()
	{
		return m_id;
	}

	public void setId(int id)
	{
		//...
		m_id = id;
	}

	public String getName()
	{
		return m_name;
	}

	public void setName(String name)
	{
		//...
		m_name = name;
	}

	public int getPort()
	{
		return m_port;
	}

	public void setPort(int port)
	{
		//...
		m_port = port;
	}
	public String toString()
	{
		return String.format("[%d]%s:%d", m_id, m_name, m_port);
	}
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte devices referansına ilişkin ArrayList nesnesine yeni bir eleman eklenmiştir. clone
	referansına ilişkin ArrayList nesnesinin bundan haberi olmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

public class App {
	public static void main(String [] args)
	{
		ArrayList devices = new ArrayList();

		devices.add(new DeviceInfo(1, "test", 5050));
		devices.add(new DeviceInfo(2, "sensor", 5051));
		devices.add(new DeviceInfo(3, "mest", 5698));

		System.out.printf("devices:%s%n", devices);

		ArrayList clone = (ArrayList)devices.clone();

		System.out.printf("clone:%s%n", clone);

		System.out.println("********************");

		devices.add(new DeviceInfo(5, "weathersensor", 9898));

		System.out.printf("devices:%s%n", devices);
		System.out.printf("clone:%s%n", clone);
	}
}

class DeviceInfo {
	private int m_id;
	private String m_name;
	private int m_port;

	public DeviceInfo() {}
	public DeviceInfo(int id, String name, int port)
	{
		//...
		m_id = id;
		m_name = name;
		m_port = port;
	}

	public int getId()
	{
		return m_id;
	}

	public void setId(int id)
	{
		//...
		m_id = id;
	}

	public String getName()
	{
		return m_name;
	}

	public void setName(String name)
	{
		//...
		m_name = name;
	}

	public int getPort()
	{
		return m_port;
	}

	public void setPort(int port)
	{
		//...
		m_port = port;
	}
	public String toString()
	{
		return String.format("[%d]%s:%d", m_id, m_name, m_port);
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte finally bloğunda çağrılan close metodu try-catch içerisine alınarak checked exception fırlatmasından
	dolayı oluşan error engellenmiştir.	Ancak çoğu zaman close metodunun exception fırlatması durumu programın ilgileneceği
	birşey değildir. Yani açık olan bir kaynağın close yapılamaması durumunda çoğu zaman programcının yapabileceği
	birşey yoktur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

public class App {
	public static void main(String [] args)
	{
		Connection con  = null;

		try {
			con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
			con.doWork();
		}
		catch (Throwable ex) {
			System.out.printf(ex.getMessage());
		}
		finally {
			try {
				if (con != null)
					con.close();
			}
			catch (IOException ex) {
				//...
			}
		}

	}
}

class Connection implements Closeable {
	private String m_url;
	public Connection(String url)
	{
		//...
		m_url = url;
		System.out.printf("Connected to:%s%n", m_url);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on connection at '%s'%n", m_url);
	}
	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem aşağıdaki gibi daha az karmaşık ve biraz daha okunabilir olarak çözülebilir.
	Ayrıca bu yaklaşımda close metodu için exception işlenmesi de yapılabilir. Ancak üstteki örnekte close
	için yapılacak exception işlenmesi ayrıca yapılmak zorundadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

public class App {
    public static void main(String [] args)
    {
        Connection con  = null;

        try {
            try {
                con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
                con.doWork();
            }
            finally {
                if (con != null)
                    con.close();
            }
        }
        catch (Throwable ex) {
            System.out.printf(ex.getMessage());
        }
    }
}

class Connection implements Closeable {
    private String m_url;
    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte eklenen try-with resources (twr) deyimi ile yukarıdaki problem çok daha etkin olarak çözülebilir.
	twr deyimi ile AutoCloseable arayüzünü destekleyen sınıflar kullanılabilir. twr yukarıdaki işlemin
	otomatik olarak yapılanı biçiminde düşünülebilir. Closeable arayüzü AutoCloseable arayüzünden türetilmiştir.
	Bu deyim ile close metodunun çağrılacağı da garanti altında olduğundan programcının çağırmayı unutması gibi
	bir durum da yaşanmaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

public class App {
	public static void main(String [] args)
	{
		try (Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb")) {
			con.doWork();
		}
		catch (Throwable ex) {
			System.out.printf(ex.getMessage());
		}
	}
}

class Connection implements Closeable {
	private String m_url;
	public Connection(String url)
	{
		//...
		m_url = url;
		System.out.printf("Connected to:%s%n", m_url);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on connection at '%s'%n", m_url);
	}
	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	twr birden fazla sınıf ile de kullanılabilir. Bu durumda close yaratılma sırasının tersinde çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

public class App {
	public static void main(String [] args)
	{
		try (Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
			 Image image = new Image("tatil.png")) {
			con.doWork();
		}
		catch (Throwable ex) {
			System.out.printf(ex.getMessage());
		}
	}
}

class Connection implements Closeable {
	private String m_url;
	public Connection(String url)
	{
		//...
		m_url = url;
		System.out.printf("Connected to:%s%n", m_url);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on connection at '%s'%n", m_url);
	}
	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}

}


class Image implements Closeable {
	private String m_filename;
	public Image(String filename)
	{
		//...
		m_filename  = filename;
		System.out.printf("%s image opened%n", m_filename);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on image '%s'%n", m_filename);
	}
	public void close() throws IOException
	{
		System.out.println("Image closed");
	}

}

/*----------------------------------------------------------------------------------------------------------------------
	twr içerisinde kullanılan referanslar final kabul edilir (effectively final)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

public class App {
	public static void main(String [] args)
	{
		try (Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
			 Image image = new Image("tatil.png")) {
			con = new Connection("test"); //error
			con.doWork();
		}
		catch (Throwable ex) {
			System.out.printf(ex.getMessage());
		}
	}
}

class Connection implements Closeable {
	private String m_url;
	public Connection(String url)
	{
		//...
		m_url = url;
		System.out.printf("Connected to:%s%n", m_url);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on connection at '%s'%n", m_url);
	}
	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}

}


class Image implements Closeable {
	private String m_filename;
	public Image(String filename)
	{
		//...
		m_filename  = filename;
		System.out.printf("%s image opened%n", m_filename);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on image '%s'%n", m_filename);
	}
	public void close() throws IOException
	{
		System.out.println("Image closed");
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 9 ile birlikte twr den önce yaratılmış olan nesnelere ilişkin referans lar da twr parantezi
	içerisinde kullanılabilmektedir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

public class App {
	public static void main(String [] args)
	{
		Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
		Image image = new Image("tatil.png");

		try (con; image) { //Since Java 9
			con.doWork();
		}
		catch (Throwable ex) {
			System.out.printf(ex.getMessage());
		}
	}
}

class Connection implements Closeable {
	private String m_url;
	public Connection(String url)
	{
		//...
		m_url = url;
		System.out.printf("Connected to:%s%n", m_url);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on connection at '%s'%n", m_url);
	}
	public void close() throws IOException
	{
		System.out.println("Connection closed");
	}

}


class Image implements Closeable {
	private String m_filename;
	public Image(String filename)
	{
		//...
		m_filename  = filename;
		System.out.printf("%s image opened%n", m_filename);
	}

	public void doWork()
	{
		//...
		System.out.printf("Working on image '%s'%n", m_filename);
	}
	public void close() throws IOException
	{
		System.out.println("Image closed");
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	twr parantezi içerisinde kullanılan referanslar yine final etkisi gösterir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.io.Closeable;
import java.io.IOException;

public class App {
    public static void main(String [] args)
    {
        Connection con = new Connection("postgresql:jdbc://localhost:8080/devicesdb");
        Image image = new Image("tatil.png");

        try (con; image) { //error
            con.doWork();

            con = new Connection("test");
        }
        catch (Throwable ex) {
            System.out.printf(ex.getMessage());
        }
    }
}

class Connection implements Closeable {
    private String m_url;
    public Connection(String url)
    {
        //...
        m_url = url;
        System.out.printf("Connected to:%s%n", m_url);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on connection at '%s'%n", m_url);
    }
    public void close() throws IOException
    {
        System.out.println("Connection closed");
    }

}


class Image implements Closeable {
    private String m_filename;
    public Image(String filename)
    {
        //...
        m_filename  = filename;
        System.out.printf("%s image opened%n", m_filename);
    }

    public void doWork()
    {
        //...
        System.out.printf("Working on image '%s'%n", m_filename);
    }
    public void close() throws IOException
    {
        System.out.println("Image closed");
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	19.04.2020
	Generic sınıf bildirimde generic parametreler denen isimler kullanılır. Bu isimler açısal parantezler arasında
	virgülle ayrılacak şekilde yazılır. Generic parametreler değişken isimlendirme kurallarına uygun isimlerdir.
	Bu isimlerbildirildikleri sınıf boyunca geçerlidir (class scope, sınıf faaliyet alanı). Generic parametre ismi
	bir tür ismi anlamına gelir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class A<T> { // T generic parametre
    //...
    private T m_t;
}


abstract  class B<T, K, L> {
    //...
    public abstract T foo(K k, L l);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıflar açılım ile kullanılabilir. Açılım generic parametrenin türünü belirtir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A<String> a; // A nın String açılımı
		A<Integer> b; // A nın Integer açılımı
	}
}

class A<T> { // T generic parametre
	//...
	private T m_t;
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıf açılımsız kullanılırsa generic parametreler Object kabul edilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A a; // T Object kabul edilir

	}
}

class A<T> { // T generic parametre
	//...
	private T m_t;
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic açılımlar temel türlerle yapılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A<int> a; // error

	}
}

class A<T> { // T generic parametre
	//...
	private T m_t;
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıflar
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<Boolean, String> a;
        A<Integer, Boolean> b;
        //...
    }
}

class A<T, K> {
    //...

}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıflar türünden nesne yaratılması aşağıdaki gibi yapılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<Boolean, String> x = new A<Boolean, String>();
        A<Integer, Float> y = new A<Integer, Float>();

        //...
    }
}

class A<T, K> {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Java 7 ile birlikte new opertörü ile açılım yapılırken türler yazılmayabilir. Ancak açısal parantezler olmalıdır
	(diamond syntax)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<Boolean, String> x = new A<>(); //Since Java 7 : Diamond syntax
        A<Integer, Float> y = new A<>();

        //...
    }
}

class A<T, K> {
    //...
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıflar Object için kullanılacaksa Object açılımı yapılması iyi bir tekniktir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{
		A<Object> x = new A<>();

		//...
	}
}

class A<T> {
	//...

}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların generic parametrelerinin kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

abstract class A<T, R> {
    public abstract  R get(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıf generic olmayan bir sınıftan türetilebilir. Bu durumda generic sınıfın her açılımı
	o taban sınıftan türetilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<Boolean> bb = new B<>();
        B<String> bs = new B<>();

        A x;

        x = bs;

        x = bb;

        //...
    }
}

class A {
    //...
}
class B<T> extends A {
    //
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic olmayan bir sınıf generic bir sınıfın herhangi bir açılımından türetilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();
        A<String> a = b;

        b.foo("ankara");
        a.foo("istanbul");
        a.foo(10); //error
        A<Integer> ai = b; //error

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

class B extends A<String> {
    //
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic olmayan bir sınıf generic bir sınıfın herhangi bir açılımından türetilebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();
        A<String> a = b;

        a.foo("istanbul");

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}
class B extends A<String> {
    public void foo(String str)
    {
        super.foo(str);
        System.out.println(str.toUpperCase());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte derleme zamanında tür kontrolü dolayısıyla error oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();
        A<String> a = b;

        a.foo(3.4); //error

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}
class B extends A<String> {
    public void foo(String str)
    {
        super.foo(str);
        System.out.println(str.toUpperCase());
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte generic a sınıfı açılımsız kullanıldığında derleme zamanı tür kontrolü yapılmaz.
	Örneğimiz için foo metoduna double türü geçirildiğinde exception oluşur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B b = new B();
        A a = b;

        a.foo(3.4);

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}
class B extends A<String> {
    public void foo(String str)
    {
        super.foo(str);
        System.out.println(str.toUpperCase());
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıf başka bir generic sınıftan türetilebilir. Bu durumda türemiş sınıfın her açılımı
	taban sınıfın o açılımından türetilmiş olur
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<Integer> b = new B<>();
        A<Integer> a = b;

        b.foo(10);
        b.bar(1);

        B<String> b1 = new B<>();
        A<String> a1 = b1;

        a1.foo("ankara");
        b1.bar("istanbul");
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}
class B<T> extends A<T> {
    public void bar(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte K türü taban sınıf için kullanılmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<Integer, String> x = new B<>();
        A<String> y = x;

        x.bar(10);
        x.foo("ankara");
        y.foo("izmir");

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}

class B<T, K> extends A<K> {
    public void bar(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic kavramı derleme zamanında tür kontrolü için düşünülmüştür. Aşağıdaki örnekte x' in türünden dolayı
	A<Boolean> açılımına atanamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        B<Integer, String> x = new B<>();
        A<Boolean> y = x; //error

        //...
    }
}

class A<T> {
    public void foo(T t)
    {
        System.out.println(t);
    }
}
class B<T, K> extends A<K> {
    public void bar(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfının kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<String> names = new ArrayList<>();

        names.add("ali");
        names.add("veli");
        names.add("selami");

        for (String name : names)
            System.out.println(name.toUpperCase());

        System.out.println("***************");

        for (int i = 0; i < names.size(); ++i) {
            String str = names.get(i);
            System.out.println(str.toUpperCase());
        }

    }
}
/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfının kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < 10; ++i)
            list.add(i * 10);

        for (int val : list)
            System.out.printf("%d ", val);

        System.out.println();
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Çalışma zamanı sırasında generic bir sınıfın her açılımı aynı türdendir. Yani sınıf generic bile olsa
	o sınıfa ilişkin tek bir tür bulunmaktadır. Arakod içerisinde sadece A sınıfı bulunmaktadır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<String> as = new A<>();
        A<Integer> ai = new A<>();
        A<Boolean> ab = new A<>();

        System.out.println(as.getClass().getName());
        System.out.println(ab.getClass().getName());
        System.out.println(ai.getClass().getName());
    }
}


class A<T> {
    //...
}


/*----------------------------------------------------------------------------------------------------------------------
	ArrayList sınıfının kullanımı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
	public static void main(String [] args)
	{
		ArrayList<ArrayList<String>> names = new ArrayList<>();
		ArrayList<String> nameList = new ArrayList<>();

		nameList.add("Ali");
		nameList.add("Veli");

		names.add(nameList);

		nameList = new ArrayList<>();

		nameList.add("Ayşe");
		nameList.add("Fatma");
		nameList.add("Zeynep");

		names.add(nameList);
		for (ArrayList<String> nl : names) {
			for (String name : nl)
				System.out.printf("%s ", name);
			System.out.println();
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzün herhangi bir açılımını implemente eden bir sınıf metotları açılıma
	uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo("ankara");
    }
}

class Sample implements IX<String> {
    public void foo(String str)
    {
        System.out.println(str.toUpperCase());
    }
}

interface IX<T> {
    void foo(T t);
}
/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzün herhangi bir açılımını implemente eden bir sınıfın metotları açılıma
	uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        IX<String> ix = s;

        s.foo("ankara");
        ix.foo("izmir");
    }
}

class Sample implements IX<String> {
    public void foo(String str)
    {
        System.out.println(str.toUpperCase());
    }
}

interface IX<T> {
    void foo(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzün herhangi bir açılımını implemente eden bir sınıf metotları açılıma
	uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        System.out.println(s.convert("ankara"));
    }
}

class Sample implements IConverter<String, Integer> {
    public Integer convert(String str)
    {
        return str.length();
    }
}

interface IConverter<T, R> {
    R convert(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzün herhangi bir açılımını implemente eden bir sınıf metotları açılıma
	uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        System.out.println(s.convert("ankara"));
    }
}

class Sample implements IConverter<String, Integer> {
    public Integer convert(String str)
    {
        return str.length();
    }
}

interface IConverter<T, R> {
    R convert(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzün herhangi bir açılımını implemente eden bir sınıfın metotları açılıma
	uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.foo("ankara");
        s.bar(20);
    }
}

class Sample implements IX<String>, IY<Integer> {
    public void foo(String str)
    {
        System.out.println(str.toUpperCase());
    }

    public void bar(Integer i)
    {
        System.out.println(i * i);
    }
}

interface IX<T> {
    void foo(T t);
}

interface IY<T> {
    void bar(T t);
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic bir arayüzü implemente eden bir sınıf metotları açılıma uygun şekilde override edilmelidir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<Boolean> s = new Sample<>();
        Sample<Double> k = new Sample<>();

        s.foo(true);
        s.bar(false);

        k.foo(3.4);
        k.bar(4.5);
    }
}

class Sample<T> implements IX<T>, IY<T> {
    public void foo(T t)
    {
        System.out.println("foo:");
        System.out.println(t);
    }

    public void bar(T t)
    {
        System.out.println("bar:");
        System.out.println(t);
    }
}

interface IX<T> {
    void foo(T t);
}

interface IY<T> {
    void bar(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Bir sınıf generic bir arayüzün birden fazla açılımını destekleyemez. Çünkü arakodda tüm açılıma ilişkin türler
	Object olarak ele alınır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{

	}
}

class Sample implements IX<Integer>, IX<String> { //error
	public void foo(String t)
	{

	}

	public void foo(Integer t)
	{

	}
}

interface IX<T> {
	void foo(T t);
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnek geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
	public static void main(String [] args)
	{

	}
}

class Sample<T> implements IX<Integer>, IY<String> { //error
	public void foo(String t)
	{

	}

	public void foo(Integer t)
	{

	}
}

interface IX<T> {
	void foo(T t);
}

interface IY<T> {
	void foo(T t);
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic parametrelere kısıt (constraint) verilebilir. Bu işlem için extends anahtar sözcüğü
	kullanılır. Aşağıdaki örnekte Mample sınıfı IX arayüzünü destekleyen bir tür ile açılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Mample<Sample> m;
        Mample<Integer> m1; //error

    }
}

class Mample<T extends IX> {
    public void bar(T t)
    {
        t.foo();
    }
}

class Sample implements IX {
    public void foo()
    {
        System.out.println("Sample.foo");
    }
}

interface IX {
    void foo();
}

/*----------------------------------------------------------------------------------------------------------------------
	int türden bir dizi referansı Integer türden bir dizi referansına atanamaz. Aslında sarmalayan sınıf türünden
	dizi ile sarmaladığı sınıf türünden dizi referansları arasında dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<Integer> s = new Sample<>();
        int [] a = {1, 2, 4};

        s.display(a); //error
    }
}

class Sample<T> {
    public void display(T [] a)
    {
        for (T t : a)
            System.out.println(t);
    }
}
/*----------------------------------------------------------------------------------------------------------------------
	Generic parametreler temel türler olarak belirlenemeyeceğinden aşağıdaki örnekte int türden dizi için
	ayrı bir sınıf yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<String> s = new Sample<>();
        String [] names = {"ali", "veli", "selami"};

        s.display(names);

        int [] a = {1, 2, 3, 4};
        IntSample k = new IntSample();

        k.display(a);
    }
}

class IntSample {
    public void display(int [] a)
    {
        for (int val : a)
            System.out.println(val);
    }
}
class Sample<T> {
    public void display(T [] a)
    {
        for (T t : a)
            System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic parametreler temel türler olarak belirlenemeyeceğinden aşağıdaki örnekte int türden dizi için
    ayrı bir metot yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<Integer> s = new Sample<>();
        int [] a = {1, 2, 4};

        s.display(a);
    }
}

class Sample<T> {
    public void display(int [] a)
    {
        for (int val : a)
            System.out.println(val);
    }

    public void display(T [] a)
    {
        for (T t : a)
            System.out.println(t);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıfın türemiş sınıf açılımı aynı generic sınıfın taban sınıf açılımına
    doğrudan atanamaz (invariant)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
	public static void main(String [] args)
	{
		ArrayList<Integer> list = new ArrayList<>();

		for (int i = 0; i < 10; ++i)
			list.add(i * 10);

		Sample.display(list); //error
	}
}

class Sample {
	public static void display(ArrayList<Number> list)
	{
		for (Number n : list)
			System.out.println(n);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic bir sınıfın türemiş sınıf açılımı aynı generic sınıfın taban sınıf açılımına
    tür dönüştürme operatörü ile de yapılamaz atanamaz (invariant)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Integer> list = new ArrayList<>();

        for (int i = 0; i < 10; ++i)
            list.add(i * 10);

        Sample.display((ArrayList<Number>)list); //error
    }
}

class Sample {
    public static void display(ArrayList<Number> list)
    {
        for (Number n : list)
            System.out.println(n);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki durum ? extends ile aşağıdaki gibi çözülebilir (covariant)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
	public static void main(String [] args)
	{
		ArrayList<Integer> list = new ArrayList<>();

		for (int i = 0; i < 10; ++i)
			list.add(i * 10);

		Sample.display(list);
	}
}

class Sample {
	public static void display(ArrayList<? extends Number> list)
	{
		for (Number n : list)
			System.out.println(n);
	}
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıda generic açılım contravariant duruma getirilmiştir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Number> list = new ArrayList<>();

        Sample.foo(list);

        ArrayList<Object> listObjects = new ArrayList<>();

        Sample.foo(listObjects);
    }
}

class Sample {
    public static void foo(ArrayList<? super Integer> list)
    {
        //...
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte ? işereti açılımı kullanılmıştır. Bu herhangi bir tür demektir. Ancak Object gibi
	düşünülmemelidir. Bu durumun kullanımı uygulama kursunda ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        A<?> a;

        a = new A<>();

        a.foo("ankara"); //error
        a.bar();

    }
}

class A<T> {
    public void bar()
    {

    }

    public void foo(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic metotlar ve çağrılması. Generic metotlar çağrı sırasında eğer tür tespit edilebiliyorsa (type deduction)
	açılım yapmadan da kod yazılabilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample s = new Sample();

        s.<String>foo("ankara");
        s.foo("ankara");

        s.foo(10);
    }
}

class Sample {
    public <T> void foo(T t)
    {
        System.out.println(t);
    }
}


/*----------------------------------------------------------------------------------------------------------------------
   Aşağıdaki iki çağırmada da String parametreli foo çağrılır. Dikkat tür belirtilse bile String paramatreli metot
   çağrılır
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara");
        Sample.<String>foo("ankara");
    }
}

class Sample {
    public static void foo(String s)
    {
        System.out.println("foo(String)");
    }

    public static <T> void foo(T t)
    {
        System.out.println("foo(T)");
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic arayüzler
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        AddOperation addOperation = new AddOperation();

        System.out.println(addOperation.doOperation(10, 20));
    }
}

class AddOperation implements IOperation<Integer> {
    public Integer doOperation(Integer i1, Integer i2)
    {
        return i1 + i2;
    }
}

interface IOperation<T> {
    T doOperation(T t1, T t2);
}


/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotları içerisinde sınıfların generic parametreleri kullanılamaz.
	Bu durumda static metotların da generic yapılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara");
        Sample.foo(2.3);

    }
}

class Sample<T> {
    public static <K> void foo(K k)
    {
        System.out.println(k);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotları içerisinde sınıfların generic parametreleri kullanılamaz.
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara");
        Sample.foo(2.3);

    }
}

class Sample<T> {
    public static void foo(T t) //error
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotları içerisinde sınıfların generic parametreleri kullanılamaz.
	Bu durumda static metotların da generic yapılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara");
        Sample.foo(2.3);

        Sample<String> s = new Sample<>();

        s.bar("ankara");
    }
}

class Sample<T> {
    public void bar(T t)
    {
        System.out.println(t);
    }

    public static <K> void foo(K k)
    {
        System.out.println(k);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotları içerisinde sınıfların generic parametreleri kullanılamaz.
	Bu durumda static metotların da generic yapılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara");
        Sample.foo(2.3);

        Sample<String> s = new Sample<>();

        s.bar("ankara");
    }
}

class Sample<T> {
    public void bar(T t)
    {
        System.out.println(t);
    }

    public static <T> void foo(T t)
    {
        System.out.println(t);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotları içerisinde sınıfların generic parametreleri kullanılamaz.
	Bu durumda static metotların da generic yapılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara", true);
        Sample.foo(2.3, 's');
    }
}

class Sample<T, K> {
    public static <T, K> void foo(T t, K k)
    {
        System.out.println(t);
        System.out.println(k);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Generic sınıfların static metotları içerisinde sınıfların generic parametreleri kullanılamaz.
	Bu durumda static metotların da generic yapılması gerekir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample.foo("ankara", true);
        Sample.foo(2.3, 's');
    }
}

class Sample<T, K> {
    public static <T, K> T foo(T t, K k)
    {
        System.out.println(t);
        System.out.println(k);

        return t;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekte non-static bir metot da generic yapılmıştır (member generic)
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {
        Sample<Integer, Float> s;

        s = new Sample<>();

        s.foo(10, 3.4F, "ankara", true);
    }
}

class Sample<T, K> {
    public <L, M> T foo(T t, K k, L l, M m)
    {
        System.out.println(t);
        System.out.println(k);
        System.out.println(l);
        System.out.println(m);

        return t;
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Pair sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Pair;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Pair<Integer, String>> cities = new ArrayList<>();

        cities.add(new Pair<>(34, "istanbul"));
        cities.add(new Pair<>(6, "ankara"));
        cities.add(new Pair<>(35, "izmir"));

        for (Pair<Integer, String> city : cities)
            System.out.println(city);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Pair sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Pair;

import java.util.ArrayList;

import static org.csystem.util.Pair.create;

class App {
    public static void main(String [] args)
    {
        ArrayList<Pair<Integer, String>> cities = new ArrayList<>();

        cities.add(create(34, "istanbul"));
        cities.add(create(6, "ankara"));
        cities.add(create(35, "izmir"));

        for (Pair<Integer, String> city : cities)
            System.out.println(city);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Pair sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Pair;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Pair<Integer, String>> cities = new ArrayList<>();

        cities.add(Pair.create(34, "istanbul"));
        cities.add(Pair.create(6, "ankara"));
        cities.add(Pair.create(35, "izmir"));

        for (Pair<Integer, String> city : cities)
            System.out.println(city);
    }
}

package org.csystem.util;

public final class Pair<F, S> {
    private final F m_first;
    private final S m_second;

    public static <F, S> Pair<F, S> create(F first, S second)
    {
        return new Pair<>(first, second);
    }

    public Pair(F first, S second)
    {
        m_first = first;
        m_second = second;
    }

    public F getFirst()
    {
        return m_first;
    }

    public S getSecond()
    {
        return m_second;
    }

    public String toString()
    {
        return String.format("{First=%s, Second=%s}", m_first, m_second);
    }
}



/*----------------------------------------------------------------------------------------------------------------------
	Triple sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.util.Triple;

import java.util.ArrayList;

class App {
    public static void main(String [] args)
    {
        ArrayList<Triple<Integer, Integer, String>> cities = new ArrayList<>();

        cities.add(Triple.create(34, 212, "İstanbul Avr."));
        cities.add(Triple.create(34, 216, "İstanbul And."));
        cities.add(Triple.create(35, 232, "İzmir"));

        for (Triple<Integer, Integer, String> city : cities)
            System.out.println(city);
    }
}

package org.csystem.util;

public final class Triple<F, S, T> {
    private final F m_first;
    private final S m_second;
    private final T m_third;

    public static <F, S, T> Triple<F, S, T> create(F first, S second, T third)
    {
        return new Triple<>(first, second, third);
    }

    public Triple(F first, S second, T third)
    {
        m_first = first;
        m_second = second;
        m_third = third;
    }

    public F getFirst()
    {
        return m_first;
    }

    public S getSecond()
    {
        return m_second;
    }

    public T getThird()
    {
        return m_third;
    }

    public String toString()
    {
        return String.format("{First=%s, Second=%s, Third=%s}", m_first, m_second, m_third);
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Java' da generic dizi doğrudan yaratılamaz
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample<T> {
    private T [] m_t;

    public Sample(int n)
    {
        m_t = new T[n]; //error
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki problem aşağıdaki gibi yapılarak çözülebilir
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

class App {
    public static void main(String [] args)
    {

    }
}

class Sample<T> {
    private T [] m_t;

    public Sample(int n)
    {
        m_t = (T[])new Object[n]; //Uyarı önemsiz. Şimdilik görmeyin
    }
}

/*----------------------------------------------------------------------------------------------------------------------
	CSDArrayList generic sınıfı ve test kodu
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.app;

import org.csystem.collection.CSDArrayList;

class App {
    public static void main(String [] args)
    {
        CSDArrayList<Integer> numbers = new CSDArrayList<>();

        for (int i = 0; i < 10; ++i)
            numbers.add(i * 10);

        for (int i = 0; i < numbers.size(); ++i) {
            int val = numbers.get(i);

            System.out.println(val * val);
        }
    }
}
/*----------------------------------------------------------------------------------------------------------------------
    CSDArrayList sınıfı
----------------------------------------------------------------------------------------------------------------------*/
package org.csystem.collection;

public class CSDArrayList<T> {
    private static final int DEFAULT_CAPACITY = 10;
    private T [] m_elems;
    private int m_index;

    private static void checkForIllegalArgumentException(int capacity)
    {
        if (capacity < 0)
            throw new IllegalArgumentException("Capactiy value can not be negative");
    }

    private static void checkForIndexOutOfBounds(int index, int end)
    {
        if (index < 0 || index >= end)
            throw new IndexOutOfBoundsException("Index out of bounds");
    }

    private void allocateCapacity(int capacity)
    {
        T [] temp = (T[])new Object[capacity];

        for (int i = 0; i < m_index; ++i)
            temp[i] = m_elems[i];

        m_elems = temp;
    }

    private void checkAndAllocCapacity(int capacity)
    {
        if (m_index < m_elems.length)
            return;

        this.allocateCapacity(capacity);
    }

    public CSDArrayList()
    {
        this(DEFAULT_CAPACITY);
    }

    public CSDArrayList(int initialCapacity)
    {
        checkForIllegalArgumentException(initialCapacity);
        m_elems = (T[])new Object[initialCapacity];
    }

    public boolean add(T elem)
    {
        this.checkAndAllocCapacity(m_elems.length * 2);
        m_elems[m_index++] = elem;

        return true;
    }

    public void add(int index, T elem)
    {
        checkForIndexOutOfBounds(index, m_index + 1); // add size verildiğinde sona ekler
        this.checkAndAllocCapacity(m_elems.length * 2);

        //TODO:
    }

    public int capacity() {return m_elems.length;}

    public void clear()
    {
        for (int i = 0; i < m_index; ++i)
            m_elems[i] = null;

        m_index = 0;
    }

    public T get(int index)
    {
        checkForIndexOutOfBounds(index, m_index);

        return m_elems[index];
    }

    public T set(int index, T elem)
    {
        checkForIndexOutOfBounds(index, m_index);
        T old = m_elems[index];

        m_elems[index] = elem;

        return old;
    }

    public T remove(int index)
    {
        checkForIndexOutOfBounds(index, m_index);
        T old = m_elems[index];

        //TODO:
        return old;
    }
    public int size() {return m_index;}

    public void trimToSize()
    {
        if (m_index == m_elems.length)
            return;

        this.allocateCapacity(m_index == 0 ? DEFAULT_CAPACITY : m_index);
    }
}



/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

