----------------------- 18 Ocak 2020 -----------

- Temel türler(predifined, primitive, built-in türler)
- Temel türler herhangi bir progralama dilindeki bir kütüphane eklenmeden kullanabilen türlerdir.

 	- Java da bütün tam sayı türleri işaretli olarak tutulur

 	- short				2 byte
 	- int				4 byte
 	- long				8 byte
 	- byte				1 byte [-128 ,127]; 1000 0000(-128), 0111 1111(127)

 - Bu sistemlerde sıfır pozitif sayı olarak görülür.
 - Java'da C, C++'da ki gibi işletim sistemlerine göre türlerin byte'ları değişmez.
   Bütün işletim sistemleri için aynıdır.

   	- float 			4 byte
   	- double			8 byte

- tam sayı türleri için default tür olarak int kullanılmalıdır.
  Aynı şey gerçek sayı türleri double türüdür.


 	- char				2 byte
 	  boolean			standartlarda belirtilmemiştir.

----------------------- 19 Ocak 2020 -----------------

- Java da değişken bildirimi üç şekilde yapılabilir.
	1. Yerel değişkenler		(local variables)
	2. Paremetre değişkenleri	(Parameter variables
	3. Sınıf veri elemanları	( class member variables )

- Java da istenildiği kadar iç içe bloklar olabilir.
- Java da metot içerisinde bir bloğun herhangi bir yerde bildirilen değişkenlere
  yerel değişkenler denir.

- scope : bir değişen isminin derleyici tarafından görülebildiği alana denir.
- yerel değişkenlerin ilk değer verilmediği halde, herhangi bir değer ile hayata gelmez.
- iki yerel değişkenlerin isimleri aynı ise faaliyet alanlarının çalışması durumunda error oluşur.
  Faaliyet alanları birbirini kapsar durumda ise de bu errordur.

- Java da C'de ki gibi name lookup'dan kaynaklı isim saklanması olayı yoktur. Birbirini kapsayan
  bloklarda böyle bir name lookup işlemi yapılmaksızın program hata verecektir.

- Java'da içine değer atılmamış bir değişken kullanılamaz. Yerel değişkenlere değer atanması programcının
  sorumluluğundadır. Yerel değişkenlere otomatik olarak değer atanmaz.

- Java Değişken isimleri lower-upper case sensitiv olarak değerlenir.
	int val, Val, VAL, vAl; // hepsi geçerli

- Klavyeden int isteme kalıbı
	java.util.Scanner kb = new java.util.Scanner(System.in);
	int a = Integer.parseInt(kb.nextLine());
- Klavyeden double isteme kalıbı
	java.util.Scanner kb = new java.util.Scanner(System.in);
	double a = Double.parseDouble(kb.nextLine());
- Değişken isimleri doğrudan anahtar smzcüklerden oluşamaz. Ancak bunun istisnaları vardır.(var anahtar sözcüğü)

- değişken isimleri camelcase kuralına, Sınıf isimleri Pascal(Baş harfi büyük) kuralına göre yazılır. Paket
  isimlerinin hepsi küçük yazılır.

- V&V(Verification//Kodun doğru çalışması&Validation//Kodun doğru işi yapması)

- fonksiyonlarda return ifadesi geçici bir nesne oluşturulup fonksiyon çağrısının kullanıldığı yere koyulur.


- Cast işlemleri, dönüşümler(conversions)

- derleyici eğer ki tür dönüşümü durumunda bir değer kaybı söz konusu değilse dönüşümü otomatik olarak gerçekleştirir.
  Değer kaybının söz olduğu döünşümler otomatik olarak yapılmaz. Kullanıcı tarafından yapımı zorunludur.

- Küçük tam sayı türünden büyük tam sayı türüne doğrudan atama(implicit assignment) geçerlidir.
  implicit dönüştürme operatörü olmaksızın dönüştürmeişleminin yapılması anlamında gelir.(kesin dönüşüm)

- küçük tam sayı türünden büyüğe yapılan atama negatif bir değerde yapılıyor ise geriye kalan bitler bir ile beslenir.
  Eğer sayı pozitif ise bit'ler 0 ile beslenir.
- char türünden short'a short' türünden de char doğrudan atama geçersizdir.

- byte türden ve short türünden nesnelere sabit sayılar ile kendi sınırları içerisinde kalmak şartı ile
  yani byte için en fazla 1 byte'lık short içinde en fazla iki byte'lık sınır içerisinde yazma koşulu ile
  sabit sayı atanabilir.
   byte = 128;// error

- Sınırlar içerisinde kalmak koşulu ile int türden bir sabit char türüne doğrudan atanabilir

- float türünden double türüne doğrudan atama vardır.

- bool türünden hiç bir türüne ve hiç bir türden de bool türüne atama yada dönüşüm(cast) yapılamaz.

- hiç bir türden byte türüne doğrudan atama yapılamaz(2 byte sınırlar içerisindeki int değerleri hariç).
- char türünden short türüne, ve short türünden char türüne doğrudan atama geçersizdir.
    (Nedeni char türde negatif değişkenlerin olmamasından kaynaklıdır.)
***************************************************************
***************************************************************
***************************************************************
	byte 	-> short, int, long, float, double
 	short 	-> int, long, float, double
 	int 	-> long, float double
 	long 	-> float, double
 	char 	-> int, long, float, double
 	float 	-> double
***************************************************************
***************************************************************
***************************************************************

- java da bir değişkenin kullanılabilirlik alanı

	do {
	int val = 0;
	}while(val == 0)// errordur val değişkeni do'ya ait küme parentezinde tanımlıdır.

- geri dönüş değerlerinde sabit değerler(int) sınırlar içerisindeyse otomatikman short,byte ve char türler için
  geçerlidir.
- sabit tam sayı(10,20,35 gibi) değerleri fonksiyon çağrı konumunda char, short ve byte'a otomatik olarak dönüşmez.


- int türü ve altındaki değerler kendi aralarında aritmetik işleme sokuldaklarında integral promotion'a tabi olurlar.

- boolean türü hiç bir tür ile işleme sokulamaz.
- boolean türünden herhangi bir türe ve herhangi bir türden boolean türüne dönüşüm yapılamaz.

- Büyük tamsayı türünden küçük tamsayı türüne yapılan bilinçli dönüşümde büyük
	tamsayı türüne ilişkin değer küçük tamsayının sınırlar içerisinde bilgi kaybı
	oluşmaz. Aslında bu dönüşüm yüksek anlamlı byte değerlerinin atılması ile
	gerçekleşir. Yani örneğin long türünden int türüne dönüşümde long türüne
	ilişkin değerin yüksek anlamlı 4 byte lık kısmı atılır. Geri kalan 4 byte
	int türüne atanır. Bu durumda kaynak türün içeriisndeki değer hedef
	türün sınırları içerisinde kalıyorsa bu değerin yüksek anlamlı atılacak
	byteların değerleri sıfırdır. Bu durumda kaynak türün içeriisndeki değer
	hedef türün sınırları dışındaysa bilgi kaybı olur

- byte türünden char türüne explicit dönüşüm

- String sınıfının format(static public) methodu printf interface'i ile bir yazıyı
  alıp bize String döndürür.

- String sınıfının valueOf sınıfları verilen değişkenleri String'e dönüştürür.

- int bir değeri String değerine dönüştürmek
	1- val + ""//boş string
	2- String.valueOf(val);// Her biri
	3- String.format("%d",val);//

- Bir sayıyı yazıya çevirmek için
  - parseInt,parseDouble method'ları;//çeviri başarısız ise Exceptiın gönderir.

- Wrapper sınıflar
	Integer,Double, Long,Float gibi sınıflardır.


- immutable sınıf, sınıf türünden nesne yaratıldığında nesnenin içeriği değiştirilemediği sınıflardır.

- String sınıfı bir immutable sınıftır.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                        26.01.2020
///////////////////////////////////////////////////////////////////////////////////////////////////
- javac her sınıf(aynı yada farklı paketlerde olması farketmeksizin) için .class uzantılı dosya(byte code) üretir.


- Bir sınıf herhangi bir pakette olabilir. Bir proje içerisinde kullanılan sınıfların aynı pakette
  olma zorunluluğu yoktur
- .class dosyaları mutlaka
- Bir paket içerisinde bildirilen bir sınıfın farklı bir paketten kullanılabilmesi için
  public olarak bildirilmesi gerekir. public olarak bildirilmeyen bir sınıf ancak
  aynı paketteki diğer sınıflar tarafından kullanılabilir (friendly, internal//bunlar public yazmamanın anlamıdır. Anahtör sözcük değillerdir.)

- Farklı paketlerdeki sınıflar için byte kodların da uygun yerde olması gerekir. Uygulamanın çalışmaya
  başlatıldığı dizin tüm paketlerin olması gereken dizindir(java csd.App). Ancak bu durumun istisnaları olabilir(Source folder : aynı pakette olup farklı directory'lerde
  .class dosyaları kullanabilirsin.)

- Bir paket içerisinde aynı isimde birden fazla sınıf bildirimi yapılamaz. Farklı paketler
  içerisinde aynı isimde sınıflar olabilir. Farklı paketler içinde aynı isimde class'lar kullanılabilir.

- Bir .java dosyası içerisindeki sınıflar o java dosyasının başında bildirilen paket içerisinde
  	 olurlar.

- Bir .java dosyasında farklı paket bildirimleri yapılamaz

- Hiç bir paket bildirimi olmayan .java dosyalarında bildirilen sınıflar isimsiz paket
  (unnamed package) denilen bir paket içerisinde kabul edilir.
  Ancak projelerde isimsiz paket içerisinde sınıf bildirimi yapılmamalıdır.

- Bir paket içerisinde alt paketler olabilir. Alt paketler
  package <paket ismi>.<alt paket ismi>;

  biçiminde bildirilir. Alt paketlerde bulunan sınıfların .class dosyaları (byte code) paket
  hiyararşisine uygun alt dizinlerde bulunmalıdır.

- Paketler içiçe bile olsa farklı paketlerdir. Yani örneğin org.csystem.util paketi içerisinde
  ArrayUtil sınıfı varsa org.csystem paketi içerisinde de ArrayUtil sınıfı olabilir.
  Bu isimler kesinlikle çakışmaz.

- Paket isimleri genelde firmaya ilişkin tekil bir bilgi olan domain isimleri ile
  belirlenir. Örneğin CSD firmasının paketleri ve sınıfları domain adresi "csystem.org"
  olduğundan "org.csystem" paketi altında yazılabilir(spring framework'ünde her şey org.spring ile başlar)

 - Domain isminin altında da paketler olur.(Örneğin org.spring.util)
- android'in bütün paketleri android ile başlar.

- Bundan sonraki uygulamalarda org.csystem şeklinde başlatılacaktır.

- java nın standart tüm paketleri ve sınıfları java isimli bir paket altında toplanmıştır

- java.lang isimli paket altında bulunan tüm sınıflar her yerden görülebilirdir. Yani
  buradaki isimleri paket ismi ile kombine etmeye gerek yoktur (import deyimi kullanılmadan da
  olmadan da  kullanılabilir, Örneğin String sınıfı java.lang package'i altında tanımlanmıştır.)

- Bu sadece java.lang'a özgüdür.

///////////////////////////////////////////////////////////////////////////////////////////////////                                 İsim arama kuralları
///////////////////////////////////////////////////////////////////////////////////////////////////- bir isim doğrudan kullanılmış ise veya . operatörünün solunda kalıyor ise niteliksiz(unqualified) olarak aranır.
 	Sample s =  new Sample();//Sample niteliksiz aranır
 	s.foo(); // burada s niteliksiz foo nitelikli aranır.
 	Sample.bar() // Sample niteliksiz bar fonksiyonu nitelikli aranır(qualified).


- Niteliksiz isim arama(name lookup) kuralları(eğer kurallardan biri gerçekleşirse diğerine bakılmaz)
	1-) Bir metot içerisinde kullanılan bir isim kullanıldığı yerden yukarıya doğru metot içerisinde
	    ve metot'un parametre parantezinde aranır.(Bu kuralın ayrıntıları vardır.(this keyword))
	2-) Metot'un ait olduğu sınıfın içerisinde tüm metotların dışında her yer de aranır. Bulanamazsa taban
	    sınıflarına(super class) da sırasıyla bakılır.
	3-) O sınıfın ait olduğu pakete bakar.Kapsayan, kapsanan paketlere bakılmaz. Bulamazsa error'dur.
		Bu yüzden isimsiz paketlere erişim yoktur. sub package'ları niteliksiz olarak görülemez.

- Aynı Faaliyet alanı içerisinde YEREL değişkenler aynı isimde iki kez tanımlanamaz.
  Bu durum Sınıf'ların member'ları için geçerli değildir.(aynı isimde tanınınabilirler)

- İsim arama kuralların- .class dosyaları mutlakada ilk olarak isim arama yapılır. Uygun kullanıp kullanılamadığına bakılır.

- Nitelikli isim arama() kuralları
	1-) Aranan ismin solunda sınıf ismi var ise, isim sınıf içerisinde aranır bulunamaz ise taban sınıflar içerisine bakılır.
	2-) Aranan ismin solunda referans ismi var ise, isim referansa ilişkin sınıf içerisinde bulunamazsa taban sınıflara bakılır.
	3-) Aranan ismin solunda paket ismi var ise, isim o paket içerisinde aranır bulunamaz ise error oluşur.

- Paket isimleri hiyerarşik bir aramaya tabi değildir. sub package'lar niteliksiz olarak aranamaz. Mutlaka base package'lar
  belirtilmek zorundadır. Niteliksiz arama da  paket isimlerine bakılmaz.
///////////////////////////////////////////////////////////////////////////////////////7
                         import deyimi
///////////////////////////////////////////////////////////////////////////////////////7
- import deyimi iki şekilde kullanılır.
	1- yıldızlı import (import on demand)
	2- yıldızsız import (import type declaration)

- yıldızlı import (import on demand) genel biçimi
	import <paket_ismi>.*;

- import deyimleri .java dosyasında paket bildiriminin altında tür bildirimlerinin üstünde bulunmalıdır.
- import deyimi niteliksiz isim arama da bir isim  çalışılan paket içerisinde bulunamazsa bakılacak paketi de aramaya dahil eder.
  (import java.util.*;//java.util paketinide bak)

- import deyimi niteliksiz isim araması için geçerlidir. Nitelikli isim arama kuralları için hiç bir önemi yoktur.
- import deyimlerinin sırasının hiç bir önemi yoktur.
- import deyimleri paket bildiriminin altında sınıf bildiriminin üstünde olmalıdır.

- Her paket(sub paket'ler buna dahil) birbirinden ayrıdır.

- *'lı import deyiminde eğer niteliksiz arama en son bulunamazsa import deyimine ilişkin paket'te aranır.

- *'sız importta eğer aynı java dosyasında aynı sınıftan bir tane var ve aynı sınıf import deyimi eklenmek isterse
  import declaration'ı hatadır.

- *'lı arama da önce bulunduğu yere sonra dosyaya sonra bulunduğu paket'e pakette de bulunamaz ise import deyimlerine bakar.
- *'sız arama da ise önce bulunduğu dosyaya sonrasında import deyimlerine bulunamaz ise aynı paketin içinde aranır.

- import static directive(deyimi)'i
	import static single type declaration(yıldızsız)
	import static on demand statement (yıldızlı)
- Bu deyimler bir sınıfın static elemanlarının başka bir paket içerisinde
  niteliksiz olarak kullanımını sağlar.

- import static on demand statement(yıldızlı)'ın genel biçimi
  import static [paket ismi].<sınıf ismi>.*;

  import static org.csystem.util.NumberUtil.*;
	public static void main()
	{
		factorial(10);
	}
- import static on demand statement(yıldızsız)'ın genel biçimi
  import static [paket ismi].<sınıf ismi>.<static elemanın ismi>;

  import static org.csystem.util.NumberUtil.factorial;
	public static void main()
	{
		factorial(10);
	}

///////////////////////////////////////////////////////////////////////////////////////////////////
                                     22.02.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
                            foreach(range based for loop)
///////////////////////////////////////////////////////////////////////////////////////////////////
- for (int i = 0; i  < a.length; ++i) {
        int val = a[i];
  }
  for (int val : a) // temsili karşılığı

- döngü değişkeni döngü scope'u boyunca geçerlidir. sonrasında kullanılamaz.

-  forecah'de : noktadan sonraki kısım sSınıf elamanlarının erişim belirleyicileri(access modifiers)adece bir kez yapılır.

- döngü değişkeni ile dolaşabilen türe ilişkin her elemanın atanabileceği türde olması gerekir.

- burada val'e atama yapmak dizi de ki gerçek değeri değiştirmez.

- foreach döngü deyiminde indeks gerektiren bir işlem yazılmamalıdır.
- diziyi tersten dolaşılması gereken durumlarda yapılır.

- for_each döngü deyimi eğer dizi baştan sona dolaşılacak ise kullanılmalıdır.

- Eğer indeks 0'dan değilde başka bir indeksten başlarsa, yada 0'dan başlayıp sonuncu hariç herhangi
  bir indekste bitmesi durumunda kullamılması durumunda kullanılmamalıdır.

- String sınıfı iterable değildir.
    for (char ch : s) // error'dur.
///////////////////////////////////////////////////////////////////////////////////////////////////
                            Sınıf elamanlarının erişim belirleyicileri(access modifiers)
///////////////////////////////////////////////////////////////////////////////////////////////////
-   sınıfın kendisinin erişim belirleyicisi eğer yazılıcak ise public'tir.

- sınıf elemanlarının erişim belirleyicileri
    - public, protected, no-modifier, private

- Java dışındaki dillerde no-modifier ile java da ki farkı çok farklıdır.

- protected ve no-modifier elemanları public ve private'a göre açılır.
- public ve private bir elemanın başka bir sınıf içerisinden erişilip erişilemeyeceği anlamına gelir.

- Sınıfın public bölümümne sınıf dışından aynı pakette yada paketlerde de erişilebilir.
- sınıfın private bölümüne sınıf dışından erişim geçersizdir.

- sınıfın no-modifier bölümü aynı paketteki diğer sınıflar için public'tir.
  Farklı paketteki sınıflar için  ise private etkisinde olacaktır.

- Sınıfın protected bölümü aynı paketteki diğer sınıflar için public'tir.

- Sınıfın protected bölümü türetme söz konusu değil ise farklı paketteki sınıflar için private anlamındadır.

-  Erişim Belirleyici   Kendi      Aynı paketteki sınıflar         Farklı paketteki sınıflar       Türemiş sınıf
   public               +          +                               +                               +
   protected            +          +                               -                               +
   no-modifier          +          +                               -                               -
   private              +          -                               -                               -

///////////////////////////////////////////////////////////////////////////////////////////////////
                                         23.02.2020
///////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////
             Sınıfların elemanlarının gizlenmesi(encapsulation, data hiding)
///////////////////////////////////////////////////////////////////////////////////////////////////

    - Sınıfları yazarken dışarıya vermek istemediğimiz veri elemanlarını private yada uygun erişim belirleyicisini
      kullanarak dışarıya detayların yansıtılmasını engellemek sağlanır.

    - Sınıfların dışarıya yansıtılan(public olan kısımları) sadece dökümente edilir.

- Bir veriyi gizlemek için pratikte aşağıdaki dört  koşuldan birinin  gerçekleşmesi gerekir.(Sıra önemli değildir.)
    1-) Sınıf tasarımının ilerleyen versiyonlarında veri elemanlarının isimlerinin hatta türlerinin değişimesi durumuna
        çok sık rastlanır. Eski kodların client'in kodunun etkilenmemesi için veri gizlenmelidir.

    2-) Bir veri elemanının sınır değerleri olabilir(Öğrencinin isminin boş geçilmesi). Bu sınır değerlerinin
        dışında değerlerin verilmemesi için veri gizlenmelidir.

    3-) Bir veri elemanı değiştiğinde başka bir veri elemanının değeri hesaplanması gerekiyor olabilir.(Örneğin üçgenin
        bir kenarının değişmesi sonucu,alanının değişmesi) Bu durumda veri gizlenmelidir.

    4-) Bir veri elemanı değiştiğinde sınıfın o değere göre başka bir iş yapması gerekiyor  olabilir.
        (Örneğin Date sınıfının, gün değerini tutan değişkenin değiştirilmesi sonucu sınıfın doğru bir tarih mi kontrolü yapması)

    Bu durumların dışında (% 3 - 5 arası) elemanlar public yapılabilir.


- Gizlenmiş bir veri elemanına erişmek için kullanılan methot'lara accessors metotlar denir.
    - Gizlenmiş veri elemanlarının değerlerine erişmik için kullanılan methodlara getter
    - Gizlenmiş veri elemanlarının değerlerini değiştirmek için kullanılan methodlara setter denir.

    - Sınıfların get Metotları genel olarak get ile başlatılır. Bazı ortamlar(framework) bunu default
      olarak isterler. Bu kurala bir sentaks kuralı gibi uymamız gerekir.

    - Sınıfların set metotları genel olarak set ile başlatılır.Bazı ortamlar(framework) bunu def belirlault
      olarak isterler. Bu kurala bir sentaks kuralı gibi uymamız gerekir.

- Sınıfların private veri elemanlarının isimlendirilmesinde bazı önemli kurallar vardır.
  bu elemanlar m_day, mDay ile başlamalıdır.(Kursta m_ şeklinde yazılacaktır.) Burada m member anlamındadır.

- eğer member static ms_day msDay şeklindedir.
    - pascal sistemi isimlendirme (Sınıf isimleri bütün kelimelerin baş harfleri büyük)
    - camel case (ilk kelimenin hepsi küçük, diğer kelixmelerin baş harfleri büyük)
    - unique isimlendirme(tüm harfler küçük kelimelerin arasında _ kullanılır. Genelde java da kullanılmaz.)

- Javada boolean türden private elemanlara getter metotları get ile değil is ile başlar.
  Örneğin private boolean m_married değişkeni için isMarried kullanılır.

- Bir sınıfın default ctor'u haricinde bir ctor yazıldığı zaman default ctor'un yazılıp yazılamayacağına
  o an karar verip duruma göre yazmalıyız. Derleyici tarafından default ctor yazılmaz.


///////////////////////////////////////////////////////////////////////////////////////////////////
                                        29.02.2020
///////////////////////////////////////////////////////////////////////////////////////////////////


- ctor private olabilir.
- Nesne yaratılmasının anlamının olmayacağı sınıflarda ctor'un private olmalıdır.(ArrayUtil sınıfı örnektir.)
  (Array Util, Array Util gibi sınıflara mantıksal static sınıflar denir.)
  Array Util sınıfının herhangi bir non-static veri  elamanı olmayacağı için bir anlamı olmaz.

- NumberUtil sınıfı ve StringUtil sınıfının ctor'uda  private yapılmalıdır.
- Standart kütüphanenin Math sınıfının ctor private'dır.

- String sınıfının default ctor'u public idir ve çok gereksiz bir durumdur. Her seferinde yeni bir nesne oluşturulur.
  Çift tırnak ise bundan çok daha efektif bir kod olur.
  String s = new String(); // bad code
  String s = ""; //effective code

- Design Patterns(Gang of Four Patterns)
    - Nesne yaratan patternler (Creational)
    - Yapısal (Structurel)
    - Davranış(Behaivour)

- Singleton design pattern'i bunlardan biridir. // Aşağıdaki kod yapısına lazy implementation'dır.
    class Singleton{
        private static Singleton s;
        private Singleton(){}

        public static Singleton getInstance() {
            if (s == null)
                s = new Singleton();

             return s;
        }
    }

- static elemanlar program sonuna kadar yaşar. Singleton nesnesi program sonuna kadar yaşayacaktır.
  static elemanlar nesnenin herhangi bir elemanı kullanıldığı anda hayata gelirler.
- set methodlarında eğer aynı değer set edilme durumu var ise ortada bunun kontrol edilmesi gerekir.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                      07.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- Eğer başka bir fonksiyonu tekrar ederek çağırmak algoritmamızı büyük ölçüde yavaşlaştıyor ise bu algoritmanın
  kendisi bu fonksiyon çağrılmadan yazılabilir. (Numbertil'in içindeki nextFibonacci ve next metotları böyle yazılmıştır.)

- Bazı durumlarda aynı işlemleri yapan başka bir fonksiyonu çağırmak fonksiyonumuzun karmaşıklığını O(n)'den
  O(n^2)' ye çıkartabilir.
///////////////////////////////////////////////////////////////////////////////////////////////////
                                     Final keywordu
///////////////////////////////////////////////////////////////////////////////////////////////////

- Bir değişken final olarak belirlendiğinde o değişkene faaliyet alanı boyunca bir kez atama yapılabilir.
  Bu atama ilk değer verme ifadesi olmak zorunda değildir. (Klavyeden bir değer girilebilir.)

-final yerel değişkenler
    final double PI= 3.14;
    - final yerel değişkenler java 8 öncesinde bazı durumlarda gerekliydi. Java 8 sonrasında bu ihtiyaç yoktur.

- Method parametresi final olan değişkenler.
    - Not : methodların parametre değişkenleri method başında bildirilmiş yerel değişkenler gibidir.
    - Java 8 öncesinde zorunluluk dışında şu an için hiç bir anlamı yoktur.
    - Bir metotun parametre değişkeni metot çağrısında yaratılır, metot bittiğinde hayata veda eder.

- final member variables
    - final bir veri elemanına default değer atanmaz. Sınıfı yazan kişinin sorumluluğundadır.
      Değer atanmaması durumu error  olur.
    - final bir non-static   veri elemanlarına 3 yerde değer atanabilir.
      1-) Bildirim noktasında // final int a = 5;
      2-) Ctor içerisinde, Bütün ctor'lar için yapılmalıdır
         (Bütün final değişkenlerin hepsine atama yapmak koşulu ile) // 1. koşul yapılmamış ise

      3-) non-static initializer(İleride göreceğiz.)

- Derleyiciler bir değişkeni final  olarak gördüğünde bunları daha çabuk erişilebilecek bir alana(cache yani önbelleğe)
  koyarlar. Hiç değişmeyecek bir elemanı final belirtmeliyiz. (Derleyicinin optimizasyonu için gereklidir.)
  Bir elemanı final yapılması gerekiyor ise yapılmalıdır.

- Sınıfın static final member variable'larına da default değer atanmaz. Progmramcı sorumluluğundadır.
    2 yerde değer atanabilir.
        1-) Bilidirim sırasında
        2-) sTatic initializer(ileride göreceğiz)
///////////////////////////////////////////////////////////////////////////////////////////////////
                                        08.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- Sınıfın statik veri elemanları o sınıf türünden statik bir fonksiyon yada statik bir member'ı kullanıldığı anda
  hayata gelirler.

- Referans türünden bir tür final olarak belirtilmiş ise sınıfın içindeki bilgiyi değiştirebiliriz.
  Değiştiremeyeceğiz şey referanstır. aslında final referanslar her zaman low lewel const'luğa sahiptir diyebiliriz.
    final Sample s = new Sample();
    s = new Sample; // error
    s.setX(5); // ok
    - yani final referansların gösterdiği nesne modify edilebilir.
- Ctor'ın geri dönüş değer kavramının olmamasının nedeni programcının doğrudan ctor'ı çağıramamasıdır. Ancak ve ancak
  new operatörü ile runtime da çağırılır.

- private eleman dışarının kullanılmasını istemediğimiz elemandır.

- immutable sınıflarda elemanı final yapmamız gerekir.

- new operatörü aynı değer ile çağırılan immutable nesneler farklı referanslardır. Böyle durumlarda valueOf
  fonksiyonu kullanılabilir. Referanstan bağımsız yapılacak karşılaştırmalar için ,
  Object sınıfının equals yada sınıfın kendi compareTo metodu kullanılabilir.
    String s = new String("ankara");
    String s1 = new String("ankara");
    System.out.println(s == s1); // false

- factory metodlar ctor'u private olan sınıf türünden nesne döndüren public static metot'lardır. Factory metodlar
  bizden bir değer alıp bu değere göre de nesne yaratabilirler.

- IntValue(BigDecimal sınıfı) tarzı sınıfların çok kullanılan veri elemanları örneğin 1, 0 gibi elemanları final static
  eleman haline dönüştürülür.
  class IntValue {
    public static final IntValue ZERO = of(0);
  }

- final keywordu referans nesneler için her zaman top level constluk sağlar.
    final String s = new String();
    s = new String(); // error
    final String [] strings = {"ahet", "bcd", "efg" };
    strings[i] = "ankara"; //ok
    strings = new String[3];//error

- factory metod'lar 8'den önve valueOf ile yazılırken, 8'den sonra of  şeklinde isimlendirilmiştir.


- ctor'ı private olan bir çok sınıf factory metod'a sahiptir. Buna factory pattern denir.

- final anahtar sözcüğünün dilden dile bir çok farklı kullanım biçimi vardır.  C#' da karşılığı readOnly sözcüğüdür.
    - değişkenlerin final olarak bildirilmesi
    - metotların final bildirilmesi
    - sınıfların final bildirimesi
    - bir kaç yer daha vardır.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                      Enum türü
///////////////////////////////////////////////////////////////////////////////////////////////////
- enum türü neden vardır?
    class App {
        public static void main(String [] args)
        {
            StickyMan stickyMan = new StickyMan();

            stickyMan.move(1); //right
            stickyMan.move(3); //left
            stickyMan.move(4); //bottom
            stickyMan.move(2); //top

        }
    }

    class StickyMan {
        //...
        public void move(int direction)
        {
            //...
        }
    }

-  Yukarıda ki örnekte programcı StickyMan sınıfı için gerekli direction bilgilerini  ait değerleri
   her zaman aklında tutması gerekir. move fonksiyonunun içinde örneğin 1 sağ, 2 top, 3 left, 4 bottom
   değerleri için haraket etmektedir. Programcı bu kütüphaneyi kullanan birisi olarak her zaman bu değerleri bilmesi
   ve ayrıca aklında tutması gerekir.


- Burada move metodunun parametresi int türden değilde String türünden olabilirdi. Kullanıcı böylelikle
  fonksiyon çağrısını aşağıdaki şekilde yapabilir.
      stickyMan.move("right");
      stickyMan.move("lef"); // burada hata olduğunu farkedemeyecektir.
      stickyMan.move("bottom");
      stickyMan.move("top");

- Ancak yukarıda ki fonksiyon String'lerin karşılaştırması olduğu için int'e göre göreceli yavaş bir fonksiyondur.
  Ayrıca String karşılaştırması runtime' da yapıldığı için programcı hata yapıp bunun nedenini farkedemeyebilir(Buradaki
  error programcının isteği şeklinde çalışmaması olacaktır.).


- Programcı sınıfı string gibi kullanabileceği ama karşılaştırmanın da int şeklinde yapılabileceği hale getirmesi gerekir.
  Bunun için de static ve final değişkenler kullanılması gerekir.

- Programcı bu durumda stickyMan sınıfınnı aşağıdaki hala getirebilir.
    class App {
            public static void main(String [] args)
            {
                StickyMan stickyMan = new StickyMan();

                stickyMan.move(Direction.RIGHT;
                stickyMan.move(Direction.LEFT);
                stickyMan.move(Direction.BOTTOM);
                stickyMan.move(Direction.TOP);

            }
        }


        class Direction {
         public static final int RIGHT = 1;
         public static final int TOP = 2;
         public static final int LEFT = 3;
         public static final int  BOTTOM = 4;
        }
        class StickyMan {
            //...
            public void move(int direction)
            {
                //...
            }
        }

- Yukarıdaki kodda ki sıkıntı ise move fonksiyonun parametresinin int türden olması ve herhangi bir
  Bildiriminin olmaması (yani okunabilirlik açısından gene zayıf olması) ayrıca bu fonksiyona sadece Direction sınıfının
  değerlerinin değil başka değerlerinde  atanabiliyor olması ayrıca bir hata içerir.

  class StickyMan {

    public void move(Direction d)
  }

  class Direction {
    private final int m_ordinal;
    private  final Direction [] m_values = {
        new Direction(0),hatta
        new Direction(1),
        new Direction(2),
        new Direction(3),
    };

    private Direction(int ordinal) {
        m_ordinal = ordinal;
    }
    public static final Direction RIGHT = m_values[0];
    public static final Direction TOP = m_values[1];
    public static final Direction LEFT = m_values[2];
    public static final Direction BOTTOM = m_values[3];

    public static Direction [] values(){
        return m_values;
    }
    public int ordinal() {
        return ordinal;
    }
  }
- Enum türü bir sınıf türüdür. Bildirimi enum anahtar sözcüğü ile yapılır.
  (Yukarıdaki sınıf aslında enum türünün çok yakın bir implementasyonudur.Yukarıdaki fonksiyonların  hepsi enum yazılarak yapılabilir.)

- enum türleri ctor'ı private yapılmış ve her bir enum türü için, içinde o sınıf türünden bir nesne tutan
  yapılardır.


- enum içerisinde bildiren isimler enum sabiti olarak adlandırılır.
- Bu isimler public static final ve ilgili enum türündendir.
- Ancak bildirim sırasında bunların yazılması errordur

- enum sınıfının toString metodu ilgili sabitin yazısal karşılığını verir.

- her enum sınıfının ordinal(public non-static) metodu referansı gösterdiği indeksin değerini döndürür.

- her enum türünün values metodu bütün sabitlerin  değerlerini tutan bir diziyi döndürür.

- enum türünden bir nesne yaratılamaz.(new ile yapılamaz.)

- enum  türünden nesne sadece içerideki adet kadar yaratılabilir.

- Singleton nesnesinin en kolay yapılışı
  enum Singleton {
    INSTANCE
  }
///////////////////////////////////////////////////////////////////////////////////////////////////
                                    14.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- final değişkenler switch deyimlerinde case ifadesi olarak  kullanılabilirler. Ancak switch deyimlerinde sınıf
  referansları kullanılamaz.

    Direction d = Direction.RIGHT; // Burada direction enum türünden değil yazdığımız sınıftır.
    switch (d) //error. user defined- reference can not use as a switch expression
    {
        case LEFT: // ok
    }


- Enum türleri switch deyiminde ve case'lerde de kullanılabilir.

    Direction d = Direction.LEFT;
    switch (d) //ok
    {
        case Direction.LEFT: // error
        case LEFT: //Doğru hali budur.Direction.LEFT kullanımı error'dur. Çünk
    }

    enum Direction {
        RIGHT,TOP,LEFT,BOTTOM
    }

- enum türü bir referans türü olduğu  için, aynı türden enumlar == ve != operatörleri ile karşılaştırılabilirler.
    Direction d = Direction.LEFT;

    System.out.println(d == Direction.LEFT); // true
    enum Direction {
        RIGHT,TOP,LEFT,BOTTOM
    }


- enum türleri aynı türden ise aşağıdaki üç şekilde karşılaştırılabilir.
  1-) switch deyimleri,
  2-) if deyimleri içerisinde,
  3-) sınıfın equals fonksiyonu // Bu fonkisiyonda farklı enum türleri karşılaşıtrabilir. == veya !='de bu yapılamaz.


- Enum sınıfının compareTo metodu enumlar arasındaki ordinal'lerin  farkını döndürür.
    enum DayOfWeek {
        SUN, MON, TUE, WED, THU FRI, SAT;
    }

- enum türlerinde en sona eklenen COUNT değeri ile sınıfın uzunluğu, alınabilir.
    enum myClass{
        WEIGHT,POWER,ABILITY, COUNT;
    }

    enum myClass{
            HEIGHT,LENGTH,AGILITY,POWER,ABILITY, COUNT;
    }
    //COUNT'ın ordinal'i myClass'ın uzunluğunu döndürür.

- Her enum türünün valueOf adlı static bir metodu vardır.
- Bu fonksiyona string türünden parametre ile kullanılır.

    Color c = Color.valueOf("GREEN");
    Color c = Color.valueOf("GREE"); //throws Exception

    enum Color {
        REG,GREEN,BLUE;
    }

///////////////////////////////////////////////////////////////////////////////////////////////////
                                    15.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
                                    SINIFLAR ARASI İLİŞKİLER
///////////////////////////////////////////////////////////////////////////////////////////////////

- iki tane sınıf arasında ya hiç ilişki yoktur ya da aşağıdaki dört durumdan yalnızca  biri vardır
    1- composition (İçerme)
    2- aggregation (Birleşme)
    3- Association (Çağrışım)
    4- Inheritance (Türetme, kalıtım)

- İlk üç madde'yi destekleyen doğrudan bir dil desteği yoktur.

- Ama inheritance için bu böyle değildir. İnheritance bir çok dil tarafından  desteklenmektedir.

- Composition, inheritance ve aggregation'da sınıflar ile açıklama yapılırken genellikle A ve B sınıfı kullanılacaktır.
      Composition (A has a B)
      Aggregation (A holds a B)
      Inheritance (B extends A)


- Composition ve Aggregation ilişkisi birbirine çok benzemektedir. Bir sınıfın başka bir sınıfı bütünsel olarak
  kullanmasıdır.

- Association ise bir sınıfı bütünsel olarak kullanmamaktadır.

- İki sınıf arasında ilişki var ise biri olmadan diğeri yazılamaz. Yani bir sınıf olmadan diğer sınıf derlenemiyor
  ise buna bağımlılık denir. (Buna Dependency denir)
  Örneğin araba sınıfının motor sınıfına bağımlı olması gibidir.

-

///////////////////////////////////////////////////////////////////////////////////////////////////
                                        COMPOSITION
///////////////////////////////////////////////////////////////////////////////////////////////////


- Composition ilişkisi --has a-- ilişkisidir.

- A ile B arasında A has a B ilişkisinde aşağıdaki kural geçerlidir.
  Yada aşağıdaki iki kural geçerli ise A ile B arasında composition ilişkisi vardır.
      1-) A nesnesine ait B nesnesi başka bir nesne tarafından kullanılamaz.
          (B nesnesi A'nın içinde private bir veri elemanı olmalıdır.)

      2-) A nesnesine ait B nesnesinin ömrü A ile hemen hemen aynı olacaktır. (ctor'larda yaratılabilir.)

- Bu ilişki bütünsel bir ilişkidir. A nesnesi kendisine ait olan B nesnesini bütünsel olarak kullanılır.
    Sınıfın veri elemanı sınıfın bütün metodlarında kullanabilen veri elemanıdır.

- Composition ilişkisinde A Sınıfı B'ye bağımlıdır. (UML'de gösterimini bulabiliriz.)

- Composition'da has a ilişkisi nicelik bakımından değişiklik gösterir.
  Örneğin Car sınıfının bir adet motoru var iken
          Plane sınıfının motor sayısı birden fazla olabilir.(Bu durumda member elemanı Engine türünden dizi olmalıdır.)
///////////////////////////////////////////////////////////////////////////////////////////////////
                                        AGGREGATION
///////////////////////////////////////////////////////////////////////////////////////////////////

- A ile B arasındaki ilişki de --holds a-- şeklinde kullanılır.
- Composition'da ki kurallardan en az  biri delinebilir ise buna aggregation denir. Bütünsellik gene geçerlidir.

  - Aşağıdaki örnekte iki kuralda delinmiştir.
  class A {
    private B m_b;
    public A(B b)
    {
        m_b = b; // new'i kendi yapmıyor. Dışarıdan var olan bir nesneyi alır.
    }

    public B getB(){ return m_b;}  // B elemanı başka sınıflar tarafından kullanılır.
  }

  class B {
    public void doSometing()
    {

    }

   }
///////////////////////////////////////////////////////////////////////////////////////////////////
                                       ASSOCIATION
///////////////////////////////////////////////////////////////////////////////////////////////////

- A sınıfının B sınıfını ihtiyacı ölçüsünde kullanılması,bütünsel kullanım söz konusu değildir.

- A sınıfının bir fonksiyonunun B sınıfı türünden bir referans parametresini kullanmasıdır.  Yada fonksiyonun içinde
  new ile yaratılıp o fonksiyon boyunca kullanılır.

- String(immutable sınıfların hepsi)  ile yapılan yapısal olarak aggregation gibi görünen işlemler ,
  xaslında aggregation değildir.

- taksi ile sürücü aggregation (Driver'ı dışarıdan alır.)
- taksi ile müşteri ise associationdır.(Sadece bir fonksiyon için kullanılır.)

///////////////////////////////////////////////////////////////////////////////////////////////////
                                        KALITIM
///////////////////////////////////////////////////////////////////////////////////////////////////

- is a ilişkisidir.

- varolan sınıfı kodlarına dokunmadan genişletebilmektir.


///////////////////////////////////////////////////////////////////////////////////////////////////
                                        21.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- A sınıfındna türetilen B sınıfı durumunda (B is a A ) A sınıfına B sınıfının taban sınıfı(base class), B sınıfına ise
  derived(Türemiş class denir.) Bu duruma extension(genişletme) denir.

- Java da bu terimler yerine base class yerine super class, derived class yerine subclass terimi kullanılır.

- Bir sınıfın taban sınıfı dendiğinde o sınıfın türemiş bir sınıf olduğu anlaşılır. Bu taban sınıfa  direct(doğrudan)
  super class yada super class denir. (Vapur ve Deniz Aracı ilişkisi.)

- Indirect super class (Vapur ve Araç ilişkisi)

- Java da multiple inheritance yoktur. Bir sınıf sadece tek bir sınıftan türetilebilir.

- Java da türetme işlemi extends anahtar sözcüğü ile yapılır.

- A sınıfından türetilen bir B sınıfında(class B extends A) A sınıfının private ve non-modifier metodları hariç tüm
  metodları kullanılabilir. Aynı şeyler veri elamanları içinde geçerlidir.

- B sınıfından türetilen bir C sınıfında A sınıfının, ve B sınıfının public ve protected metodları ve memberlarına erişim
  sağlanabilir.

- C sınıfının base class(yada direct class'ı)'ı B'dir. indirect base class'ı ise A'dır.

- veri elemanları içinde aynı durum içindir.
         B x = new B();
         b.x = 10;
         b.y = 10;
    class B extends A {
        public int y;
    }
    class A {
        public int x;
    }

- türetme durumunda taban sınıf içerisindeki değişkenlerde türemiş sınıf içerisine aktarılır.
- Türetme durumunda taban sınıf türünden nesnenin sizeof'u kadarlık bir bölğm türemiş sınıf türünden nesne içinde bulunur.

- Composition'da ve aggregation'da bu durum sadece içinde diğer sınıf türünden bir referans bulundurur.

- Kalıtımda ise Taban sınıfı türünden bir nesne türemiş sınıf içinde vardır.(Burada resimlere bakılabilir)

- Türemiş sınıf  nesnesinin uzunluğu  = taban sınıf nesnesinin uzunluğu ve yeni eklenen
  non-static veri elemanlarının uzunluklarının toplamından daha az olamaz. Fazla olabilir.

- Metodlar sınıf içerisinde yer kaplamaz.

- Bir nesnenin yaratılma aşamaları
    - Bellekte yer ayrılır
    - Veri elemanlarına default değer atanır.
    - Ctor çağırılır.

- Türetilmiş sınıf nesnesi yaratıldığında türemiş sınıfın ilgili ctor'u çağrılmadan önce taban sınıfın
  önceden yaratılması gerekir.  Yani subclass'ın ctor'u çağrılmadan önce super class'ın ctor'ının mutlaka çağrılması gerekir.

- herhangi bir şey belirtilmemiş ise taban sınıfın default ctor'u çağrılır.

- taban sınıfın default ctor'un çağrılmaması için
    - taban sınıfın default ctor'u hiç olmayabilir.(Parametreli bir ctor yazılmıştır.)
    - taban sınıfın default ctor'u private olabilir.
    - yada programcı taban sınıfın default ctor yerine başka bir ctor'un çağrılmasını istiyor olabilir.

- Yukarıdaki durumlarda türemiş sınıf türünden herhangi bir belirtme yapılmadan nesne yaratılamaz.

- Bu durumlarda özel bir sentaks vardır. İsmi super ctor sentaksıdır.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                        super ctor sentaksı
///////////////////////////////////////////////////////////////////////////////////////////////////

- Programcı türemiş sınıfının ctor'unun hemen başında taban sınıfının ilgili ctor'unun çağrılmasını sağlayabilir.

- Bu durumda super ctor sentaksı kullanılabilir.

- super ctor sentaksı ancak ve ancak türemiş sınıfın ctor'u içerisinde geçerlidir. ve ctor'un ilk statement'ı olmalıdır.
    class B extends A
    {
        public B()
        {
          int x = 5;
          super();//error, super ctor sentaks have to be first statement of ctor
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////////////
                                        this ctor sentaksı
///////////////////////////////////////////////////////////////////////////////////////////////////

- this anahtar sözcüğü ile ilgili sınıfın başka bir ctor'ının çağrılması sağlanır.
- bu sentaksı super ctor sentaksından ayıran şey this ctor'u yazılmadığnda herhangi bir şey  yapılmaz,
  ancak super ctor sentaksında bir şey yazılmaz ise taban sınıfın default ctor'ına çağrı yapılır.

-Bunların ayrıca this ve super referansı adı verilen referans'larıda vardır. this ctor sentaksı da en başta olmalıdır.

- this sentaksı ve super ctor sentaksı aynı anda kullanımı hatadır. Ve hiç bir tasarım kalıbı bizi bu duruma sürüklemez.

- this sentaksında döngüsel durum geçersizdir.

- A sınıfından türetilmiş bir B sınıfının protected bölümüne (A sınıfı ve B sınıfı ayrı pakettelerdir)
    package test;
    class A {
    protected int x;
    }

    package mest;
    import test.A;
    class B extends A {
        public void foo (){
            A a1 =  new A();

            a1.x; // error, can't access to protected area;
            x = 15; ok, türemiş sınıf kendisine ait elemana erişmiş olur.
        }
    }

- Bir elemanı gizlerken ondan türemiş olan sınıfların erişip erişemeyeceğini  belirlemekte önceden gereklidir.
  Ancak bir veri elemanının gizlenmesi yani private yapılmasının kuralları gene geçerlidir.

- Bir veri elemanın protected olması için öncelikli olarak private olmasını gerektiren koşulların hepsinin problemimizi
  etkilemiyor olması lazım.

- içeride sarmaladığı(composition yada aggregation'a sahip) bir sınıfın aynı isimli aynı parametreli fonksiyonlarını
  yazmaya delegate etme denir. Buna delegate metod, pass true metod denir.

- Java da her sınıf doğrudan yada dolaylı olarak Object sınıfından türetilmiştir.

- Object'in extends ile yazılması sorun oluşturmaz. Ancak yazılmaması daha uygundur.

- UML diagramları çizerken en tepeye Object sınıfı koyulmaz.
  (Her java progamcısı en tepede Object sınıfının olduğunu bilir.)

- Java' da türemiş sınıf türünden bir referans taban sınıf türünden bir referansa atanabilir.(upcasting)

- Taban sınıf türünden bir referans türemiş sınıf türünden bir referansa doğrudan atamaz.(down casting)

- taban sınıf türünden türemiş sınıfa atama yapılamamasının sebebi, türemiş sınıf referansının türemiş sınıf
  memberlarını kullanıyor olabilmesi ve runtime error'a sebep olur.

- downcasting tür dönüştürme operatörleri ile de birbirine atanamaz. Bunun istisnai durumları vardır.

- upcasting(Yani taban sınıf ile türemiş sınıfın ortak yeri)'de sadece taban sınıf ile çağırılabilecek fonksiyonları
  çağırabiliriz.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            22.03.2020
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Bir referansın iki türü vardır. static ve dinamik türleridir.

- Bir referansın statik türü o referansın bildirildiği türdür ve hiç bir zaman değişmez.
  Derleme zamanına ilişkin bir bilgidir.
  A a;// a referansının statik türü her zaman A türündendir.
  a = new B(); // a referansının dinamik türü B türündendir.

- Statik tür programda kendi belirttiğimiz türdür.

- Bir referansın türü dendiğinde statik tür anlaşılır.

- Bir referansın dinamik  türü o referansın bellekte gösterdiği nesnenin gerçek türüdür.
- Referansın dinamik türü değişebilir
- Referansın dinamik türü run timeYüksek seviyeli çoğu dil için adreslere doğrudan erişimi diller desteklemi 'a bağlı bir şeydir. Referansa run time'da atanan değer
  dinamik türüdür.


- Java da ve C++'da da bir referansa bağlı olarak çağırabilecek fonksiyonlar referansın dinamik türüne göre değil
  statik türüne göre yapılır.
  A a = new B();

  a. ile ancak ve ancak a'nın statik referansına uygun metodlar çağırabilir. Eğer ki ilgili metod override edilmemiş ise
  (Yani A sınıfının içindeki fonksiyonlar)

- Bir referansın dinamik türü aşağıdaki gibi ekrana yazdırabilir.
    Sout(a.getClass().getName());

- Derleyici çalışma zamanında ki değişebilecek değerleri umursamaz.

- downcasting tür dönüşümlerinde eğer yapılan dönüşümde referansa atanan dinamik tür, o referansı
  kapsıyor ise bu dönüşüm geçerlidir.

- Java da adreslere doğrudan erişim sağlanamamaktadır. Run time da yada aşağı seviyede erişmemizi sağlayan
  araçlar vardır.

- referanslar'da  her zaman statik tür ne ise o türe ilişkin fonksiyonlar ve member'lara erişim sağlanır.
  upcasting kuralıda bu kurala dahil değildir.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    RTTI (RUN TIME TYPE IDENFTIFICATION)-> Çalışma zamanında tür belirleme
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- instanceof operatörü, iki operandlı  araek bir operatördür, birinci operandı referans ,
  ikinci operandı da referans tür ismidir.
- Operatör birinci operandına ilişkin referansın dinamik türünün ikinci operandına ilişkin türü
  kapsayıp kapsamadığına göre  boolean türüne geri döner.
  if (obj instanceof Employee) // Eğer obj referansının dinamik türü Worker, ProjectWorker, Manager
  SalesManager türünden biri ise doğru dönecektir.
  Yani is a ilişkisine de bakar.

- instanceof operatörünün mantıksal değilini döndüren herhangi bir operatör bulunmaktadır.
  bunu sağlamak için ancak ve ancak if(!(obj instanceof reftype)) şeklinde kullanılabilir.
- ! operatörü instance of'dan öncelikli seviye'ye sahiptir.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                     FINAL CLASS
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Bir sınıftan türetme yapılması istenmiyor ise  sınıf bildiriminde final olarak belirtilmelidir.
    final class intValue{}

- Genel de immutable sınıflar final olarak yazılır.
  String sınıfı final'dır.

- Dillerde mutlaka türetmeye açmaya veya türetmeye kapatmaya yarayan araçlar vardır.

- Kotlin programa dilinde default olarak bir sınıf türetmeye kapalıdır. Kotlin de türetmeye açmak için bir sentaks vardır.


- final yapmak ayrıca okunabilirliği de etkilemektedir. Programcı final yapılması gerekilen bir sınıfı final
  yapılmaz ise programcıyı okuma yönünden olumsuz etkilemiş oluruz.

- final yapmadan sınıfı türetmyeye kapatmanın yolu ctor'u private yapmaktır. Ancak bir sınıf türetmeye kapatılmak

- Bir sınıfı türetmeye kapatmak için ctor'u private olsa bile mutlaka final bildirilmelidir.
  Hem okunabilirlik, hemde derleyicinin kod optimizasyonu içindir.

- enum türünün ctor'u private olduğundan türetme yapılamaz. ayrıca başına final konulmasına izin verilmez.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                 Wrapper(Sarmalayan) Sınıflar
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Her temel(primitive) türe karşılık bir sarmalayan sınıf getirilmiştir.
    byte        Byte
    short       Short
    int         Integer
    long        Long

    float       Float
    double      Double

    char        Character(chars'lar ile işlem yapan metodları vardır.)

    boolean     Boolean

- Bu sınıflardan gerçek sayı ve tam sayı türüne ilişkin olanlar yani nümerik sınıfların(Byte, Short, Integer, Long,
  Float, Double ) türleri java.lang.Number isimli bir sınıftan türetilmiştir.

- Bu sınıflar immutable olarak yazılmıştır ve final olarak bildirilmiştir.

- Sarmalayan sınıfların ctor elemanları java 9 ile birlikte deprecated yapılmuıştır. Bu ctor'ların
  Java 5'den itibaren kullanımı kötü bir tekniktir.

- Sarmalayan sınıfların bir çok yararlı statik metodları vardır(Parse metodları, isUpperCase, isLowerCase).
    Nümerik sınıfların parseXXX metodları vardır.
        Integer.parseInt(String s, int radix); // klasik parseInt 10'luk sayı sistemine göre sayıyı alır.

    Nümerik sınıfların sarmaladıkları türe ilişkin bir takım değerleri içeren final static veri elemanları bulunur.
        Her birinde bulunan MAX_VALUE, MIN_VALUE ilgili sınıf hangi türden ise o türe geri dönerler.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            03.04.2020
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Boolean class
    - Herhangi bir şekilde min yada max valuedeğerleri yoktur.
    - SIZE değeri yoktur
    - BYTES değeri yoktur.
- Java da built-in türlerin uzunluklarını Sarmalayan sınıfların  final static veri elemanı olan SIZE ilgili türün
  kaç bit'lik yer tuttuğu yazılmıştır. Boolean türünün SIZE değişkeni yoktur, Çünkü standartlarda boolean türünün
  kapladığı yere dair herhangi bir bilgi bulunmamaktadır. Bu derleyiciyi yazan kişilere bırakılmıştır.



- Sarmalayan sınıfların diğer bir görevi de temel bir türe ilişkin değeri heap'de tutmamızı sağlar.


- Bunun yararı örneğin object türü ile kullanılabilmesidir. Bu sarmalama işlemine yani heap'te tutma işlemine
  boxing (kutulama) denir.

- Java 9 ile birlikte ctor elemananları deprecated olmuştur. Deprecated bir fonksiyon kullanılmamalıdır.

- Java 5 ile birlikte sarmalayan sınıflar için valueOf metodları eklenmiştir(Temel tür parametreli olanlar.).
  Java 5'ten sonra hiçkimse new operatörü ile sarmalayan sınıf yaratmamaktadır.

- valueOf tarzı sınıflara factory metodlar denir.

- Tüm sarmalayan sınıflar immutable olarak yazılmıştır.

- Integer sınıfı -128 ile + 127 aralığını cache atmaktadır. (Yani final static bir dizi olarak belirilmiştir.)
- Tüm sayı sınıfları aynı işlemi yapar.

- String parametreli valueOf metodlarının böyle bir sonuç vereceği kesin değildir. tür parametreli ile kullanmak
  her zaman daha iyidir.

- Character sınıfının negatif bir değeri olmadığı için sadece [0, 127] arasındaki değerleri tutar.  Character sınıfının
  bu değerler dışındaki karakterleri ön bellekte tutup tutmayacağı garanti değildir. Aynı durum integer sınıfı içinde
  geçerlidir.

- Double ve Float sınıfları da sarmalama anlamında belleği efektif kullanacağını garanti eder.

- Nümerik sarmalayan sınıflar Number isimli bir sınıftan türetilmiştir.
    - Number sınıfının xxxValue(intValue, byteValue) sarmaladığımız değeri  elde etmemizi sağlar.
    - Bu metodlar örneğin Integer.byteValue(); metodu klasik tür dönüştürme kurallarına göre çalışır.
      (Tür dönüştürme kurallarını tekrar et) Bu duruma(unboxing denir.)
- narrowing(daraltıcı), widening(genişletici)

- Sarmalayan sınıflar ile temel türleri de object referansına atanabilir hale gelmektedir.

- java 5 ile birlikte auto boxing ve auto unboxing eklenmiştir.
  Buna göre temel türe ilişkin değer sarmalayan sınıfa doğrudan atanabilmektedir.
  Integer i = 10; //Derleyici burada Integer i = Integer.valueOf(10) şeklinde yazacaktır. Yani auto boxing
  Double d = 1.; // Double d = Double.valueOf(1.);

- Bu özellik sadece sarmalayan sınıflara ait bir özelliktir.

- Kutulama işlemi Object türü içinde geçerlidir.
  Object o =  10;

- Kutulama(auto boxing) işleminde otomatik tür dönüştürme kurallarına uygun olsa bile bir primitive tür
  Başka türden bir sarmalayan bir sınıfa atanamaz.
  Double dval = 6;//error

- Bir referansın dinamik türü Object sınıfının getClass fonksiyonunun geri dönüş değerinin getName fonksiyonu
  ise referansın dinamik türünü verir.

- String sınıfında auto boxing gibi bir durum söz konusu değildir
    String s = "ankara";//derleyici burada "ankara" yazısı için bellekte  bir yer ayırır ve bu String nesnesinin
    referansını döndürür.

- integral promotion kuralları burada da geçerlidir.

- auto unboxing
     Double d = 1.; // Double d = Double.valueOf(1.);
     double dval = d; // double dval = d.doubleValue() auto unboxing.
     Burada primitive tür ne ise ona göre tür değiştirme fonksiyonunu çağırır.
     int ival = d; // d.intValue();


- auto unboxing' de Number türünden  doğrudan primitive türe atama yapanaamz.
    Number n = 10;
    int a = n; // error
    int a = (int)n;//ok Tür dönüştürme operatörü kullanılmalıdır.Aynı durum Object türü içinde geçerlidir.

    Object n = 10;
    int a = n; // error
    int a = (int)n;//ok

- otomatik kutu açma da primitive türün doğrudan sarmalandığı türe downcasting yapılabilir. Bunun dışında yapılan
  dönüşüm error olacaktır.
    Object o = 10; // o.getClass().getName(); == Integer
    long l = (long)o; // throws Exception Integer can't cast to Long


- int val = 10;
  Object o = val;
    short a= (int)o;//error int can't cast to short;
    short a = (short)(int)o; //ok (short)((Integer)o).intValue() burada tür dönüştürme operatörünün önceliği sağdan soladır.


- Sarmalayan sınıflar temel türün Sınıf karşılığıdır. Sarmalayan sınıflarda  dört işlem  yapılabilir.
    Integer iVal = 23;
    double val = ival + 2.3; // double val = ival.doubleValue() + 2.3;
  Sarmalayan sınıflar ilişkin oldukları türler gibi davranabilirler.

- Wrapper sınıflar' da ++ operatörünün operandı olan referans işlemden sonra  başka bir nesneyi gösterir
  (immutable olmasından kaynaklıdır.).
  Integer i = 10;
  ++i; // i = Integer.valueOf(i.intValue() + 1);

- Wrapper sınıflar ile yapılacak işlemler için yapaılacak işlemler için kod ilgili primitive türe dönüşütülüp
  o türler ile devam edilir
    Integer i = 1000;
    ++i; // i = Integer.valueOf(i.intValue() + 1);
    --i; // i = Integer.valueOf(i.intValue() - 1);
    ++i; // i = Integet.valueOf(i.intValue() + 1);

- Yukarıdaki kod aşağıdaki şekilde yazılması göreceli daha iyidir.
    Integer i = 1000;
    int val = 10;
    ++val;
    --val;
    ++val;
    i = val; // Integer.valueOf(val);

- Sarmalayan sınıflar auto boxing ve auto unboxing  sayesinde bir primitive türmüş gibi kullanılabilir.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            04.04.2020
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Algoritma nedir : bir problemin doğru çözüm adımlarına denir.
- Algoritmanın incelemensine  algoritma analizi denir. Algoritma analizindeki en tipik durumlardan birisi algoritmanın
  karmaşıklığıdır.

- Algoritmanın karmaşıklığı
    - Hız *
    - Kaynak kullanımına bağlıdır.
    - Burada hız genel olarak daha ön planda tutulur.

- Algoritmanın karmaşıklığı
    O(1)        -> döngü yok
    O(logn)     -> tek bir döngü var her adımda dönme sayısı yarı yarıya azaltılır.(Binary search algoritması)
    O(n)        -> tek döngü vardır.
    O(n * logn) -> iç içe iki döngü vardır ve birisi her adımda yarı yarıya azalır.(içteki veya dıştaki farketmez.)
                   Quick sort algoritması böyle bir algoritmadır.
    O(n ^ 2)    -> iç içe iki döngü vardır.
    O(n ^ 3)    ->
    O(n ^ k)    -> böyle bir ihtimal çok düşüktür.
    O(k ^ n)    -> k ^ n'sel karmaşıklık
    O(n!)       -> faktöriyel karmaşıklık


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            Arraylist/Vector sınıfları
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Arraylist/vector aynı StringBuilder(StringBuilder sınıfı için length ve capacity) sınıfı gibi capacity ve size adlı iki
  değişkeni vardır. Arraylist dinamik olarak büyüyebilen bir sınıftır.

- Arraylist olsun başka Collection sınıflar olsun capacity ile size arasındaki herhangi bir bölgeye
  doğrudan erişmek run time hatasıdır.

- Arraylist sınıfının capacity'yi veren bir metodu yoktur. Bunu gerektiren durumlarda ArrayList yerine Vector sınıfı
  kullanılacaktır. Bu sınıflar java.util paketi altındadır.

- Default belirlenen(Ne demek olduğu Collection'lar konusunda daha iyi anlaşılacaktır.) ArrayList objeleri içerisinde
  Object türünden dizi referansı  tutar.

- ArrayList/Vector sınıflarının default ctor'larında capacity değeri 10 olur.

- ArrayList/Vector sınıflarının add metodları sona ekleme yapmak için kullanılır
  Gerektiğinde capacity değerini de büyütür.

- Sınıfın index parametreli add metodları parametre olarak gönderilen index geçerli bir değer değer ise o indexe
  ekleme yapıp sınıfı bir kaydıracaktır.
- ArrayList/Vector sınıfının capacity artırılması gerektiği zaman capacity'i 2 katına çıkartır.

- ArrayList/Vector sınıflarınının ekleme yapan metodları capacity'i genişletirken
  silme yapan metodları  capacity de herhangi bir küçültme yapmaz.

- Sınıfın araya ekleme yapan (index parametreli) add metodları O(n) karmaşıklığında çalışır. Çünkü kaydırma
  işlemi yapacaktır. ArrayList.add(T idx, T value)

- get metodları verilen indexteki objeyi döndürür.
    int val = ArrayList.get(int index); // error Object can't cast to int;
    int val = (int)ArrayList.get(int index); // ok

- ArrayList/Vector tarzı sınıflara iterable sınıflar denir(Bu tarz sınıflar for-each döngü deyimi ile dolaşılabilir.).

-  set metodu
    - Object set(int index, int val); // set ettiğimiz elemanın eski değeri Object nesnesi olarak geti döndürür.
      int val = obj.set(10, 25); // 10.  indexteki elemanı değiştirebiliriz. val değeri 10. indeksteki set'ten önceki
      değerini döndürür.

-  clear metodu(Capacity değerini değiştirmez)
     - ArrayList.clear(); // içindeki bütün elemanları siler.(Böyle sınıfların silme yapan metodları capacity'de
       herhangi bir değişikliğe gitmez. Yalnızca size'ı değiştirir.)

- remove metodu // belirli bir indekteki değeri siler. O sildiği objeyi geri döndürür.
    int val = (int)ArrayList.remove(int index);

- trimtoSize(); // capacity'yi size'a çeker.


- ensureCapacity(int newCapacity) // capacity'i sadece büyütmemizi sağlar. küçültme işlemi için kullanılamaz.
    - Örnek için Boş bir Vector türü kullanılacaktır.(Vector v = new Vector();) // default capacity değeri 10'dur
    - Varolan capacity değerinden daha düşük bir değer girilirse capacity'yi varolan capacity değerini korur.
        (capacity <= 10)
    - Varolan capacity değerinin artması gereken değerden büyük ise
        (capacity >= 10 && capacity <= 20 ise capacity 20 olur.)
    - Eğer varolan capacity değerinden büyük ise o zaman parametre ile verilen capacity değerine çekilir.
            (capacity > 20 ise capacity fonksiyona argüman geçilen değer olacaktır.)
- Bu tarz sınıfların setLength gibi length'i doğrudan değiştirmemizi sağlayan bir metodu yoktur.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            null referans (Tony Hoare tarafından ortaya atılmıştır.)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- kullanılmayan bir adresi temsil etmek için null  anahtar sözcüğü kullanılır.(aslında null bir sabit değerdir.)
  null adresi ancak referanslara atanabilir.
    - sınıflar
    - diziler
    - enum türünden referanslara null değeri atanabilir.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            05.04.2020
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- null değer kontrolü adres kontrolü olduğu için == yada != operatörü ile kontrol edilebilir.
    Sample s = null;
    System.out.println(s == null); //  true
    System.out.println(s != null); //  false

- bir referansın default değeri null'dır.(Yani referansın mantıksal 0 değeri null'dır.)

- null değeri neden kullanırız.
    1-) Singleton(lazy implementation) yani kontrol amaçlı kullanılabilir.Bir referansın nesne gösterip göstermediği
        testi yapılabilir.
    Not : içerisinde null olan bir referans'a erişim exception hatasıdır.
    2-) türe dönen fonksiyonlarda yanlış bir argüman geçildiğinde null döner.(örneği random fonksiyonlarda min ve max
        değerleri yanlış girildiyse) Uygulama kursunda daha gelişmiş java 8 ile dile eklenen bir araç ile yapılır.

    3-) Hiç bir şey atanmamış bir sınıf referansını null ile initialize edilmelidir.
    4-) Nesneyi gösteren referanstan nesneyi kopartmamızı sağlar. (s = null;)

- Nesneler ne zaman ölür
    - yerel değişkenler scope'ları bittikten sonra ölürler(Yerel değişkenlerden kastımız parametre değişkenleri ayrıca,
      Tür referansları da birer yerel değişkendir.)
    - static değişkenler program da hayata geldikleri andan itibaren program sonuna kadar hayatına devam edebilir.
    - Java da programcı nesneyi öldüremez(nesneyi öldürecek olan garbage collector denilen mekanizmadır.). Sadece nesnenin
      ölmesine sebep olabilir. Nesnenin kullanılmadığına yönelik algoritmalar vardır. Bunlardan en tipik olanı referans
      sayma yöntemidir. Bu yönteme göre yaratılmış her nesne için bir referans sayacı tutulur. Nesnenin her referansa
      atanması durumunda bu sayaç bir artırılır. Her referans'tan koparıldığında bu sayaç bir azaltılır. referans'a
      null değeri atanabilir. Nesne için referans sayacı 0 değerine gelmişse nesne artık kullanılmıyor durumdadır. Yani
      çöp olmuşturç Buna ingilizce olarak "garbage collected(Java da daha çok bu kullanılır)" veya "eligible" terimi
      kullanılmaktadır. Bir nesne kullanılmıyor(Yani garbage collected ) durumda ise garbage collector devreye girdiğinde
      yok edilir. Standartlara göre çöp toplayıcı programın ne zaman devreye gireceğine yönelik bir standart
      belirlenmemiştir. Bu işlem garbage collector'u yazanlara bırakılmıştır. Ancak  JRE(Java runtime edition) için
      bunun etkinliğine güvenilir(Python'da sayaç sıfıra düştüğü garbage collector hemen gelip nesneyi yokeder).
      Java da bir programcı nesnenin ancak ölümüne sebep verebilir.
    - Garbage collector nesnesinin ne zaman çalışığına dair bir mekanizma yoktur.

    - Programcı istediği zamanda garbage collector'u çağırabilir.(System sınıfının gc isimli metodu ile garbage collector
      devreye sokulabilir. Ancak bunun sürekli yapılmaması daha açık bir ifade ile dikkatli yapılması gerekmektedir. Çoğu
      zaman garbage collector'un kendi algoritmasına güvenilebilir.)

  - Bir nesnenin adresinin bir statik referansta olması demek o referansın ve nesnenin programın sonuna kadar yaşayacağı
    anlamına gelir.


- ArrayList'in add metodları boolean döner(Ancak her zaman true döner).
- ArrayList sınfı tarzı sınıfların(Collection sınıfların) implementasyonu mülakatlarda sorulabilir.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            static  initializer
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Sınıfın içerisindde static bloklar istenildiği kadar tanımlanabilir. Bu blokların her birinin içine kod yazılabilir
- Bir sınıfın herhangi bir elemanı ilk kez kullanıldığında, tüm statik bloklar yukarıdan aşağıya sırasıyla bir kez
  olmak üzere çalıştırılır.
    class A {
        static {

        }
        static {
        }
    }

- static bloklar herhangi bir static metod  gibidir. Yani bu bloklarda sınıfın yalnızca statik elemanlarına erişilebilir.

- static initializer ne işe yarar?
    - sınıfın final static yada sadece static veri elemanlarına atama yapılabilir. Burada atama yapılabilmesi için
      bildirim noktasında atama yapılmamış olması lazımdır.

- Bir sınıfın static elemanları ne zaman yaratılır ? yada statik bloğu ne zaman çalışır.
    - Sınıfın herhangi bir elemanının ilk kez kullanılımında (bu ctor olabilir yada başka bir static eleman olabilir.)

- sınıfın veri elemanları yada static block sınıfın herhangi bir yerine yazılabilir.




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            10.04.2020
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            non-static  initializer
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Bir sınıf nesnesi yaratılmadan önce gerçekleştirilen fonksiyondur gibi diyebiliriz.

- super sentaksı non-static initializer'dan daha önce yapılır.

- Kalıtım durumunda öncelikli olarak taban sınıfın ctor'u  çağırılır. Yani taban sınıfın varsa  önce
  non-static initializer'ı sonra taban sınıfın ilgili ctor'u sonrasında ise türemiş sınıfın  varsa non-static
  initializer'ı yoksa ilgili ctor'u çağırılır.

- non-static initializer'ı ile, sınıfın non-static final değişkenlerine değer atanabilir.

- static blok'lar uygulamada non-static bloklara göre daha çok karşımmıza çıkar.

- static bloklar okuma amaçlı olarak sınıfın daha derli toplu gözükmesi için yazılabilir.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            this  reference
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Java da aşağı seviye de bütün non-static metodlar static metoda dönüştürülür. Metodlara this referansı dediğimiz
  yani hangi sınıfa ait bir fonksiyon ise o sınıf nesnesinin adresi ile çağrılır.

- class Myclass {
    public void foo(){}
    // foo metodu aşağı seviyede tamamen aşağıdaki gibi yazılır diyebiliriz.
    public static void foo(Myclass m) {}
  }
}
- aslında aşağı seviyede yazılan bütün metodlar static metodlardır.
- aşağı seviyede foo methodunun Myclass türünden bir referans parametresi vardır.
- bu fonksiyonun çağrılmasında ise derleyici aşağı seviyede şöyle bir kod yazmaktadır
    Sample s = new Sample();
    s.foo();
    // Sample.foo(s); derleyici aşağı seviyede kodu bu hale getirir.

- this referansına atama yapılamaz.

- this referansını okunabilirliği artırmak için non-static metodlar için kullanılacaktır ve tercih edilecektir.

- fluent kalıbı illa ki this reference'ı ile yapılacak diye bir şey yoktur.
- String sınıfı fluent çağrıya uygundur.
- immutable sınıflarda da yeni bir sınıf nesnesi dönen sınıflar fluent kalıpları
  ile yapılabilir.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            11.04.2020
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            Polymorphism(Run time polymorphism)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- 2 çeşite ayrılır
    1- Run time polymorphism
    2- Compile time polymorphism(Generic'ler ile başlanacak)


- Polymorphism'in nesne yönelimli programlamada 3 tane tanımından bahsedilebilir.
    1- Biyolojik tanımı            : Taban sınıfın bir fonksiyonunun türemiş sınıfta yeniden gerçekleştirilmesidir.
    2- Yazılım Mühendisliği Tanımı : Türden bağımsız kod yazabilmektir. Hangi türden işlem yapacağınızı bilmeden kod
                                     yazmaktır.

    3- Aşağı seviyeli tanımı       : Önceden yazılmış kodların sonradan yazılmış kodları çağırabilmesidir.
                                     Burada söylenmek istenen taban sınıf türünden bir referans ile türemiş sınıfın
                                     fonksiyonu çağırılabilir.

- Java da polymorphism sanal metotlar ile gerçekleştirilir.
- Sanal metotlar non-static ve final olmayan metotlar sanal metotlardır.
- static metotlar sanal metot olarak ele alınmazlar.

- Taban sınıfın bir metodunun türemiş sınıf içerisinde geri dönüş değeri ve imzası aynı olarak yeniden yazılmasına
  "override" fiili kullanılır. Burada erişim belirleyici aynı olmayabilir. Ancak bu konunun detayları vardır,
  ileride ele alınacaktır.

- Override edilen bir fonksiyon static olarak bildirilemez.

- Sanal bir metotun türemiş sınıfta overrride edilmesi zorunlu değildir. Durum tamamen senaryomuza bağlıdır.

- Sanal bir metot çağırısında referansın dinamik türüne ilişkin ilgili sanal metot override edilmiş ise ilgili
  dinamik türün fonksiyonu çağrılmasıdır.

- Override edilmemiş ise dinamik türe ait sınıfın taban sınıfına yada sınıflarına bakılır. Bunların hepsi run time da
  yapılır.

- Ortada inheritance yok ise polymorphism'den bahsedilemez.

- isim arama kuralları statik referans'a göre yapılır. Dinamik türe  bakılarak hangş fonksiyonun çağrılacağı belli olur.

- augmentation = override edilmiş bir fonksiyon taban sınıfın ilgili fonksiyonunu çağrılıp yeni eklemeler yapılmasıdır.
                 companyapp örneğindeki toString metodları bunun örneğidir.


- augmentation genel olarak şöyle bir yapıdır. Türemiş sınıfın ilgili metodu taban sınıfın ilgili metodunu
  super keywordu ile çağırır. Ayrıca override edilmiş fonksiyon da yeni eklemeler yapılması durumudur.

    class A {
        public void foo()
        {
            System.out.println("A.foo()");
        }
    }

    class B extends A{
        public void foo()
        {
            // dinamik türler super referansı dışında herhangi bir şekilde taban sınıfın fonksiyonunu çağıramaz.
            super.foo();
            //bunun dışında yeni özellikler eklenirse  bu gibi durumlara augmentation denir.
            System.out.println("B.foo()");
        }
    }

- Taban sınıfın içerisinde bildirilmiş bir veri elemanı ile aynı isimde bir değişken türemiş sınıfında da bildirilebilir.

- Ancak bu durumun polymorphism ile ilgisi yoktur. Bu durum kullanılan referansın (A x = b; bahsedilen referans A'dır)
  statik referansına ilişkin bir durumdur.

- polymorphism doğrudan metota ilişkin bir kavramdır.

- Java'da override edilen bir methodun erişim belirleyicisi ancak ve ancak yükseltilebilir. Düşürülemez.

    class A {
       public void foo(){}
    }

    class B extends A {
        protected void foo(){}//error access modifier can't reduce, Erişim belirleyicisi düşürülemez.
    }

- Aşağıdaki örnekte erişim belirleyici yükseltilmiştir.
    class A {
       protected void foo(){}
    }

    class B extends A {
        public void foo(){}// ok. erişim belirleyicisi yükseltilebilir.
    }

    - public bir erişim belirleyicisine sahip bir fonksiyon public olarak override edilebilir.
    - protected bir erişim belirleyicisi nadir de olsa bile public'e yükseltildiği durumlar vardır.

    Not : Java da herkese protected olan bir eleman konulamaz.

- covariant return type : polymorphism'i ilgilendiren özel bir durumdur. Geri dönüş değeri referans olan metotlar
  için geçerlidir.

- taban sınıf içerisinde referans geri dönüş değeri olan bir metod, türemiş sınıfta override edilirken geri dönüş değeri
  olarak taban sınıftaki metodun geri dönüş türünden veya o türden türetilmiş bir sınıf türüne dönebilir.

- Bu durum sadece geri dönüş değeri referans olan metotlar için ve geri dönüş değeri için bir geçerli bir durumdur.

- Aşağıdaki durum sadece covariant return type için geçerli bir durumdur. Normalde bir fonksiyon override edilirken geri
  dönüş değeri(primitive bir tür ise yada final belirtilmiş bir tür ise) bu türün değiştirilmesi error olur.

- Aşağıdaki örnek covariant return type için bir örnektir. Java'da bunun alışkanlığı yoktur. Daha çok C++'da görünür.
    class A {
        public X foo()
        {
            return new X();
        }
    }
    class B extends A {
        public Y foo()
        {
            return new Y();
        }
    }
    class Y extends X {}
    class X{}


- static  fonksiyonlar nesneden bağımsız oldukları için override edilemez.
- Türemiş sınıf içerisinde taban sınıfın statik bir metodu aynı geri dönüş değeri ve imza ile yazılabilir. Buna
  bazı kaynaklar logical static override derler. Ancak polymorphism anlamındaki bir override kesinlikle değildir.

- metotlar için final keywordu : bir türetme hiyerarşisinde ilgili fonksiyonu türetmeye kapatmak için kullanılır.
  Kısaca final olarak bildirilmiş bir metot override edilemez.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            12.04.2020
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Java bir fonksiyonu override ettirmeme durumunu bizim vermemiz gereken bir karardır.


- Aslında bütün sınıflar object sınıfından üretildiği için toString() metodu çoğu zaman
  override edilir.

- eğer toString metodu override edilmemiş ise toString metodu nensneye yönelik tekil bir
  bilgi verir. Bu bilginin pratikte çok anlamı yoktur.

- toString metodu en çok override edilen metodlardandır.

- printf, println metodlarına bir referans verildiğinde toString gerçekleşir, bu metodlar nesne null bir referans
  göstermiyor ise ilgili referansın toString metodunu çağırır.

- println metodu tarzı metodlar primitive türler için overload edilnmişken, printf için auto-boxing
  yapılırak gönderilir.

- operatörlerden biri String ve birisi herhangi bir primitive tür ise primitive autoboxing yapılarak toString metodu
  çağırılır.
    int degree = 10;
    String str = "Derece : " + a; // "Derece : " +Integer.valueOf(degree).toString();

- tosString metodu ile bir String ile herhangi bir nesne toplanabilir.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            Abstract class
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Kendi başına bir anlam ifade etmeyen ancak kendisinden türetilmiş sınıfların anlam kazandığı sınıflara abstract(soyut)
  sınıflar denir. Soyut olmayan sınıflara concrete(somut) sınıf denir.

- Soyut bir sınıf abstract anahtar sözcüğü ile bildirilir.

- Bir sınıfın abstract metodları olabilir. abstract metodlar gövdesi olmayan metodlardır. Bu metodlar sanaldır
  dolayısıyla override edilebilir. En az bir tane abstract metodu olan bir sınıf  abstract olarak bildirilmelidir.
  Aksi durumda error oluşur.

- abstract metod ve class'ın implementasyonu
   abstract class Sample {
        public abstract void foo();
   }

- abstract bir metoda sahip bir sınıfın abstract bildirilmesi zorunludur.

- abstract sınıf türünden bir nesne new operatörü ile yaratılamaz(abstract sınıf türünden nesne yaratılamaz değildir).
  Sınıf içerisinde dahi yaratılamaz. Yalnızca bir türemiş referanstan upcasting yapılarak oluşturulabilir.

- abstract sınıfların veri elemanları olabilirler.

- abstract metodlar sanal metodlardır. (Yani override edilebilen fonksiyonlardır.)

- abstract bir metod, override edilirken abstract olarak belirtilemez.
- abstaract bir sınıftan türetilmiş sınıf bir taban sınıfın en az bir tane  abstract fonksiyonunu override etmemiş
  ise türetilmiş sınıfta abstract bir sınıftır.

- türetme hiyerarşisinde taban sınıfın bütün abstract metodları override edilmiş ise  ancak somut(concrete) bir
  sınıf olur.
    abstract class A {
        public abstract void foo();
        public abstract void tar();
    }
    abstract class B extends A {
        public  void foo()[} // B sınıfı halen abstract olur.
    }
    class C extends B {
         public void tar(); // C sınıfı artık somut bir sınıftır.
    }

- static bir fonksiyon abstract olarak bildirilemez. Abstract'lık tamamen nesne ile alakalı bir kavramdır.

- abstract bir sınıfın anlamı taban sınıfı türünden bir referans bildirilip bu referansa türemiş abstract olmayan
  bir referans atanabieceği içindir. Buda polymorphism için çok önemli bir detaydır. Burada new ile yaratılan nesne
  kesinlikle somut bir sınıftır.

- polymorphism'in kullanıldığı sınıflar da genel olarak en tepe de bir abstract sınıf vardır.
- Object sınıfı abstract bir sınıf değildir.

- abstract sınıf türünden bir nesne yaratılabilir. Ancak o nesneler kullanıcı tarafından yaratılamaz.
  zaten türemiş sınıf içinde taban sınıf türünden bir nesne mutlaka yaratılır.

- Abstract sınıfların ctor'u olabilir. Çünkü o sınıftan türetilmiş bir sınıf ilgili ctor'u çağırmak istiyor olabilir.
  Ancak abstract sınıfların çoğu zaman ctor'unun public olması

- abstract sınıflarda ctor'un anlamı tamamen türemiş sınıflar içindir. Bu yüzden de okunabilirlik açısından
  ctor'un protected yapılması önemli bir işlemdir. Abstract sınıfların ctor'unun public yapılması çoğu zaman
  anlamsızdır.  abstract sınıfların ctor'u genel olarak  protected yapılır. Çok az rastlanan durumlar için de
  private yapılır.

- abstrac sınıf yada metodlar aynı zamanda final bildirilemez.

- concrete metotlar denildiğinde aklımıza non-static metodlar gelmelidir.

- sınıfın non-static metodları sadece bir tanedir. Yalnızca sınıf türünden referansı olan bir fonksiyonu vardır.

- Genel de abstract bir sınıfın en az bir adet abstract metodu vardır.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                            Exception Handling
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

- Java da exception işlemleri için aşağıdaki anahtar sözcükler kullanılır.
    try, catch, throw, finally, throws

- Exception genel olarak programın çalışma zamanında  oluşabilecek hatalı durumlar için kullanılır.


- Java da Exception hiyerarişisi
    en tepe de
    throwable <- Exception <- RunTimeException
              <- Error

- Exception sınıfları throwable'dan yada throwable'dan türemiş herhangi bir sınıftan türetilmesi gerekmektedir.

- Bir exception fırlatıldığında akış exception'ın fırlatıldığı metoddan bir daha geri dönmemek üzere o sınıftan
  çıkar.

- Doğrudan dolaylı olarak throwable sınıfı türünden türetilmemiş bir sınıf ile exception throw işlemi yapılamaz.

- akış exception bakımında ele alınacak ise try bloğu   içerisinde yazılmalıdır. try bloğunu en az bir tane
  catch bloğu yada tek bir finally bloğu yada catch blokları ve finally bloğu ile devam edebilir.
  try bloğu mutlaka ve mutlaka catch yada finally blokları içinde olamlıdır.

- bir exception yakalanmak isteniyor ise mutlaka try bloğu içerisine konulmalıdır.

- catch bloğu aşağıdaki şekildedir. catch parametresi mutlaka ve mutlaka gene exception hiyerarşisinden
  türetilmiş bir sınıf olmalıdır.
    catch (catch_parameter)

- Java da exception handling yapılmadan program yazılamaz(C++'da exception handling'den olabildiğince kaçınılmalıdır.).

- catch blokları sadece bir tane olmak zorunda değildir. Birden çok catch bloğu olabilir. Ayrıca exception throw
  edilen kodda farklı kod yerlerinde farklı exception nesneleri fırlatabilir.

- catch blokları yukarıdan aşağıya switch deyimi gibi kontrol eder. Uygun catch bloğu bulunur ise akış oraya girer.
  Uygun catch bloğu aramasında upcasting işlemi de geçerlidir. Uygun catch bloğu bulunamaz ise proram sona erer.


















