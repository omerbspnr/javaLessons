----------------------- 18 Ocak 2020 -----------

- Temel türler(predifined, primitive) :
 	- Java da bütün tam sayı türleri işaretli olarak tutulur

 	- short				2 byte
 	- int				4 byte
 	- long				8 byte
 	- byte				1 byte [-128 ,127]; 1000 0000(-128), 0111 1111(127)

 - Bu sistemlerde sıfır pozitif sayı olarak görülür.
 - Java'da C, C++'da ki gibi işletim sistemlerine göre türlerin byte'ları değişmez.
   Bütün işletim sistemleri için aynıdır.

   	- float 			4 byte
   	- double			8 byte

- tam sayı türleri için default tür olarak int kullanılmalıdır.
  Aynı şey gerçek sayı türleri double türüdür.


 	- char				2 byte
 	  boolean			standartlarda belirtilmemiştir.

----------------------- 19 Ocak 2020 -----------------

- Java da değişken bildirimi üç şekilde yapılabilir.
	1. Yerel değişkenler		(local variables)
	2. Paremetre değişkenleri	(Parameter variables
	3. Sınıf veri elemanları	( class member variables )

- Java da istenildiği kadar iç içe bloklar olabilir.
- Java da metot içerisinde bir bloğun herhangi bir yerde bildirilen değişkenlere
  yerel değişkenler denir.

- scope : bir değişen isminin derleyici tarafından görülebildiği alana denir.
- yerel değişkenlerin ilk değer verilmediği halde, herhangi bir değer ile hayata gelmez.
- iki yerel değişkenlerin isimleri aynı ise faaliyet alanlarının çalışması durumunda error oluşur.
  Faaliyet alanları birbirini kapsar durumda ise de bu errordur.

- Java da C'de ki gibi name lookup'dan kaynaklı isim saklanması olayı yoktur. Birbirini kapsayan
  bloklarda böyle bir name lookup işlemi yapılmaksızın program hata verecektir.

- Java'da içine değer atılmamış bir değişken kullanılamaz. Yerel değişkenlere değer atanması programcının
  sorumluluğundadır. Yerel değişkenlere otomatik olarak değer atanmaz.

- Java Değişken isimleri lower-upper case sensitiv olarak değerlenir.
	int val, Val, VAL, vAl; // hepsi geçerli

- Klavyeden int isteme kalıbı
	java.util.Scanner kb = new java.util.Scanner(System.in);
	int a = Integer.parseInt(kb.nextLine());
- Klavyeden double isteme kalıbı
	java.util.Scanner kb = new java.util.Scanner(System.in);
	double a = Double.parseDouble(kb.nextLine());
- Değişken isimleri doğrudan anahtar smzcüklerden oluşamaz. Ancak bunun istisnaları vardır.(var anahtar sözcüğü)

- değişken isimleri camelcase kuralına, Sınıf isimleri Pascal(Baş harfi büyük) kuralına göre yazılır. Paket
  isimlerinin hepsi küçük yazılır.

- V&V(Verification//Kodun doğru çalışması&Validation//Kodun doğru işi yapması)

- fonksiyonlarda return ifadesi geçici bir nesne oluşturulup fonksiyon çağrısının kullanıldığı yere koyulur.


- Cast işlemleri, dönüşümler(conversions)

- derleyici eğer ki tür dönüşümü durumunda bir değer kaybı söz konusu değilse dönüşümü otomatik olarak gerçekleştirir.
  Değer kaybının söz olduğu döünşümler otomatik olarak yapılmaz. Kullanıcı tarafından yapımı zorunludur.

- Küçük tam sayı türünden büyük tam sayı türüne doğrudan atama(implicit assignment) geçerlidir.
  implicit dönüştürme operatörü olmaksızın dönüştürmeişleminin yapılması anlamında gelir.(kesin dönüşüm)

- küçük tam sayı türünden büyüğe yapılan atama negatif bir değerde yapılıyor ise geriye kalan bitler bir ile beslenir.
  Eğer sayı pozitif ise bit'ler 0 ile beslenir.
- char türünden short'a short' türünden de char doğrudan atama geçersizdir.

- byte türden ve short türünden nesnelere sabit sayılar ile kendi sınırları içerisinde kalmak şartı ile
  yani byte için en fazla 1 byte'lık short içinde en fazla iki byte'lık sınır içerisinde yazma koşulu ile
  sabit sayı atanabilir.
   byte = 128;// error

- Sınırlar içerisinde kalmak koşulu ile int türden bir sabit char türüne doğrudan atanabilir

- float türünden double türüne doğrudan atama vardır.

- bool türünden hiç bir türüne ve hiç bir türden de bool türüne atama yada dönüşüm(cast) yapılamaz.

- hiç bir türden byte türüne doğrudan atama yapılamaz(2 byte sınırlar içerisindeki int değerleri hariç).
- char türünden short türüne, ve short türünden char türüne doğrudan atama geçersizdir.
    (Nedeni char türde negatif değişkenlerin olmamasından kaynaklıdır.)
***************************************************************
***************************************************************
***************************************************************
	byte 	-> short, int, long, float, double
 	short 	-> int, long, float, double
 	int 	-> long, float double
 	long 	-> float, double
 	char 	-> int, long, float, double
 	float 	-> double
***************************************************************
***************************************************************
***************************************************************

- java da bir değişkenin kullanılabilirlik alanı

	do {
	int val = 0;
	}while(val == 0)// errordur val değişkeni do'ya ait küme parentezinde tanımlıdır.

- geri dönüş değerlerinde sabit değerler(int) sınırlar içerisindeyse otomatikman short,byte ve char türler için
  geçerlidir.
- sabit tam sayı(10,20,35 gibi) değerleri fonksiyon çağrı konumunda char, short ve byte'a otomatik olarak dönüşmez.


- int türü ve altındaki değerler kendi aralarında aritmetik işleme sokuldaklarında integral promotion'a tabi olurlar.

- boolean türü hiç bir tür ile işleme sokulamaz.
- boolean türünden herhangi bir türe ve herhangi bir türden boolean türüne dönüşüm yapılamaz.

- Büyük tamsayı türünden küçük tamsayı türüne yapılan bilinçli dönüşümde büyük
	tamsayı türüne ilişkin değer küçük tamsayının sınırlar içerisinde bilgi kaybı
	oluşmaz. Aslında bu dönüşüm yüksek anlamlı byte değerlerinin atılması ile
	gerçekleşir. Yani örneğin long türünden int türüne dönüşümde long türüne
	ilişkin değerin yüksek anlamlı 4 byte lık kısmı atılır. Geri kalan 4 byte
	int türüne atanır. Bu durumda kaynak türün içeriisndeki değer hedef
	türün sınırları içerisinde kalıyorsa bu değerin yüksek anlamlı atılacak
	byteların değerleri sıfırdır. Bu durumda kaynak türün içeriisndeki değer
	hedef türün sınırları dışındaysa bilgi kaybı olur

- byte türünden char türüne explicit dönüşüm

- String sınıfının format(static public) methodu printf interface'i ile bir yazıyı
  alıp bize String döndürür.

- String sınıfının valueOf sınıfları verilen değişkenleri String'e dönüştürür.

- int bir değeri String değerine dönüştürmek
	1- val + ""//boş string
	2- String.valueOf(val);// Her biri
	3- String.format("%d",val);//

- Bir sayıyı yazıya çevirmek için
  - parseInt,parseDouble method'ları;//çeviri başarısız ise Exceptiın gönderir.

- Wrapper sınıflar
	Integer,Double, Long,Float gibi sınıflardır.


- immutable sınıf, sınıf türünden nesne yaratıldığında nesnenin içeriği değiştirilemediği sınıflardır.

- String sınıfı bir immutable sınıftır.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                        26.01.2020
///////////////////////////////////////////////////////////////////////////////////////////////////- javac her sınıf(aynı yada farklı paketlerde olması farketmeksizin) için .class uzantılı dosya(byte code) üretir.


- Bir sınıf herhangi bir pakette olabilir. Bir proje içerisinde kullanıla- .class dosyaları mutlaka
n sınıfların aynı pakette
  olma zorunluluğu yoktur

- Bir paket içerisinde bildirilen bir sınıfın farklı bir paketten kullanılabilmesi için
  public olarak bildirilmesi gerekir. public olarak bildirilmeyen bir sınıf ancak
  aynı paketteki diğer sınıflar tarafından kullanılabilir (friendly, internal//bunlar public yazmamanın anlamıdır. Anahtör sözcük değillerdir.)

- Farklı paketlerdeki sınıflar için byte kodların da uygun yerde olması gerekir. Uygulamanın çalışmaya
  başlatıldığı dizin tüm paketlerin olması gereken dizindir(java csd.App). Ancak bu durumun istisnaları olabilir(Source folder : aynı pakette olup farklı directory'lerde
  .class dosyaları kullanabilirsin.)

- Bir paket içerisinde aynı isimde birden fazla sınıf bildirimi yapılamaz. Farklı paketler
  içerisinde aynı isimde sınıflar olabilir. Farklı paketler içinde aynı isimde class'lar kullanılabilir.

- Bir .java dosyası içerisindeki sınıflar o java dosyasının başında bildirilen paket içerisinde
  	 olurlar.

- Bir .java dosyasında farklı paket bildirimleri yapılamaz

- Hiç bir paket bildirimi olmayan .java dosyalarında bildirilen sınıflar isimsiz paket
  (unnamed package) denilen bir paket içerisinde kabul edilir.
  Ancak projelerde isimsiz paket içerisinde sınıf bildirimi yapılmamalıdır.

- Bir paket içerisinde alt paketler olabilir. Alt paketler
  package <paket ismi>.<alt paket ismi>;

  biçiminde bildirilir. Alt paketlerde bulunan sınıfların .class dosyaları (byte code) paket
  hiyararşisine uygun alt dizinlerde bulunmalıdır.

- Paketler içiçe bile olsa farklı paketlerdir. Yani örneğin org.csystem.util paketi içerisinde
  ArrayUtil sınıfı varsa org.csystem paketi içerisinde de ArrayUtil sınıfı olabilir.
  Bu isimler kesinlikle çakışmaz.

- Paket isimleri genelde firmaya ilişkin tekil bir bilgi olan domain isimleri ile
  belirlenir. Örneğin CSD firmasının paketleri ve sınıfları domain adresi "csystem.org"
  olduğundan "org.csystem" paketi altında yazılabilir(spring framework'ünde her şey org.spring ile başlar)

 - Domain isminin altında da paketler olur.(Örneğin org.spring.util)
- android'in bütün paketleri android ile başlar.

- Bundan sonraki uygulamalarda org.csystem şeklinde başlatılacaktır.

- java nın standart tüm paketleri ve sınıfları java isimli bir paket altında toplanmıştır

- java.lang isimli paket altında bulunan tüm sınıflar her yerden görülebilirdir. Yani
  buradaki isimleri paket ismi ile kombine etmeye gerek yoktur (import deyimi kullanılmadan da
  olmadan da  kullanılabilir, Örneğin String sınıfı java.lang package'i altında tanımlanmıştır.)

- Bu sadece java.lang'a özgüdür.

///////////////////////////////////////////////////////////////////////////////////////////////////                                 İsim arama kuralları
///////////////////////////////////////////////////////////////////////////////////////////////////- bir isim doğrudan kullanılmış ise veya . operatörünün solunda kalıyor ise niteliksiz(unqualified) olarak aranır.
 	Sample s =  new Sample();//Sample niteliksiz aranır
 	s.foo(); // burada s niteliksiz foo nitelikli aranır.
 	Sample.bar() // Sample niteliksiz bar fonksiyonu nitelikli aranır(qualified).


- Niteliksiz isim arama(name lookup) kuralları(eğer kurallardan biri gerçekleşirse diğerine bakılmaz)
	1-) Bir metot içerisinde kullanılan bir isim kullanıldığı yerden yukarıya doğru metot içerisinde
	    ve metot'un parametre parantezinde aranır.(Bu kuralın ayrıntıları vardır.(this keyword))
	2-) Metot'un ait olduğu sınıfın içerisinde tüm metotların dışında her yer de aranır. Bulanamazsa taban
	    sınıflarına(super class) da sırasıyla bakılır.
	3-) O sınıfın ait olduğu pakete bakar.Kapsayan, kapsanan paketlere bakılmaz. Bulamazsa error'dur.
		Bu yüzden isimsiz paketlere erişim yoktur. sub package'ları niteliksiz olarak görülemez.

- Aynı Faaliyet alanı içerisinde YEREL değişkenler aynı isimde iki kez tanımlanamaz.
  Bu durum Sınıf'ların member'ları için geçerli değildir.(aynı isimde tanınınabilirler)

- İsim arama kurallarında ilk olarak isim arama yapılır. Uygun kullanıp kullanılamadığına bakılır.

- Nitelikli isim arama() kuralları
	1-) Aranan ismin solunda sınıf ismi var ise, isim sınıf içerisinde aranır bulunamaz ise taban sınıflar içerisine bakılır.
	2-) Aranan ismin solunda referans ismi var ise, isim referansa ilişkin sınıf içerisinde bulunamazsa taban sınıflara bakılır.
	3-) Aranan ismin solunda paket ismi var ise, isim o paket içerisinde aranır bulunamaz ise error oluşur.

- Paket isimleri hiyerarşik bir aramaya tabi değildir. sub package'lar niteliksiz olarak aranamaz. Mutlaka base package'lar
  belirtilmek zorundadır. Niteliksiz arama da  paket isimlerine bakılmaz.
///////////////////////////////////////////////////////////////////////////////////////7
                         import deyimi
///////////////////////////////////////////////////////////////////////////////////////7
- import deyimi iki şekilde kullanılır.
	1- yıldızlı import (import on demand)
	2- yıldızsız import (import type declaration)

- yıldızlı import (import on demand) genel biçimi
	import <paket_ismi>.*;

- import deyimleri .java dosyasında paket bildiriminin altında tür bildirimlerinin üstünde bulunmalıdır.
- import deyimi niteliksiz isim arama da bir isim  çalışılan paket içerisinde bulunamazsa bakılacak paketi de aramaya dahil eder.
  (import java.util.*;//java.util paketinide bak)

- import deyimi niteliksiz isim araması için geçerlidir. Nitelikli isim arama kuralları için hiç bir önemi yoktur.
- import deyimlerinin sırasının hiç bir önemi yoktur.
- import deyimleri paket bildiriminin altında sınıf bildiriminin üstünde olmalıdır.

- Her paket(sub paket'ler buna dahil) birbirinden ayrıdır.

- *'lı import deyiminde eğer niteliksiz arama en son bulunamazsa import deyimine ilişkin paket'te aranır.

- *'sız importta eğer aynı java dosyasında aynı sınıftan bir tane var ve aynı sınıf import deyimi eklenmek isterse
  import declaration'ı hatadır.

- *'lı arama da önce bulunduğu yere sonra dosyaya sonra bulunduğu paket'e pakette de bulunamaz ise import deyimlerine bakar.
- *'sız arama da ise önce bulunduğu dosyaya sonrasında import deyimlerine bulunamaz ise aynı paketin içinde aranır.

- import static directive(deyimi)'i
	import static single type declaration(yıldızsız)
	import static on demand statement (yıldızlı)
- Bu deyimler bir sınıfın static elemanlarının başka bir paket içerisinde
  niteliksiz olarak kullanımını sağlar.

- import static on demand statement(yıldızlı)'ın genel biçimi
  import static [paket ismi].<sınıf ismi>.*;

  import static org.csystem.util.NumberUtil.*;
	public static void main()
	{
		factorial(10);
	}
- import static on demand statement(yıldızsız)'ın genel biçimi
  import static [paket ismi].<sınıf ismi>.<static elemanın ismi>;

  import static org.csystem.util.NumberUtil.factorial;
	public static void main()
	{
		factorial(10);
	}

///////////////////////////////////////////////////////////////////////////////////////////////////
                                     22.02.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
                            foreach(range based for loop)
///////////////////////////////////////////////////////////////////////////////////////////////////
- for (int i = 0; i  < a.length; ++i) {
        int val = a[i];
  }
  for (int val : a) // temsili karşılığı

- döngü değişkeni döngü scope'u boyunca geçerlidir. sonrasında kullanılamaz.

-  forecah'de : noktadan sonraki kısım sSınıf elamanlarının erişim belirleyicileri(access modifiers)adece bir kez yapılır.

- döngü değişkeni ile dolaşabilen türe ilişkin her elemanın atanabileceği türde olması gerekir.

- burada val'e atama yapmak dizi de ki gerçek değeri değiştirmez.

- foreach döngü deyiminde indeks gerektiren bir işlem yazılmamalıdır.
- diziyi tersten dolaşılması gereken durumlarda yapılır.

- for_each döngü deyimi eğer dizi baştan sona dolaşılacak ise kullanılmalıdır.

- Eğer indeks 0'dan değilde başka bir indeksten başlarsa, yada 0'dan başlayıp sonuncu hariç herhangi
  bir indekste bitmesi durumunda kullamılması durumunda kullanılmamalıdır.

- String sınıfı iterable değildir.
    for (char ch : s) // error'dur.
///////////////////////////////////////////////////////////////////////////////////////////////////
                            Sınıf elamanlarının erişim belirleyicileri(access modifiers)
///////////////////////////////////////////////////////////////////////////////////////////////////
-   sınıfın kendisinin erişim belirleyicisi eğer yazılıcak ise public'tir.

- sınıf elemanlarının erişim belirleyicileri
    - public, protected, no-modifier, private

- Java dışındaki dillerde no-modifier ile java da ki farkı çok farklıdır.

- protected ve no-modifier elemanları public ve private'a göre açılır.
- public ve private bir elemanın başka bir sınıf içerisinden erişilip erişilemeyeceği anlamına gelir.

- Sınıfın public bölümümne sınıf dışından aynı pakette yada paketlerde de erişilebilir.
- sınıfın private bölümüne sınıf dışından erişim geçersizdir.

- sınıfın no-modifier bölümü aynı paketteki diğer sınıflar için public'tir.
  Farklı paketteki sınıflar için  ise private etkisinde olacaktır.

- Sınıfın protected bölümü aynı paketteki diğer sınıflar için public'tir.

- Sınıfın protected bölümü türetme söz konusu değil ise farklı paketteki sınıflar için private anlamındadır.

-  Erişim Belirleyici   Kendi      Aynı paketteki sınıflar         Farklı paketteki sınıflar       Türemiş sınıf
   public               +          +                               +                               +
   protected            +          +                               -                               +
   no-modifier          +          +                               -                               -
   private              +          -                               -                               -

///////////////////////////////////////////////////////////////////////////////////////////////////
                                         23.02.2020
///////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////
             Sınıfların elemanlarının gizlenmesi(encapsulation, data hiding)
///////////////////////////////////////////////////////////////////////////////////////////////////

    - Sınıfları yazarken dışarıya vermek istemediğimiz veri elemanlarını private yada uygun erişim belirleyicisini kullanarak
      dışarıya detayların yansımamasıdır.

    - Sınıfların dışarıya yansıtılan(public olan kısımları) sadece dökümente edilir.

- Bir veriyi gizlemek için pratikte aşağıdaki dört  koşuldan birinin  gerçekleşmesi gerekir.(Sıra önemli değildir.)
    1-) Sınıf tasarımının ilerleyen versiyonlarında veri elemanlarının isimlerinin hatta türlerinin değişimesi durumuna
        çok sık rastlanır. Eski kodların client'in kodunun etkilenmemesi için veri gizlenmelidir.

    2-) Bir veri elemanının sınır değerleri olabilir(Öğrencinin isminin boş geçilmesi). Bu sınır değerlerinin
        dışında değerlerin verilmemesi için veri gizlenmelidir.

    3-) Bir veri elemanı değiştiğinde başka bir veri elemanının değeri hesaplanması gerekiyor olabilir.(Örneğin üçgenin
        bir kenarının değişmesi sonucu,alanının değişmesi) Bu durumda veri gizlenmelidir.

    4-) Bir veri elemanı değiştiğinde sınıfın o değere göre başka bir iş yapması gerekiyor  olabilir.
        (Örneğin Date sınıfının, gün değerini tutan değişkenin değiştirilmesi sonucu sınıfın doğru bir tarih mi kontrolü yapması)

    Bu durumların dışında (% 3 - 5 arası) elemanlar public yapılabilir.


- Gizlenmiş bir veri elemanına erişmek için kullanılan methot'lara accessors metotlar denir.
    - Gizlenmiş veri elemanlarının değerlerine erişmik için kullanılan methodlara getter
    - Gizlenmiş veri elemanlarının değerlerini değiştirmek için kullanılan methodlara setter denir.

    - Sınıfların get Metotları genel olarak get ile başlatılır. Bazı ortamlar(framework) bunu default
      olarak isterler. Bu kurala bir sentaks kuralı gibi uymamız gerekir.

    - Sınıfların set metotları genel olarak set ile başlatılır.Bazı ortamlar(framework) bunu default
      olarak isterler. Bu kurala bir sentaks kuralı gibi uymSınıf elamanlarının erişim belirleyicileri(access modifiers)amız gerekir.

- Sınıfların private veri elemanlarının isimlendirilmesinde bazı önemli kurallar vardır.
  bu elemanlar m_day, mDay ile başlamalıdır.(Kursta m_ şeklinde yazılacaktır.) Burada m member anlamındadır.

- eğer member static ms_day msDay şeklindedir.
    - pascal sistemi isimlendirme (Sınıf isimleri bütün kelimelerin baş harfleri küçük)
    - camel case (ilk kelimenin hepsi küçük, diğer kelimelerin baş harfleri büyük)
    - unique isimlendirme(tüm harfler küçük kelimelerin arasında _ kullanılır. Genelde java da kullanılmaz.)

- Javadan boolean türden private elemanlara getter metotları get ile değil is ile başlar.
  Örneğin private boolean m_married değişkeni için isMarried kullanılır.

- Bir sınıfın default ctor'u haricinde bir ctor yazıldığı zaman default ctor'un yazılıp yazılamayacağına
  o an karar verip duruma göre yazmalıyız. Derleyici tarafından default ctor yazılmaz.


///////////////////////////////////////////////////////////////////////////////////////////////////
                                        29.02.2020
///////////////////////////////////////////////////////////////////////////////////////////////////


- ctor private olabilir.
- Nesne yaratılmasının anlamının olmayacağı sınıflarda ctor'un private olmalıdır.(ArrayUtil sınıfı örnektir.)
  (Array Util, Array Util gibi sınıflara mantıksal static sınıflar denir.)
  Array Util sınıfının herhangi bir non-static veri  elamanı olmayacağı için bir anlamı olmaz.

- NumberUtil sınıfı ve StringUtil sınıfının ctor'uda  private yapılmalıdır.
- Standart kütüphanenin Math sınıfının ctor private'dır.

- String sınıfının default ctor'u public idir ve çok gereksiz bir durumdur. Her seferinde yeni bir nesne oluşturulur.
  Çift tırnak ise bundan çok daha efektif bir kod olur.
  String s = new String(); // bad code
  String s = ""; //effective code

- Design Patterns(Gang of Four Patterns)
    - Nesne yaratan patternler (Creational)
    - Yapısal (Structurel)
    - Davranış(Behaivour)

- Singleton design pattern'i bunlardan biridir. // Aşağıdaki kod lazy implementation denir.
    class Singleton{
        public static Singleton s;
        private Singleton(){}

        public static Singleton getInstance() {

            return s != null ? s : new Singleton();
        }
    }

- static elemanlar program sonuna kadar yaşar. Singleton nesnesi program sonuna kadar yaşayacaktır.
  static elemanlar nesnenin herhangi bir elemanı kullanıldığı anda hayata gelirler.
- set methodlarında eğer aynı değer set edilme durumu var ise ortada bunun kontrol edilmesi gerekir.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                      07.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- Eğer başka bir fonksiyonu tekrar ederek çağırmak algoritmamızı büyük ölçüde yavaşlaştıyor ise bu algoritmanın
  kendisi bu fonksiyon çağrılmadan yazılabilir. (Numbertil'in içindeki nextFibonacci ve next metotları böyle yazılmıştır.)
///////////////////////////////////////////////////////////////////////////////////////////////////
                                     Final keywordu
///////////////////////////////////////////////////////////////////////////////////////////////////

- Bir değişken final olarak belirlendiğinde o değişkene faaliyet alanı boyunca bir kez atama yapılabilir.
  Bu atama ilk değer verme ifadesi olmak zorunda değildir. (Klavyeden bir değer girilebilir.)

-final yerel değişkenler
    final double PI= 3.14;
    - final yerel değişkenler java 8 öncesinde bazı durumlarda gerekliydi. Java 8 sonrasında bu ihtiyaç yoktur.

- Method parametresi final olan değişkenler.
    - Not : methodların parametre değişkenleri method başında bildirilmiş yerel değişkenler gibidir.
    - Java 8 öncesinde zorunluluk dışında şu an için hiç bir anlamı yoktur.
    - Bir metotun parametre değişkeni metot çağrısında yaratılır, metot bittiğinde hayata veda eder.

- final member variables
    - final bir veri elemanına default değer atanmaz. Sınıfı yazan kişinin sorumluluğundadır.
      Değer atanmaması durumu error  olur.
    - final bir non-static   veri elemanlarına 3 yerde değer atanabilir.
      1-) Bildirim noktasında // final int a = 5;
      2-) Ctor içerisinde, Bütün ctor'lar için yapılmalıdır
         (Bütün final değişkenlerin hepsine atama yapmak koşulu ile) // 1. koşul yapılmamış ise

      3-) non-static initializer(İleride göreceğiz.)

- Derleyiciler bir değişkeni final  olarak gördüğünde bunları daha çabuk erişilebilecek bir alana(cache yani önbelleğe)
  koyarlar. Hiç değişmeyecek bir elemanı final belirtmeliyiz. (Derleyici optimizasyon yapacaktır.)
  Bir elemanı final yapılması gerekiyor ise yapılmalıdır.

- Sınıfın static final member variable'larına da default değer atanmaz. Progmramcı sorumluluğundadır.
    2 yerde değer atanabilir.
        1-) Bilidirim sırasında
        2-) sTatic initializer(ileride göreceğiz)
///////////////////////////////////////////////////////////////////////////////////////////////////
                                      08.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- Sınıfın statik veri elemanları o sınıf türünden statik bir fonksiyon yada statik bir member'ı kullanıldığı anda
  hayata gelirler.

- Referans türünden bir tür final olarak belirtilmiş ise sınıfın içindeki bilgiyi değiştirebiliriz.
  Değiştiremeyeceğiz şey referanstır. aslında final referanslar her zaman top lewel const'luğa sahiptir diyebiliriz.
    final Sample s = new Sample();
    s = new Sample; // error
    s.setX(5); // ok

- Ctor'ın geri dönüş değer kavramının olmamasının nedeni programcının doğrudan ctor'ı çağıramamasıdır. Ancak ve ancak
  new operatörü ile runtime da çağırılır.

- private eleman dışarının kullanılmasını istemediğimiz elemandır.

- immutable sınıflarda elemanı final yapmamız gerekir.

- new operatörü aynı değer ile çağırılan immutable nesneler farklı referanslardır.
    String s = new String("ankara");
    String s1 = new String("ankara");
    System.out.println(s == s1); // false

- factory metodlar ctor'u private olan sınıf türünden nesne döndüren public static metot'lardır. Factory metodlar
  bizden bir değer alıp bu değere göre de nesne yaratabilirler.

- IntValue(BigDecimal sınıfı) tarzı sınıfların çok kullanılan veri elemanları örneğin 1, 0 gibi elemanları final static eleman haline
  dönüştürülür.
  class IntValue {
    public static final IntValue ZERO = of(0);
  }

- final keywordu her zaman top level constluk sağlar. low level constluk immutable nesnelerle sağlanabilir.
    final String s = new String();
    s = new String(); // error
    final String [] strings = {"ahet", "bcd", "efg" };
    strings[i] = "ankara"; //ok
    strings = new String[3];//error

- factory metod'lar 8'den önve valueOf ile yazılırken, 8'den sonra of  şeklinde isimlendirilmiştir.


- ctor'ı private olan bir çok sınıf factory metod'a sahiptir. Buna factory pattern denir.

- final anahtar sözcüğünün bir çok kullanımı vardır.  C#' da karşılığı readOnly sözcüğüdür.
    - değişkenlerin final olarak bildirilmesi
    - metotların final bildirilmesi
    - sınıfların final bildirimesi
    - bir kaç yerde daha var.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                      Enum türü
///////////////////////////////////////////////////////////////////////////////////////////////////
- enum türü neden vardır?
    class App {
        public static void main(String [] args)
        {
            StickyMan stickyMan = new StickyMan();

            stickyMan.move(1); //right
            stickyMan.move(3); //left
            stickyMan.move(4); //bottom
            stickyMan.move(2); //top

        }
    }

    class StickyMan {
        //...
        public void move(int direction)
        {
            //...
        }
    }

-  Yukarıda ki örnekte programcı StickyMan sınıfı için gerekli direction bilgilerini  ait değerleri
   her zaman aklında tutması gerekir. move fonksiyonunun içinde örneğin 1 sağ, 2 top, 3 left, 4 bottom
   değerleri için haraket etmektedir. Programcı bu kütüphaneyi kullanan birisi olara her zaman bu değerleri bilmelidir.

- Burada move metodunun parametresi int türden değilde String türünden olabilirdi. Kullanıcı böylelikle
  fonksiyon çağrısını aşağıdaki şekilde yapabilir.
      stickyMan.move("right");
      stickyMan.move("lef"); // burada hata olduğunu farkedemeyecektir.
      stickyMan.move("bottom");
      stickyMan.move("top");

- Ancak yukarıda ki fonksiyon String'lerin karşılaştırması olduğu için int'e göre göreceli yavaş bir fonksiyondur.
  Ayrıca String karşılaştırması runtime' da yapıldığı için programcı hata yapıp bunun nedenini farkedemeyebilir.

- Programcı sınıfı string gibi kullanabileceği ama karşılaştırmanın da int şeklinde yapılabileceği hale getirmesi gerekir.
  Bunun için de static ve final değişkenler kullanılması gerekir.

- Programcı bu durumda stickyMan sınıfınnı aşağıdaki hala getirebilir.
    class App {
            public static void main(String [] args)
            {
                StickyMan stickyMan = new StickyMan();

                stickyMan.move(Direction.RIGHT;
                stickyMan.move(Direction.LEFT);
                stickyMan.move(Direction.BOTTOM);
                stickyMan.move(Direction.TOP);

            }
        }


        class Direction {
         public static final int RIGHT = 1;
         public static final int TOP = 2;
         public static final int LEFT = 3;
         public static final int  BOTTOM = 4;
        }
        class StickyMan {
            //...
            public void move(int direction)
            {
                //...
            }
        }

- Yukarıdaki kodda ki sıkıntı ise move fonksiyonun parametresinin int türden olması ve herhangi bir
  Bildiriminin olmaması (yani okunabilirlik açısından gene zayıf olması) hatta bu fonksiyona sadece Direction sınıfının
  değerlerinin değil başka değerlerinde  atanabiliyor olması gerektiğidir.

  class StickyMan {

    public void move(Direction d)
  }

  class Direction {
    private final int m_ordinal;
    private  final Direction [] m_values = {
        new Direction(0),
        new Direction(1),
        new Direction(2),
        new Direction(3),
    };

    private Direction(int ordinal) {
        m_ordinal = ordinal;
    }
    public static final Direction RIGHT = m_values[0];
    public static final Direction TOP = m_values[1];
    public static final Direction LEFT = m_values[2];
    public static final Direction BOTTOM = m_values[3];

    public static Direction [] values(){
        return m_values;
    }
    public int ordinal() {
        return ordinal;
    }
  }

- enum türleri ctor'ı private yapılmış ve her bir enum türü için     içinde o sınıf türünden bir nesne tutan
  yapılardır.

  class Direction {
    private int m_ordinal;
    private static final Direction [] ms_values =  {
        new Direction(0),
        new Direction(1),
        new Direction(2),
        new Direction(3),
    }
    private Direction(int ordinal) {m_ordinal = ordinal;}

    public static final Direction RIGHT = ms_values[0];
    public static final Direction TOP = ms_values[1];
    public static final Direction LEFT = ms_values[2];
    public static final Direction BOTTOM = ms_values[3];

    public static Direction [] values() {
        return ms_values;
    }
    public int ordinal()
    {
        return  m_ordinal;
    }
  }

- Enum türü bir sınıf türüdür. Bildirimi enum anahtar sözcüğü ile yapılır.
  (Yukarıdaki sınıf aslında enum türünün çok yakın bir gösterimidir.Yukarıdaki fonksiyonların  hepsi enum yazılarak yapılabilir.)

- enum içerisinde bildiren isimler enum sabiti olarak adlandırılır.
- Bu isimler public static final ve ilgili enum türündendir.
- Ancak bildirim sırasında bunlar yazılamaz.

- enum sınıfının toString metodu ilgili sabitin yazısal karşılığını verir.

- her enum sınıfının ordinal(public non-static) metodu referansı gösterdiği indeksin değerini döndürür.

- her enum türünün values metodu bütün sabitlerin  değerlerini tutan bir diziyi döndürür.

- enum türünden bir nesne yaratılamaz.(new ile yapılamaz.)

- enum  türünden nesne sadece içerideki adet kadar yaratılabilir.

- Singleton nesnesinin en kolay yapılışı
  enum Singleton {
    INSTANCE
  }
///////////////////////////////////////////////////////////////////////////////////////////////////
                                            14.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- final değişkenler switch deyimlerinde case ifadesi olarak  kullanılabilirler. Ancak switch deyimlerinde sınıf
  referansları kullanılamaz.

    Direction d = Direction.RIGHT; // Burada direction enum türünden değil yazdığımız sınıftır.
    switch (d) //error. user defined- reference can not use as a switch expression
    {
        case LEFT: // ok
    }


- Enum türleri switch deyiminde ve case'lerde de kullanılabilir.

    Direction d = Direction.LEFT;
    switch (d) //ok
    {
        case Direction.LEFT: // error
        case LEFT: //Doğru hali budur.Direction.LEFT kullanımı error'dur. Çünk
    }

    enum Direction {
        RIGHT,TOP,LEFT,BOTTOM
    }

- enum türü bir referans oldukları için, aynı türden enumlar == ve != operatörleri ile karşılaştırılabilirler.
    Direction d = Direction.LEFT;

    System.out.println(d == Direction.LEFT); // true
    enum Direction {
        RIGHT,TOP,LEFT,BOTTOM
    }


- enum türleri aynı türden ise aşağıdaki üç şekilde karşılaştırılabilir.
  1-) switch deyimleri,
  2-) if deyimleri,
  3-) sınıfın equals fonksiyonu // Bu fonkisiyonda farklı enum türleri karşılaşıtrabilir. == veya !='de bu yapılamaz.


- Enum sınıfının compareTo metodu enumlar arasındaki ordinal'lerin  farkını döndürür.
    enum DayOfWeek {
        SUN, MON, TUE, WED, THU FRI, SAT;
    }

- enum türlerinde en sona eklenen COUNT değeri ile sınıfın uzunluğu, alınabilir.
    enum myClass{
        WEIGHT,POWER,ABILITY, COUNT;
    }

    enum myClass{
            HEIGHT,LENGTH,AGILITY,POWER,ABILITY, COUNT;
    }
    //COUNT'ın ordinal'i myClass'ın uzunluğunu döndürür.

- Her enum türünün valueOf adlı static bir metodu vardır.
- Bu fonksiyona string türünden parametre ile kullanılır.

    Color c = Color.valueOf("GREEN");
    Color c = Color.valueOf("GREE"); //throws Exception

    enum Color {
        REG,GREEN,BLUE;
    }

///////////////////////////////////////////////////////////////////////////////////////////////////
                                            15.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
                                            SINIFLAR ARASI İLİŞKİLER
///////////////////////////////////////////////////////////////////////////////////////////////////

- iki tane sınıf arasında ya hiç ilişki yoktur ya da aşağıdaki dört durumdan yalnızca  biri vardır
    1- composition (İçerme)
    2- aggregation (Birleşme)
    3- Association (Çağrışım)
    4- Inheritance (Türetme, kalıtım)

- İlk üç madde'yi destekleyen doğrudan bir dil desteği yoktur.

- Ama inheritance için bu böyle değildir. İnheritance bir çok dil tarafından  desteklenmektedir.

- Composition ve Aggregation ilişkisi birbirine çok benzemektedir. Bir sınıfın başka bir sınıfı bütünsel olarak
  kullanmasıdır.

- Association ise bir sınıfı bütünsel olarak kullanmamaktadır.

- İki sınıf arasında ilişki var ise biri olmadan diğeri yazılamaz. Yani bir sınıf olmadan diğer sınıf derlenemiyor
  ise buna bağımlılık denir. (Buna Dependency denir)
  Örneğin araba sınıfının motor sınıfına bağımlı olması gibidir.

-

///////////////////////////////////////////////////////////////////////////////////////////////////
                                        COMPOSITION
///////////////////////////////////////////////////////////////////////////////////////////////////

- Composition ilişkisi --has a-- ilişkisidir.

- A ile B arasında A has a B ilişkisinde aşağıdaki kural geçerlidir.
  Yada aşağıdaki iki kural geçerli ise A ile B arasında composition ilişkisi vardır.
      1-) A nesnesine ait B nesnesi başka bir nesne tarafından kullanılamaz.
          (B nesnesi A'nın içinde private bir veri elemanı olmalıdır.)

      2-) A nesnesine ait B nesnesinin ömrü A ile hemen hemen aynı olacaktır. (ctor'larda yaratılabilir.)

- Bu ilişki bütünsel bir ilişkidir. A nesnesi kendisine ait olan B nesnesini bütünsel olarak kullanılır.
    Sınıfın veri elemanı sınıfın bütün metodlarında kullanabilen veri elemanıdır.

- Composition ilişkisinde A Sınıfı B'ye bağımlıdır. (UML'de gösterimini bulabiliriz.)

- Composition'da has a ilişkisi nicelik bakımından değişiklik gösterir.
  Örneğin Car sınıfının bir adet motoru var iken
          Plane sınıfının motor sayısı birden fazla olabilir.(Bu durumda member elemanı Engine türünden dizi olmalıdır.)
///////////////////////////////////////////////////////////////////////////////////////////////////
                                        AGGREGATION
///////////////////////////////////////////////////////////////////////////////////////////////////

- A ile B arasındaki ilişki de --holds a-- şeklinde kullanılır.
- Composition'da ki kurallardan en az  biri delinebilir ise buna aggregation denir. Bütünsellik gene geçerlidir.

  - Aşağıdaki örnekte iki kuralda delinmiştir.
  class A {
    private B m_b;
    public A(B b)
    {
        m_b = b; // new'i kendi yapmıyor. Dışarıdan var olan bir nesneyi alır.
    }

    public B getB(){ return m_b;}  // B elemanı başka sınıflar tarafından kullanılır.
  }

  class B {
    public void doSometing()
    {

    }

   }
///////////////////////////////////////////////////////////////////////////////////////////////////
                                        ASSOCIATION
///////////////////////////////////////////////////////////////////////////////////////////////////

- A sınıfının B sınıfını ihtiyacı ölçüsünde kullanılması,bütünsel kullanım söz konusu değildir.

- A sınıfının bir fonksiyonunun B sınıfı türünden bir referans parametresini kullanmasıdır.  Yada fonksiyonun içinde
  new ile yaratılıp o fonksiyon boyunca kullanılır.

- String nesneleri ile yapılan işlemler yapısal olarak aggregation, aslında aggregation değildir.
- String sınıfı ile aggreagation yapılamaz. (immutable sınıflar ile aggregation yapılamaz.)

- taksi ile sürücü aggregation (Driver'ı dışarıdan alır.)
- taksi ile müşteri ise associationdır.(Sadece bir fonksiyon için kullanılır.)

///////////////////////////////////////////////////////////////////////////////////////////////////
                                        KALITIM
///////////////////////////////////////////////////////////////////////////////////////////////////

- is a ilişkisidir.

- varolan sınıfı kodlarına dokunmadan genişletebilmektir.


///////////////////////////////////////////////////////////////////////////////////////////////////
                                            21.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- A sınıfındna türetilen B sınıfı durumunda (B is a A ) A sınıfına B sınıfının taban sınıfı(base class), B sınıfına ise
  derived(Türemiş class denir.) Bu duruma extension(genişletme) denir.

- Java da bu terimler yerine base class yerine super class, derived class yerine subclass terimi kullanılır.

- Bir sınıfın taban sınıfı dendiğinde o sınıfın türemiş bir sınıf olduğu anlaşılır. Bu taban sınıfa  direct(doğrudan)
  super class yada super class denir. (Vapur ve Deniz Aracı ilişkisi.)

- Indirect super class (Vapur ve Araç ilişkisi)

- Java da multiple inheritance olamaz. Bir sınıf sadece tek bir sınıftan türetilebilir.

- Java da türetme işlemi extends anahtar sözcüğü ile yapılır.

- A sınıfından türetilen bir B sınıfında(class B extends A) A sınıfının private ve non-modifier metodları hariç tüm
  metodları kullanılabilir. Aynı şeyler veri elamanları içinde geçerlidir.

- B sınıfından türetilen bir C sınıfında A sınıfının, ve B sınıfının bütün private ve non-modifier fonksiyonlarını
  kullanabilir.

- C sınıfının base class(yada direct class'ı)'ı B'dir. indirect base class'ı ise A'dır.

- veri elemanları içinde aynı durum içindir.
         B x = new B();
         b.x = 10;
         b.y = 10;
    class B extends A {
        public int y;
    }
    class A {
        public int x;
    }

- türetme durumunda taban sınıf içerisindeki değişkenlerde türemiş sınıf içerisine aktarılır.
- Türetme durumunda taban sınıf türünden nesnenin sizeof'u kadarlık bir bölğm türemiş sınıf türünden nesne içinde bulunur.

- Composition'da ve aggregation'da bu durum sadece içinde diğer sınıf türünden bir referans bulundurur.
- Kalıtımda bu durumda veri elemanları tamamen türemiş sınıfı türünden olur.

- Türemiş sınıf  nesnesinin unluğu e  = taban sınıf nesnesinin uzunluğu ve yeni eklenen
  non-static veri elemanlarının uzunluklarının toplamından daha az olamaz. Fazla olabilir.

- Metodlar sınıf içerisinde yer kaplamaz.

- Bir nesnenin yaratılma aşamaları
    - Bellekte yer ayrılır
    - Veri elemanlarına default değer atanır.
    - Ctor çağırılır.

- Türetilmiş sınıf nesnesi yaratıldığında türemiş sınıfın ilgili ctor'u çağrılmadan önce taban sınıfın
  önceden yaratılması gerekir.  Yani subclass'ın ctor'u çağrılmadan önce super class'ın ctor'ının mutlaka çağrılması gerekir.

- herhangi bir şey belirtilmemiş ise taban sınıfın default ctor'u çağrılır.

- taban sınıfın default ctor'un çağrılmaması için
    - taban sınıfın default ctor'u hiç olmayabilir.(Parametreli bir ctor yazılmıştır.)
    - taban sınıfın default ctor'u private olabilir.
    - yada programcı taban sınıfın default ctor yerine başka bir ctor'un çağrılmasını istiyor olabilir.

- Yukarıdaki durumlarda türemiş sınıf türünden herhangi bir belirtme yapılmadan nesne yaratılamaz.

- Bu durumlarda özel bir sentaks vardır. İsmi super ctor sentaksıdır.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                            super ctor sentaksı
///////////////////////////////////////////////////////////////////////////////////////////////////

- Programcı türemiş sınıfının ctor'unun hemen başında taban sınıfının ilgili ctor'unun çağrılmasını sağlayabilir.

- Bu durumda super ctor sentaksı kullanılabilir.

- super ctor sentaksı ancak ve ancak türemiş sınıfın ctor'u içerisinde geçerlidir. ve ctor'un ilk statement'ı olmalıdır.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                            this ctor sentaksı
///////////////////////////////////////////////////////////////////////////////////////////////////

- this anahtar sözcüğü ile ilgili sınıfın başka bir ctor'ının çağrılması sağlanır.
- bu sentaksı super ctor sentaksından ayıran şey this ctor'u yazılmadığnda herhangi bir şey  yapılmaz,
  ancak super ctor sentaksında bir şey yazılmaz ise taban sınıfın default ctor'ına çağrı yapılır.

-Bunların ayrıca this ve super referansı adı verilen sentaksları vardır. this ctor sentaksı da en başta olmalıdır.

- this sentaksı ve super ctor sentaksı aynı anda kullanımı hatadır. Ve hiç bir tasarım kalıbı bizi bu duruma sürüklemez.

- this sentaksında döngüsel durum geçersizdir.

- A sınıfından türetilmiş bir B sınıfının protected bölümüne (A sınıfı ve B sınıfı ayrı pakettelerdir)
    package test;
    class A {
    protected int x;
    }

    package mest;
    import test.A;
    class B extends A {
        public void foo (){
            A a1 =  new A();

            a1.x; // error, can't access to protected area;
            x = 15; ok, türemiş sınıf kendisine ait elemana erişmiş olur.
        }
    }

- Bir elemanı gizlerken ondan türemiş olan sınıfların erişip erişemeyeceğini  belirlemekte önceden gereklidir.

- Bir veri elemanın protected olması için öncelikli olarak private olmama kurallarının hepsinin sağlanması lazım.

- Programcının

- içeride sarmaladığı bir sınıfın aynı isimli aynı parametreli fonksiyonlarını yazmaya delegate etme denir.
  Buna delegate metod, pass true metod yada forwarding metod denir.

- Java da her sınıf doğrudan yada dolaylı olarak Object sınıfından türetilmiştir.

- Object'in extends ile yazılması sorun oluşturmaz. Ancak yazılmaması daha uygundur.
        B b = (B)a;

- UML diagramları çizerken en tepeye Object sınıfı koyulmaz.

- Java' da türemiş sınıf türünden bir referans taban sınıf türünden bir referansa atanabilir.(upcasting)

- Taban sınıf türünden bir referans türemiş sınıf türünden bir referansa doğrudan atamaz.(down casting)

- taban sınıf türünden türemiş sınıfa atama yapılamamasının sebebi, türemiş sınıf referansının türemiş sınıf
  memberlarını kullanıyor olabilmesi ve runtime error'a sebep olur.

- downcasting tür dönüştürme operatörleri ile de birbirine atanamaz. Bunun istisnai durumları vardır.

- upcasting(Yani taban sınıf ile türemiş sınıfın ortak yeri)'de sadece taban sınıf ile çağırılabilecek fonksiyonları
  çağırabiliriz.


///////////////////////////////////////////////////////////////////////////////////////////////////
                                            22.03.2020
///////////////////////////////////////////////////////////////////////////////////////////////////

- Bir referansın iki türü vardır. static ve dinamik türleridir.

- Bir referansın statik türü o referansın bildirildiği türdür ve hiç bir zaman değişmez.
  Derleme zamanına ilişkin bir bilgidir.
  A a;// a referansının statik türü her zaman A türündendir.
  a = new B(); // a referansının dinamik türü B türündendir.

- Statik tür programda kendi belirttiğimiz türdür.

- Bir referansın türü dendiğinde statik tür anlaşılır.

- Bir referansın dinamik  türü o referansın bellekte gösterdiği nesnenin gerçek türüdür.
- Referansın dinamik türü değişebilir
- Referansın dinamik türü run timeYüksek seviyeli çoğu dil için adreslere doğrudan erişimi diller desteklemi 'a bağlı bir şeydir. Referansa run time'da atanan değer
  dinamik türüdür.


- Java da ve C++'da da bir referansa bağlı olarak çağırabilecek fonksiyonlar referansın dinamik türüne göre değil
  statik türüne göre yapılır.
  A a = new B();

  a. ile ancak ve ancak a'nın statik referansına uygun metodlar çağırabilir. Eğer ki ilgili metod override edilmemiş ise
  (Yani A sınıfının içindeki fonksiyonlar)

- Bir referansın dinamik türü aşağıdaki gibi ekrana yazdırabilir.
    Sout(a.getClass().getName());

- Derleyici çalışma zamanında ki değişebilecek değerleri umursamaz.

- downcasting tür dönüşümlerinde eğer yapılan dönüşümde referansa atanan dinamik tür, o referansı
  kapsıyor ise bu dönüşüm geçerlidir.

- Java da adreslere doğrudan erişim sağlanamamaktadır. Run time da yada aşağı seviyede erişmemizi sağlayan
  araçlar vardır.

- referanslar'da  her zaman statik tür ne ise o türe ilişkin fonksiyonlar ve member'lara erişim sağlanır.
  upcasting kuralıda bu kurala dahil değildir.
///////////////////////////////////////////////////////////////////////////////////////////////////
                                RTTI (RUN TIME TYPE IDENFTIFICATION)-> Çalışma zamanında tür belirleme
///////////////////////////////////////////////////////////////////////////////////////////////////

- instanceof operatörü, iki operandlı  araek bir operatördür, birinci operandı referans ,
  ikinci operandı da referans tür ismidir.
- Operatör birinci operandına ilişkin referansın dinamik türünün ikinci operandına ilişkin türü
  kapsayıp kapsamadığına göre  boolean türüne geri döner.
  if (obj instanceof Employee) // Eğer obj referansının dinamik türü Worker, ProjectWorker, Manager
  SalesManager türünden biri ise doğru dönecektir.
  Yani is a ilişkisine de bakar.

- instanceof operatörünün mantıksal değilini döndüren herhangi bir operatör bulunmaktadır.
  bunu sağlamak için ancak ve ancak if(!(obj instanceof reftype)) şeklinde kullanılabilir.
- ! operatörü instance of'dan öncelikli seviye'ye sahiptir.
///////////////////////////////////////////////////////////////////////////////////////////////////
                                FINAL CLASS
///////////////////////////////////////////////////////////////////////////////////////////////////

- Bir sınıftan türetme yapılması istenmiyor ise  sınıf bildiriminde final olarak belirtilmelidir.
    final class intValue{}

- Genel de immutable sınıflar final olarak yazılır.
  String sınıfı final'dır.

- Dillerde mutlaka türetmeye açmaya veya türetmeye kapatmaya yarayan araçlar vardır.

- Kotlin programa dilinde default olarak bir sınıf türetmeye kapalıdır. Kotlin de türetmeye açmak için bir sentaks vardır.


- final yapmak ayrıca okunabilirliği de etkilemektedir. Programcı final yapılması gerekilen bir sınıfı final
  yapılmaz ise programcıyı okuma yönünden olumsuz etkilemiş oluruz.

- final yapmadan sınıfı türetmyeye kapatmanın yolu ctor'u private yapmaktır. Ancak bir sınıf türetmeye kapatılmak

- Bir sınıfı türetmeye kapatmak için ctor'u private olsa bile mutlaka final bildirilmelidir.
  Hem okunabilirlik, hemde derleyicinin kod optimizasyonu içindir.

- enum türünün ctor'u private olduğundan türetme yapılamaz. ayrıca başına final konulmasına izin verilmez.

///////////////////////////////////////////////////////////////////////////////////////////////////
                                Wrapper(Sarmalayan) Sınıflar
///////////////////////////////////////////////////////////////////////////////////////////////////

- Her temel(primitive) türe karşılık bir sarmalayan sınıf getirilmiştir.
    byte        Byte
    short       Short
    int         Integer
    long        Long

    float       Float
    double      Double

    char        Character(chars'lar ile işlem yapan metodları vardır.)

    boolean     Boolean

- Bu sınıflardan gerçek sayı ve tam sayı türüne ilişkin olanlar yani nümerik sınıfların(Byte, Short, Integer, Long, Float, Double ) türleri
  java.lang.Number isimli bir sınıftan türetilmiştir.
- Bu sınıflar immutable olarak yazılmıştır ve final olarak bildirilmiştir.
- Sarmalayan sınıfların ctor elemanları java 9 ile birlikte deprecated yapılmuıştır. Bu ctor'ların
  Java 5'den itibaren kullanımı kötü bir tekniktir.

- Sarmalayan sınıfların bir çok yararlı statik metodları vardır(Parse metodları, isUpperCase, isLowerCase).
    Nümerik sınıfların parseXXX metodları vardır.
        Integer.parseInt(String s, int radix); // klasik parseInt 10'luk sayı sistemine göre sayıyı alır.

    Nümerik sınıfların sarmaladıkları türe ilişkin bir takım değerleri içeren final static veri elemanları bulunur.
        Her birinde bulunan MAX_VALUE, MIN_VALUE
        Ayrıca Character sınıfının MAX_VALUE, MIN_VALUE değişkenleri vardır. (Bu elemanlarının türü char'dır.)